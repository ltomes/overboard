chapter
Optimisation
with
Flambda
HEVEA
cutname
flambda
html
section
s
flambda
overview
Overview
em
Flambda
is
the
term
used
to
describe
a
series
of
optimisation
passes
provided
by
the
native
code
compilers
as
of
OCaml
4
03
Flambda
aims
to
make
it
easier
to
write
idiomatic
OCaml
code
without
incurring
performance
penalties
To
use
the
Flambda
optimisers
it
is
necessary
to
pass
the
tt
flambda
option
to
the
OCaml
tt
configure
script
There
is
no
support
for
a
single
compiler
that
can
operate
in
both
Flambda
and
non
Flambda
modes
Code
compiled
with
Flambda
cannot
be
linked
into
the
same
program
as
code
compiled
without
Flambda
Attempting
to
do
this
will
result
in
a
compiler
error
Whether
or
not
a
particular
tt
ocamlopt
uses
Flambda
may
be
determined
by
invoking
it
with
the
tt
config
option
and
looking
for
any
line
starting
with
tt
flambda
If
such
a
line
is
present
and
says
tt
true
then
Flambda
is
supported
otherwise
it
is
not
Flambda
provides
full
optimisation
across
different
compilation
units
so
long
as
the
tt
cmx
files
for
the
dependencies
of
the
unit
currently
being
compiled
are
available
A
compilation
unit
corresponds
to
a
single
tt
ml
source
file
However
it
does
not
yet
act
entirely
as
a
whole
program
compiler
for
example
elimination
of
dead
code
across
a
complete
set
of
compilation
units
is
not
supported
Optimisation
with
Flambda
is
not
currently
supported
when
generating
bytecode
Flambda
should
not
in
general
affect
the
semantics
of
existing
programs
Two
exceptions
to
this
rule
are
possible
elimination
of
pure
code
that
is
being
benchmarked
see
section
ref
s
flambda
inhibition
and
changes
in
behaviour
of
code
using
unsafe
operations
see
section
ref
s
flambda
unsafe
Flambda
does
not
yet
optimise
array
or
string
bounds
checks
Neither
does
it
take
hints
for
optimisation
from
any
assertions
written
by
the
user
in
the
code
Consult
the
em
Glossary
at
the
end
of
this
chapter
for
definitions
of
technical
terms
used
below
section
s
flambda
cli
Command
line
flags
The
Flambda
optimisers
provide
a
variety
of
command
line
flags
that
may
be
used
to
control
their
behaviour
Detailed
descriptions
of
each
flag
are
given
in
the
referenced
sections
Those
sections
also
describe
any
arguments
which
the
particular
flags
take
Commonly
used
options
begin
options
item
machine
O2
Perform
more
optimisation
than
usual
Compilation
times
may
be
lengthened
This
flag
is
an
abbreviation
for
a
certain
set
of
parameters
described
in
section
ref
s
flambda
defaults
item
machine
O3
Perform
even
more
optimisation
than
usual
possibly
including
unrolling
of
recursive
functions
Compilation
times
may
be
significantly
lengthened
item
machine
Oclassic
Make
inlining
decisions
at
the
point
of
definition
of
a
function
rather
than
at
the
call
site
s
This
mirrors
the
behaviour
of
OCaml
compilers
not
using
Flambda
Compared
to
compilation
using
the
new
Flambda
inlining
heuristics
for
example
at
tt
O2
it
produces
smaller
tt
cmx
files
shorter
compilation
times
and
code
that
probably
runs
rather
slower
When
using
tt
Oclassic
only
the
following
options
described
in
this
section
are
relevant
tt
inlining
report
and
tt
inline
If
any
other
of
the
options
described
in
this
section
are
used
the
behaviour
is
undefined
and
may
cause
an
error
in
future
versions
of
the
compiler
item
machine
inlining
report
Emit
tt
inlining
files
one
per
round
of
optimisation
showing
all
of
the
inliner
s
decisions
end
options
Less
commonly
used
options
begin
options
item
machine
remove
unused
arguments
Remove
unused
function
arguments
even
when
the
argument
is
not
specialised
This
may
have
a
small
performance
penalty
See
section
ref
ss
flambda
remove
unused
args
item
machine
unbox
closures
Pass
free
variables
via
specialised
arguments
rather
than
closures
an
optimisation
for
reducing
allocation
See
section
ref
ss
flambda
unbox
closures
This
may
have
a
small
performance
penalty
end
options
Advanced
options
only
needed
for
detailed
tuning
begin
options
item
machine
inline
The
behaviour
depends
on
whether
tt
Oclassic
is
used
begin
itemize
item
When
not
in
tt
Oclassic
mode
tt
inline
limits
the
total
size
of
functions
considered
for
inlining
during
any
speculative
inlining
search
See
section
ref
ss
flambda
speculation
Note
that
this
parameter
does
bf
not
control
the
assessment
as
to
whether
any
particular
function
may
be
inlined
Raising
it
to
excessive
amounts
will
not
necessarily
cause
more
functions
to
be
inlined
item
When
in
tt
Oclassic
mode
tt
inline
behaves
as
in
previous
versions
of
the
compiler
it
is
the
maximum
size
of
function
to
be
considered
for
inlining
See
section
ref
ss
flambda
classic
end
itemize
item
machine
inline
toplevel
The
equivalent
of
tt
inline
but
used
when
speculative
inlining
starts
at
toplevel
See
section
ref
ss
flambda
speculation
Not
used
in
tt
Oclassic
mode
item
machine
inline
branch
factor
Controls
how
the
inliner
assesses
whether
a
code
path
is
likely
to
be
hot
or
cold
See
section
ref
ss
flambda
assessment
inlining
item
machine
inline
alloc
cost
machine
inline
branch
cost
machine
inline
call
cost
Controls
how
the
inliner
assesses
the
runtime
performance
penalties
associated
with
various
operations
See
section
ref
ss
flambda
assessment
inlining
item
machine
inline
indirect
cost
machine
inline
prim
cost
Likewise
item
machine
inline
lifting
benefit
Controls
inlining
of
functors
at
toplevel
See
section
ref
ss
flambda
assessment
inlining
item
machine
inline
max
depth
The
maximum
depth
of
any
speculative
inlining
search
See
section
ref
ss
flambda
speculation
item
machine
inline
max
unroll
The
maximum
depth
of
any
unrolling
of
recursive
functions
during
any
speculative
inlining
search
See
section
ref
ss
flambda
speculation
item
machine
no
unbox
free
vars
of
closures
Do
not
unbox
closure
variables
See
section
ref
ss
flambda
unbox
fvs
item
machine
no
unbox
specialised
args
Do
not
unbox
arguments
to
which
functions
have
been
specialised
See
section
ref
ss
flambda
unbox
spec
args
item
machine
rounds
How
many
rounds
of
optimisation
to
perform
See
section
ref
ss
flambda
rounds
item
machine
unbox
closures
factor
Scaling
factor
for
benefit
calculation
when
using
tt
unbox
closures
See
section
ref
ss
flambda
unbox
closures
end
options
paragraph
Notes
begin
itemize
item
The
set
of
command
line
flags
relating
to
optimisation
should
typically
be
specified
to
be
the
same
across
an
entire
project
Flambda
does
not
currently
record
the
requested
flags
in
the
tt
cmx
files
As
such
inlining
of
functions
from
previously
compiled
units
will
subject
their
code
to
the
optimisation
parameters
of
the
unit
currently
being
compiled
rather
than
those
specified
when
they
were
previously
compiled
It
is
hoped
to
rectify
this
deficiency
in
the
future
item
Flambda
specific
flags
do
not
affect
linking
with
the
exception
of
affecting
the
optimisation
of
code
in
the
startup
file
containing
generated
functions
such
as
currying
helpers
Typically
such
optimisation
will
not
be
significant
so
eliding
such
flags
at
link
time
might
be
reasonable
item
Flambda
specific
flags
are
silently
accepted
even
when
the
tt
flambda
option
was
not
provided
to
the
tt
configure
script
There
is
no
means
provided
to
change
this
behaviour
This
is
intended
to
make
it
more
straightforward
to
run
benchmarks
with
and
without
the
Flambda
optimisers
in
effect
item
Some
of
the
Flambda
flags
may
be
subject
to
change
in
future
releases
end
itemize
subsection
ss
flambda
rounds
Specification
of
optimisation
parameters
by
round
Flambda
operates
in
em
rounds
one
round
consists
of
a
certain
sequence
of
transformations
that
may
then
be
repeated
in
order
to
achieve
more
satisfactory
results
The
number
of
rounds
can
be
set
manually
using
the
tt
rounds
parameter
although
this
is
not
necessary
when
using
predefined
optimisation
levels
such
as
with
tt
O2
and
tt
O3
For
high
optimisation
the
number
of
rounds
might
be
set
at
3
or
4
Command
line
flags
that
may
apply
per
round
for
example
those
with
tt
cost
in
the
name
accept
arguments
of
the
form
begin
center
em
n
tt
em
round
tt
em
n
tt
end
center
begin
itemize
item
If
the
first
form
is
used
with
a
single
integer
specified
the
value
will
apply
to
all
rounds
item
If
the
second
form
is
used
zero
based
em
round
integers
specify
values
which
are
to
be
used
only
for
those
rounds
end
itemize
The
flags
tt
Oclassic
tt
O2
and
tt
O3
are
applied
before
all
other
flags
meaning
that
certain
parameters
may
be
overridden
without
having
to
specify
every
parameter
usually
invoked
by
the
given
optimisation
level
section
s
flambda
inlining
Inlining
em
Inlining
refers
to
the
copying
of
the
code
of
a
function
to
a
place
where
the
function
is
called
The
code
of
the
function
will
be
surrounded
by
bindings
of
its
parameters
to
the
corresponding
arguments
The
aims
of
inlining
are
begin
itemize
item
to
reduce
the
runtime
overhead
caused
by
function
calls
including
setting
up
for
such
calls
and
returning
afterwards
item
to
reduce
instruction
cache
misses
by
expressing
frequently
taken
paths
through
the
program
using
fewer
machine
instructions
and
item
to
reduce
the
amount
of
allocation
especially
of
closures
end
itemize
These
goals
are
often
reached
not
just
by
inlining
itself
but
also
by
other
optimisations
that
the
compiler
is
able
to
perform
as
a
result
of
inlining
When
a
recursive
call
to
a
function
within
the
definition
of
that
function
or
another
in
the
same
mutually
recursive
group
is
inlined
the
procedure
is
also
known
as
em
unrolling
This
is
somewhat
akin
to
loop
peeling
For
example
given
the
following
code
begin
verbatim
let
rec
fact
x
if
x
0
then
1
else
x
fact
x
1
let
n
fact
4
end
verbatim
unrolling
once
at
the
call
site
tt
fact
4
produces
with
the
body
of
tt
fact
unchanged
begin
verbatim
let
n
if
4
0
then
1
else
4
fact
4
1
end
verbatim
This
simplifies
to
begin
verbatim
let
n
4
fact
3
end
verbatim
CR
pchambart
A
specific
section
for
unrolling
might
be
worth
telling
when
this
is
beneficial
Flambda
provides
significantly
enhanced
inlining
capabilities
relative
to
previous
versions
of
the
compiler
subsubsection
sss
flambda
inlining
aside
Aside
when
inlining
is
performed
Inlining
is
performed
together
with
all
of
the
other
Flambda
optimisation
passes
that
is
to
say
after
closure
conversion
This
has
three
particular
advantages
over
a
potentially
more
straightforward
implementation
prior
to
closure
conversion
begin
itemize
item
It
permits
higher
order
inlining
for
example
when
a
non
inlinable
function
always
returns
the
same
function
yet
with
different
environments
of
definition
Not
all
such
cases
are
supported
yet
but
it
is
intended
that
such
support
will
be
improved
in
future
item
It
is
easier
to
integrate
with
cross
module
optimisation
since
imported
information
about
other
modules
is
already
in
the
correct
intermediate
language
item
It
becomes
more
straightforward
to
optimise
closure
allocations
since
the
layout
of
closures
does
not
have
to
be
estimated
in
any
way
it
is
known
Similarly
it
becomes
more
straightforward
to
control
which
variables
end
up
in
which
closures
helping
to
avoid
closure
bloat
end
itemize
subsection
ss
flambda
classic
Classic
inlining
heuristic
In
tt
Oclassic
mode
the
behaviour
of
the
Flambda
inliner
mimics
previous
versions
of
the
compiler
Code
may
still
be
subject
to
further
optimisations
not
performed
by
previous
versions
of
the
compiler
functors
may
be
inlined
constants
are
lifted
and
unused
code
is
eliminated
all
as
described
elsewhere
in
this
chapter
See
sections
ref
sss
flambda
functors
ref
ss
flambda
lift
const
and
ref
s
flambda
remove
unused
At
the
definition
site
of
a
function
the
body
of
the
function
is
measured
It
will
then
be
marked
as
eligible
for
inlining
and
hence
inlined
at
every
direct
call
site
if
begin
itemize
item
the
measured
size
in
unspecified
units
is
smaller
than
that
of
a
function
call
plus
the
argument
of
the
tt
inline
command
line
flag
and
item
the
function
is
not
recursive
end
itemize
Non
Flambda
versions
of
the
compiler
cannot
inline
functions
that
contain
a
definition
of
another
function
However
tt
Oclassic
does
permit
this
Further
non
Flambda
versions
also
cannot
inline
functions
that
are
only
themselves
exposed
as
a
result
of
a
previous
pass
of
inlining
but
again
this
is
permitted
by
tt
Oclassic
For
example
begin
verbatim
module
M
sig
val
i
int
end
struct
let
f
x
let
g
y
x
y
in
g
let
h
f
3
let
i
h
4
h
is
correctly
discovered
to
be
g
and
inlined
end
end
verbatim
All
of
this
contrasts
with
the
normal
Flambda
mode
that
is
to
say
without
tt
Oclassic
where
begin
itemize
item
the
inlining
decision
is
made
at
the
bf
call
site
and
item
recursive
functions
can
be
handled
by
em
specialisation
see
below
end
itemize
The
Flambda
mode
is
described
in
the
next
section
subsection
ss
flambda
inlining
overview
Overview
of
Flambda
inlining
heuristics
The
Flambda
inlining
heuristics
used
whenever
the
compiler
is
configured
for
Flambda
and
tt
Oclassic
was
not
specified
make
inlining
decisions
at
call
sites
This
helps
in
situations
where
the
context
is
important
For
example
begin
verbatim
let
f
b
x
if
b
then
x
else
big
expression
let
g
x
f
true
x
end
verbatim
In
this
case
we
would
like
to
inline
tt
f
into
tt
g
because
a
conditional
jump
can
be
eliminated
and
the
code
size
should
reduce
If
the
inlining
decision
has
been
made
after
the
declaration
of
tt
f
without
seeing
the
use
its
size
would
have
probably
made
it
ineligible
for
inlining
but
at
the
call
site
its
final
size
can
be
known
Further
this
function
should
probably
not
be
inlined
systematically
if
tt
b
is
unknown
or
indeed
tt
false
there
is
little
benefit
to
trade
off
against
a
large
increase
in
code
size
In
the
existing
non
Flambda
inliner
this
isn
t
a
great
problem
because
chains
of
inlining
were
cut
off
fairly
quickly
However
it
has
led
to
excessive
use
of
overly
large
inlining
parameters
such
as
tt
inline
10000
In
more
detail
at
each
call
site
the
following
procedure
is
followed
begin
itemize
item
Determine
whether
it
is
clear
that
inlining
would
be
beneficial
without
for
the
moment
doing
any
inlining
within
the
function
itself
The
exact
assessment
of
em
benefit
is
described
below
If
so
the
function
is
inlined
item
If
inlining
the
function
is
not
clearly
beneficial
then
inlining
will
be
performed
em
speculatively
inside
the
function
itself
The
search
for
speculative
inlining
possibilities
is
controlled
by
two
parameters
the
em
inlining
threshold
and
the
em
inlining
depth
These
are
described
in
more
detail
below
begin
itemize
item
If
such
speculation
shows
that
performing
some
inlining
inside
the
function
would
be
beneficial
then
such
inlining
is
performed
and
the
resulting
function
inlined
at
the
original
call
site
item
Otherwise
nothing
happens
end
itemize
end
itemize
Inlining
within
recursive
functions
of
calls
to
other
functions
in
the
same
mutually
recursive
group
is
kept
in
check
by
an
em
unrolling
depth
described
below
This
ensures
that
functions
are
not
unrolled
to
excess
Unrolling
is
only
enabled
if
tt
O3
optimisation
level
is
selected
and
or
the
tt
inline
max
unroll
flag
is
passed
with
an
argument
greater
than
zero
subsection
ss
flambda
by
constructs
Handling
of
specific
language
constructs
subsubsection
sss
flambda
functors
Functors
There
is
nothing
particular
about
functors
that
inhibits
inlining
compared
to
normal
functions
To
the
inliner
these
both
look
the
same
except
that
functors
are
marked
as
such
Applications
of
functors
at
toplevel
are
biased
in
favour
of
inlining
This
bias
may
be
adjusted
see
the
documentation
for
tt
inline
lifting
benefit
below
Applications
of
functors
not
at
toplevel
for
example
in
a
local
module
inside
some
other
expression
are
treated
by
the
inliner
identically
to
normal
function
calls
subsubsection
sss
flambda
first
class
modules
First
class
modules
The
inliner
will
be
able
to
consider
inlining
a
call
to
a
function
in
a
first
class
module
if
it
knows
which
particular
function
is
going
to
be
called
The
presence
of
the
first
class
module
record
that
wraps
the
set
of
functions
in
the
module
does
not
per
se
inhibit
inlining
subsubsection
sss
flambda
objects
Objects
Method
calls
to
objects
are
not
at
present
inlined
by
Flambda
subsection
ss
flambda
inlining
reports
Inlining
reports
If
the
tt
inlining
report
option
is
provided
to
the
compiler
then
a
file
will
be
emitted
corresponding
to
each
round
of
optimisation
For
the
OCaml
source
file
em
basename
tt
ml
the
files
are
named
em
basename
tt
em
round
tt
inlining
org
with
em
round
a
zero
based
integer
Inside
the
files
which
are
formatted
as
org
mode
will
be
found
English
prose
describing
the
decisions
that
the
inliner
took
subsection
ss
flambda
assessment
inlining
Assessment
of
inlining
benefit
Inlining
typically
results
in
an
increase
in
code
size
which
if
left
unchecked
may
not
only
lead
to
grossly
large
executables
and
excessive
compilation
times
but
also
a
decrease
in
performance
due
to
worse
locality
As
such
the
Flambda
inliner
trades
off
the
change
in
code
size
against
the
expected
runtime
performance
benefit
with
the
benefit
being
computed
based
on
the
number
of
operations
that
the
compiler
observes
may
be
removed
as
a
result
of
inlining
For
example
given
the
following
code
begin
verbatim
let
f
b
x
if
b
then
x
else
big
expression
let
g
x
f
true
x
end
verbatim
it
would
be
observed
that
inlining
of
tt
f
would
remove
begin
itemize
item
one
direct
call
item
one
conditional
branch
end
itemize
Formally
an
estimate
of
runtime
performance
benefit
is
computed
by
first
summing
the
cost
of
the
operations
that
are
known
to
be
removed
as
a
result
of
the
inlining
and
subsequent
simplification
of
the
inlined
body
The
individual
costs
for
the
various
kinds
of
operations
may
be
adjusted
using
the
various
tt
inline
cost
flags
as
follows
Costs
are
specified
as
integers
All
of
these
flags
accept
a
single
argument
describing
such
integers
using
the
conventions
detailed
in
section
ref
ss
flambda
rounds
begin
options
item
machine
inline
alloc
cost
The
cost
of
an
allocation
item
machine
inline
branch
cost
The
cost
of
a
branch
item
machine
inline
call
cost
The
cost
of
a
direct
function
call
item
machine
inline
indirect
cost
The
cost
of
an
indirect
function
call
item
machine
inline
prim
cost
The
cost
of
a
em
primitive
Primitives
encompass
operations
including
arithmetic
and
memory
access
end
options
Default
values
are
described
in
section
ref
s
flambda
defaults
below
The
initial
benefit
value
is
then
scaled
by
a
factor
that
attempts
to
compensate
for
the
fact
that
the
current
point
in
the
code
if
under
some
number
of
conditional
branches
may
be
cold
Flambda
does
not
currently
compute
hot
and
cold
paths
The
factor
the
estimated
probability
that
the
inliner
really
is
on
a
em
hot
path
is
calculated
as
frac
1
1
f
d
where
f
is
set
by
tt
inline
branch
factor
and
d
is
the
nesting
depth
of
branches
at
the
current
point
As
the
inliner
descends
into
more
deeply
nested
branches
the
benefit
of
inlining
thus
lessens
The
resulting
benefit
value
is
known
as
the
em
estimated
benefit
The
change
in
code
size
is
also
estimated
morally
speaking
it
should
be
the
change
in
machine
code
size
but
since
that
is
not
available
to
the
inliner
an
approximation
is
used
If
the
estimated
benefit
exceeds
the
increase
in
code
size
then
the
inlined
version
of
the
function
will
be
kept
Otherwise
the
function
will
not
be
inlined
Applications
of
functors
at
toplevel
will
be
given
an
additional
benefit
which
may
be
controlled
by
the
tt
inline
lifting
benefit
flag
to
bias
inlining
in
such
situations
towards
keeping
the
inlined
version
subsection
ss
flambda
speculation
Control
of
speculation
As
described
above
there
are
three
parameters
that
restrict
the
search
for
inlining
opportunities
during
speculation
begin
itemize
item
the
em
inlining
threshold
item
the
em
inlining
depth
item
the
em
unrolling
depth
end
itemize
These
parameters
are
ultimately
bounded
by
the
arguments
provided
to
the
corresponding
command
line
flags
or
their
default
values
begin
itemize
item
tt
inline
or
if
the
call
site
that
triggered
speculation
is
at
toplevel
tt
inline
toplevel
item
tt
inline
max
depth
item
tt
inline
max
unroll
end
itemize
bf
Note
in
particular
that
tt
inline
does
not
have
the
meaning
that
it
has
in
the
previous
compiler
or
in
tt
Oclassic
mode
In
both
of
those
situations
tt
inline
was
effectively
some
kind
of
basic
assessment
of
inlining
benefit
However
in
Flambda
inlining
mode
it
corresponds
to
a
constraint
on
the
search
the
assessment
of
benefit
is
independent
as
described
above
When
speculation
starts
the
inlining
threshold
starts
at
the
value
set
by
tt
inline
or
tt
inline
toplevel
if
appropriate
see
above
Upon
making
a
speculative
inlining
decision
the
threshold
is
reduced
by
the
code
size
of
the
function
being
inlined
If
the
threshold
becomes
exhausted
at
or
below
zero
no
further
speculation
will
be
performed
The
inlining
depth
starts
at
zero
and
is
increased
by
one
every
time
the
inliner
descends
into
another
function
It
is
then
decreased
by
one
every
time
the
inliner
leaves
such
function
If
the
depth
exceeds
the
value
set
by
tt
inline
max
depth
then
speculation
stops
This
parameter
is
intended
as
a
general
backstop
for
situations
where
the
inlining
threshold
does
not
control
the
search
sufficiently
The
unrolling
depth
applies
to
calls
within
the
same
mutually
recursive
group
of
functions
Each
time
an
inlining
of
such
a
call
is
performed
the
depth
is
incremented
by
one
when
examining
the
resulting
body
If
the
depth
reaches
the
limit
set
by
tt
inline
max
unroll
then
speculation
stops
section
s
flambda
specialisation
Specialisation
The
inliner
may
discover
a
call
site
to
a
recursive
function
where
something
is
known
about
the
arguments
for
example
they
may
be
equal
to
some
other
variables
currently
in
scope
In
this
situation
it
may
be
beneficial
to
em
specialise
the
function
to
those
arguments
This
is
done
by
copying
the
declaration
of
the
function
and
any
others
involved
in
any
same
mutually
recursive
declaration
and
noting
the
extra
information
about
the
arguments
The
arguments
augmented
by
this
information
are
known
as
em
specialised
arguments
In
order
to
try
to
ensure
that
specialisation
is
not
performed
uselessly
arguments
are
only
specialised
if
it
can
be
shown
that
they
are
em
invariant
in
other
words
during
the
execution
of
the
recursive
function
s
themselves
the
arguments
never
change
Unless
overridden
by
an
attribute
see
below
specialisation
of
a
function
will
not
be
attempted
if
begin
itemize
item
the
compiler
is
in
tt
Oclassic
mode
item
the
function
is
not
obviously
recursive
item
the
function
is
not
closed
end
itemize
The
compiler
can
prove
invariance
of
function
arguments
across
multiple
functions
within
a
recursive
group
although
this
has
some
limitations
as
shown
by
the
example
below
It
should
be
noted
that
the
em
unboxing
of
closures
pass
see
below
can
introduce
specialised
arguments
on
non
recursive
functions
No
other
place
in
the
compiler
currently
does
this
paragraph
Example
the
well
known
tt
List
iter
function
This
function
might
be
written
like
so
begin
verbatim
let
rec
iter
f
l
match
l
with
h
t
f
h
iter
f
t
end
verbatim
and
used
like
this
begin
verbatim
let
print
int
x
print
endline
Int
to
string
x
let
run
xs
iter
print
int
List
rev
xs
end
verbatim
The
argument
tt
f
to
tt
iter
is
invariant
so
the
function
may
be
specialised
begin
verbatim
let
run
xs
let
rec
iter
f
l
The
compiler
knows
f
holds
the
same
value
as
foo
throughout
iter
match
l
with
h
t
f
h
iter
f
t
in
iter
print
int
List
rev
xs
end
verbatim
The
compiler
notes
down
that
for
the
function
tt
iter
the
argument
tt
f
is
specialised
to
the
constant
closure
tt
print
int
This
means
that
the
body
of
tt
iter
may
be
simplified
begin
verbatim
let
run
xs
let
rec
iter
f
l
The
compiler
knows
f
holds
the
same
value
as
foo
throughout
iter
match
l
with
h
t
print
int
h
this
is
now
a
direct
call
iter
f
t
in
iter
print
int
List
rev
xs
end
verbatim
The
call
to
tt
print
int
can
indeed
be
inlined
begin
verbatim
let
run
xs
let
rec
iter
f
l
The
compiler
knows
f
holds
the
same
value
as
foo
throughout
iter
match
l
with
h
t
print
endline
Int
to
string
h
iter
f
t
in
iter
print
int
List
rev
xs
end
verbatim
The
unused
specialised
argument
tt
f
may
now
be
removed
leaving
begin
verbatim
let
run
xs
let
rec
iter
l
match
l
with
h
t
print
endline
Int
to
string
h
iter
t
in
iter
List
rev
xs
end
verbatim
paragraph
Aside
on
invariant
parameters
The
compiler
cannot
currently
detect
invariance
in
cases
such
as
the
following
begin
verbatim
let
rec
iter
swap
f
g
l
match
l
with
0
t
iter
swap
g
f
l
h
t
f
h
iter
swap
f
g
t
end
verbatim
subsection
ss
flambda
assessment
specialisation
Assessment
of
specialisation
benefit
The
benefit
of
specialisation
is
assessed
in
a
similar
way
as
for
inlining
Specialised
argument
information
may
mean
that
the
body
of
the
function
being
specialised
can
be
simplified
the
removed
operations
are
accumulated
into
a
benefit
This
together
with
the
size
of
the
duplicated
specialised
function
declaration
is
then
assessed
against
the
size
of
the
call
to
the
original
function
section
s
flambda
defaults
Default
settings
of
parameters
The
default
settings
when
not
using
tt
Oclassic
are
for
one
round
of
optimisation
using
the
following
parameters
CR
soon
mshinwell
for
4
04
let
s
autogenerate
these
begin
tableau
l
l
Parameter
Setting
entree
tt
inline
10
entree
tt
inline
branch
factor
0
1
entree
tt
inline
alloc
cost
7
entree
tt
inline
branch
cost
5
entree
tt
inline
call
cost
5
entree
tt
inline
indirect
cost
4
entree
tt
inline
prim
cost
3
entree
tt
inline
lifting
benefit
1300
entree
tt
inline
toplevel
160
entree
tt
inline
max
depth
1
entree
tt
inline
max
unroll
0
entree
tt
unbox
closures
factor
10
end
tableau
subsection
ss
flambda
o2
Settings
at
O2
optimisation
level
When
tt
O2
is
specified
two
rounds
of
optimisation
are
performed
The
first
round
uses
the
default
parameters
see
above
The
second
uses
the
following
parameters
begin
tableau
l
l
Parameter
Setting
entree
tt
inline
25
entree
tt
inline
branch
factor
Same
as
default
entree
tt
inline
alloc
cost
Double
the
default
entree
tt
inline
branch
cost
Double
the
default
entree
tt
inline
call
cost
Double
the
default
entree
tt
inline
indirect
cost
Double
the
default
entree
tt
inline
prim
cost
Double
the
default
entree
tt
inline
lifting
benefit
Same
as
default
entree
tt
inline
toplevel
400
entree
tt
inline
max
depth
2
entree
tt
inline
max
unroll
Same
as
default
entree
tt
unbox
closures
factor
Same
as
default
end
tableau
subsection
ss
flambda
o3
Settings
at
O3
optimisation
level
When
tt
O3
is
specified
three
rounds
of
optimisation
are
performed
The
first
two
rounds
are
as
for
tt
O2
The
third
round
uses
the
following
parameters
begin
tableau
l
l
Parameter
Setting
entree
tt
inline
50
entree
tt
inline
branch
factor
Same
as
default
entree
tt
inline
alloc
cost
Triple
the
default
entree
tt
inline
branch
cost
Triple
the
default
entree
tt
inline
call
cost
Triple
the
default
entree
tt
inline
indirect
cost
Triple
the
default
entree
tt
inline
prim
cost
Triple
the
default
entree
tt
inline
lifting
benefit
Same
as
default
entree
tt
inline
toplevel
800
entree
tt
inline
max
depth
3
entree
tt
inline
max
unroll
1
entree
tt
unbox
closures
factor
Same
as
default
end
tableau
section
s
flambda
manual
control
Manual
control
of
inlining
and
specialisation
Should
the
inliner
prove
recalcitrant
and
refuse
to
inline
a
particular
function
or
if
the
observed
inlining
decisions
are
not
to
the
programmer
s
satisfaction
for
some
other
reason
inlining
behaviour
can
be
dictated
by
the
programmer
directly
in
the
source
code
One
example
where
this
might
be
appropriate
is
when
the
programmer
but
not
the
compiler
knows
that
a
particular
function
call
is
on
a
cold
code
path
It
might
be
desirable
to
prevent
inlining
of
the
function
so
that
the
code
size
along
the
hot
path
is
kept
smaller
so
as
to
increase
locality
The
inliner
is
directed
using
attributes
For
non
recursive
functions
and
one
step
unrolling
of
recursive
functions
although
tt
unroll
is
more
clear
for
this
purpose
the
following
are
supported
begin
options
item
machine
inline
always
or
machine
inline
never
Attached
to
a
em
declaration
of
a
function
or
functor
these
direct
the
inliner
to
either
always
or
never
inline
irrespective
of
the
size
benefit
calculation
If
the
function
is
recursive
then
the
body
is
substituted
and
no
special
action
is
taken
for
the
recursive
call
site
s
machine
inline
with
no
argument
is
equivalent
to
machine
inline
always
item
machine
inlined
always
or
machine
inlined
never
Attached
to
a
function
em
application
these
direct
the
inliner
likewise
These
attributes
at
call
sites
override
any
other
attribute
that
may
be
present
on
the
corresponding
declaration
machine
inlined
with
no
argument
is
equivalent
to
machine
inlined
always
machine
inlined
hint
is
equivalent
to
machine
inline
always
except
that
it
will
not
trigger
warning
55
if
the
function
application
cannot
be
inlined
end
options
For
recursive
functions
the
relevant
attributes
are
begin
options
item
machine
specialise
always
or
machine
specialise
never
Attached
to
a
declaration
of
a
function
or
functor
this
directs
the
inliner
to
either
always
or
never
specialise
the
function
so
long
as
it
has
appropriate
contextual
knowledge
irrespective
of
the
size
benefit
calculation
machine
specialise
with
no
argument
is
equivalent
to
machine
specialise
always
item
machine
specialised
always
or
machine
specialised
never
Attached
to
a
function
application
this
directs
the
inliner
likewise
This
attribute
at
a
call
site
overrides
any
other
attribute
that
may
be
present
on
the
corresponding
declaration
Note
that
the
function
will
still
only
be
specialised
if
there
exist
one
or
more
invariant
parameters
whose
values
are
known
machine
specialised
with
no
argument
is
equivalent
to
machine
specialised
always
item
machine
unrolled
n
This
attribute
is
attached
to
a
function
application
and
always
takes
an
integer
argument
Each
time
the
inliner
sees
the
attribute
it
behaves
as
follows
begin
itemize
item
If
n
is
zero
or
less
nothing
happens
item
Otherwise
the
function
being
called
is
substituted
at
the
call
site
with
its
body
having
been
rewritten
such
that
any
recursive
calls
to
that
function
em
or
any
others
in
the
same
mutually
recursive
group
are
annotated
with
the
attribute
tt
unrolled
n
1
tt
Inlining
may
continue
on
that
body
end
itemize
As
such
n
behaves
as
the
maximum
depth
of
unrolling
end
options
A
compiler
warning
will
be
emitted
if
it
was
found
impossible
to
obey
an
annotation
from
an
tt
inlined
or
tt
specialised
attribute
paragraph
Example
showing
correct
placement
of
attributes
begin
verbatim
module
F
M
sig
type
t
end
struct
let
inline
never
bar
x
x
3
let
foo
x
bar
inlined
42
x
end
inline
never
module
X
F
inlined
struct
type
t
int
end
end
verbatim
section
s
flambda
simplification
Simplification
Simplification
which
is
run
in
conjunction
with
inlining
propagates
information
known
as
em
approximations
about
which
variables
hold
what
values
at
runtime
Certain
relationships
between
variables
and
symbols
are
also
tracked
for
example
some
variable
may
be
known
to
always
hold
the
same
value
as
some
other
variable
or
perhaps
some
variable
may
be
known
to
always
hold
the
value
pointed
to
by
some
symbol
The
propagation
can
help
to
eliminate
allocations
in
cases
such
as
begin
verbatim
let
f
x
y
let
p
x
y
in
fst
p
snd
p
end
verbatim
The
projections
from
tt
p
may
be
replaced
by
uses
of
the
variables
tt
x
and
tt
y
potentially
meaning
that
tt
p
becomes
unused
The
propagation
performed
by
the
simplification
pass
is
also
important
for
discovering
which
functions
flow
to
indirect
call
sites
This
can
enable
the
transformation
of
such
call
sites
into
direct
call
sites
which
makes
them
eligible
for
an
inlining
transformation
Note
that
no
information
is
propagated
about
the
contents
of
strings
even
in
tt
safe
string
mode
because
it
cannot
yet
be
guaranteed
that
they
are
immutable
throughout
a
given
program
section
s
flambda
other
transfs
Other
code
motion
transformations
subsection
ss
flambda
lift
const
Lifting
of
constants
Expressions
found
to
be
constant
will
be
lifted
to
symbol
bindings
that
is
to
say
they
will
be
statically
allocated
in
the
object
file
when
they
evaluate
to
boxed
values
Such
constants
may
be
straightforward
numeric
constants
such
as
the
floating
point
number
tt
42
0
or
more
complicated
values
such
as
constant
closures
Lifting
of
constants
to
toplevel
reduces
allocation
at
runtime
The
compiler
aims
to
share
constants
lifted
to
toplevel
such
that
there
are
no
duplicate
definitions
However
if
tt
cmx
files
are
hidden
from
the
compiler
then
maximal
sharing
may
not
be
possible
paragraph
Notes
about
float
arrays
The
following
language
semantics
apply
specifically
to
constant
float
arrays
By
constant
float
array
is
meant
an
array
consisting
entirely
of
floating
point
numbers
that
are
known
at
compile
time
A
common
case
is
a
literal
such
as
tt
42
0
43
0
begin
itemize
item
Constant
float
arrays
at
the
toplevel
are
mutable
and
never
shared
That
is
to
say
for
each
such
definition
there
is
a
distinct
symbol
in
the
data
section
of
the
object
file
pointing
at
the
array
item
Constant
float
arrays
not
at
toplevel
are
mutable
and
are
created
each
time
the
expression
is
evaluated
This
can
be
thought
of
as
an
operation
that
takes
an
immutable
array
which
in
the
source
code
has
no
associated
name
let
us
call
it
the
em
initialising
array
and
duplicates
it
into
a
fresh
mutable
array
begin
itemize
item
If
the
array
is
of
size
four
or
less
the
expression
will
create
a
fresh
block
and
write
the
values
into
it
one
by
one
There
is
no
reference
to
the
initialising
array
as
a
whole
item
Otherwise
the
initialising
array
is
lifted
out
and
subject
to
the
normal
constant
sharing
procedure
creation
of
the
array
consists
of
bulk
copying
the
initialising
array
into
a
fresh
value
on
the
OCaml
heap
end
itemize
end
itemize
subsection
ss
flambda
lift
toplevel
let
Lifting
of
toplevel
let
bindings
Toplevel
tt
let
expressions
may
be
lifted
to
symbol
bindings
to
ensure
that
the
corresponding
bound
variables
are
not
captured
by
closures
If
the
defining
expression
of
a
given
binding
is
found
to
be
constant
it
is
bound
as
such
the
technical
term
is
a
em
let
symbol
binding
Otherwise
the
symbol
is
bound
to
a
statically
allocated
em
preallocated
block
containing
one
field
At
runtime
the
defining
expression
will
be
evaluated
and
the
first
field
of
the
block
filled
with
the
resulting
value
This
em
initialise
symbol
binding
causes
one
extra
indirection
but
ensures
by
virtue
of
the
symbol
s
address
being
known
at
compile
time
that
uses
of
the
value
are
not
captured
by
closures
It
should
be
noted
that
the
blocks
corresponding
to
initialise
symbol
bindings
are
kept
alive
forever
by
virtue
of
them
occurring
in
a
static
table
of
GC
roots
within
the
object
file
This
extended
lifetime
of
expressions
may
on
occasion
be
surprising
If
it
is
desired
to
create
some
non
constant
value
for
example
when
writing
GC
tests
that
does
not
have
this
extended
lifetime
then
it
may
be
created
and
used
inside
a
function
with
the
application
point
of
that
function
perhaps
at
toplevel
or
indeed
the
function
declaration
itself
marked
as
to
never
be
inlined
This
technique
prevents
lifting
of
the
definition
of
the
value
in
question
assuming
of
course
that
it
is
not
constant
section
s
flambda
unboxing
Unboxing
transformations
The
transformations
in
this
section
relate
to
the
splitting
apart
of
em
boxed
that
is
to
say
non
immediate
values
They
are
largely
intended
to
reduce
allocation
which
tends
to
result
in
a
runtime
performance
profile
with
lower
variance
and
smaller
tails
subsection
ss
flambda
unbox
fvs
Unboxing
of
closure
variables
This
transformation
is
enabled
unless
tt
no
unbox
free
vars
of
closures
is
provided
Variables
that
appear
in
closure
environments
may
themselves
be
boxed
values
As
such
they
may
be
split
into
further
closure
variables
each
of
which
corresponds
to
some
projection
from
the
original
closure
variable
s
This
transformation
is
called
em
unboxing
of
closure
variables
or
em
unboxing
of
free
variables
of
closures
It
is
only
applied
when
there
is
reasonable
certainty
that
there
are
no
uses
of
the
boxed
free
variable
itself
within
the
corresponding
function
bodies
CR
someday
mshinwell
Actually
we
probably
don
t
check
this
carefully
enough
It
needs
a
global
analysis
in
case
there
is
an
out
of
scope
projection
paragraph
Example
In
the
following
code
the
compiler
observes
that
the
closure
returned
from
the
function
tt
f
contains
a
variable
tt
pair
free
in
the
body
of
tt
f
that
may
be
split
into
two
separate
variables
begin
verbatim
let
f
x0
x1
let
pair
x0
x1
in
Printf
printf
foo
n
fun
y
fst
pair
snd
pair
y
end
verbatim
After
some
simplification
one
obtains
begin
verbatim
let
f
x0
x1
let
pair
0
x0
in
let
pair
1
x1
in
Printf
printf
foo
n
fun
y
pair
0
pair
1
y
end
verbatim
and
then
begin
verbatim
let
f
x0
x1
Printf
printf
foo
n
fun
y
x0
x1
y
end
verbatim
The
allocation
of
the
pair
has
been
eliminated
This
transformation
does
not
operate
if
it
would
cause
the
closure
to
contain
more
than
twice
as
many
closure
variables
as
it
did
beforehand
subsection
ss
flambda
unbox
spec
args
Unboxing
of
specialised
arguments
This
transformation
is
enabled
unless
tt
no
unbox
specialised
args
is
provided
It
may
become
the
case
during
compilation
that
one
or
more
invariant
arguments
to
a
function
become
specialised
to
a
particular
value
When
such
values
are
themselves
boxed
the
corresponding
specialised
arguments
may
be
split
into
more
specialised
arguments
corresponding
to
the
projections
out
of
the
boxed
value
that
occur
within
the
function
body
This
transformation
is
called
em
unboxing
of
specialised
arguments
It
is
only
applied
when
there
is
reasonable
certainty
that
the
boxed
argument
itself
is
unused
within
the
function
If
the
function
in
question
is
involved
in
a
recursive
group
then
unboxing
of
specialised
arguments
may
be
immediately
replicated
across
the
group
based
on
the
dataflow
between
invariant
arguments
paragraph
Example
Having
been
given
the
following
code
the
compiler
will
inline
tt
loop
into
tt
f
and
then
observe
tt
inv
being
invariant
and
always
the
pair
formed
by
adding
tt
42
and
tt
43
to
the
argument
tt
x
of
the
function
tt
f
begin
verbatim
let
rec
loop
inv
xs
match
xs
with
fst
inv
snd
inv
x
xs
x
loop2
xs
inv
and
loop2
ys
inv
match
ys
with
4
y
ys
y
loop
inv
ys
let
f
x
Printf
printf
d
n
loop
x
42
x
43
1
2
3
end
verbatim
Since
the
functions
have
sufficiently
few
arguments
more
specialised
arguments
will
be
added
After
some
simplification
one
obtains
begin
verbatim
let
f
x
let
rec
loop
xs
inv
0
inv
1
match
xs
with
inv
0
inv
1
x
xs
x
loop2
xs
inv
0
inv
1
and
loop2
ys
inv
0
inv
1
match
ys
with
4
y
ys
y
loop
ys
inv
0
inv
1
in
Printf
printf
d
n
loop
1
2
3
x
42
x
43
end
verbatim
The
allocation
of
the
pair
within
tt
f
has
been
removed
Since
the
two
closures
for
tt
loop
and
tt
loop2
are
constant
they
will
also
be
lifted
to
toplevel
with
no
runtime
allocation
penalty
This
would
also
happen
without
having
run
the
transformation
to
unbox
specialise
arguments
The
transformation
to
unbox
specialised
arguments
never
introduces
extra
allocation
The
transformation
will
not
unbox
arguments
if
it
would
result
in
the
original
function
having
sufficiently
many
arguments
so
as
to
inhibit
tail
call
optimisation
The
transformation
is
implemented
by
creating
a
wrapper
function
that
accepts
the
original
arguments
Meanwhile
the
original
function
is
renamed
and
extra
arguments
are
added
corresponding
to
the
unboxed
specialised
arguments
this
new
function
is
called
from
the
wrapper
The
wrapper
will
then
be
inlined
at
direct
call
sites
Indeed
all
call
sites
will
be
direct
unless
tt
unbox
closures
is
being
used
since
they
will
have
been
generated
by
the
compiler
when
originally
specialising
the
function
In
the
case
of
tt
unbox
closures
other
functions
may
appear
with
specialised
arguments
in
this
case
there
may
be
indirect
calls
and
these
will
incur
a
small
penalty
owing
to
having
to
bounce
through
the
wrapper
The
technique
of
em
direct
call
surrogates
used
for
tt
unbox
closures
is
not
used
by
the
transformation
to
unbox
specialised
arguments
subsection
ss
flambda
unbox
closures
Unboxing
of
closures
This
transformation
is
em
not
enabled
by
default
It
may
be
enabled
using
the
tt
unbox
closures
flag
The
transformation
replaces
closure
variables
by
specialised
arguments
The
aim
is
to
cause
more
closures
to
become
closed
It
is
particularly
applicable
as
a
means
of
reducing
allocation
where
the
function
concerned
cannot
be
inlined
or
specialised
For
example
some
non
recursive
function
might
be
too
large
to
inline
or
some
recursive
function
might
offer
no
opportunities
for
specialisation
perhaps
because
its
only
argument
is
one
of
type
tt
unit
At
present
there
may
be
a
small
penalty
in
terms
of
actual
runtime
performance
when
this
transformation
is
enabled
although
more
stable
performance
may
be
obtained
due
to
reduced
allocation
It
is
recommended
that
developers
experiment
to
determine
whether
the
option
is
beneficial
for
their
code
It
is
expected
that
in
the
future
it
will
be
possible
for
the
performance
degradation
to
be
removed
paragraph
Simple
example
In
the
following
code
which
might
typically
occur
when
tt
g
is
too
large
to
inline
the
value
of
tt
x
would
usually
be
communicated
to
the
application
of
the
tt
function
via
the
closure
of
tt
g
begin
verbatim
let
f
x
let
g
y
x
y
in
g
inlined
never
42
end
verbatim
Unboxing
of
the
closure
causes
the
value
for
tt
x
inside
tt
g
to
be
passed
as
an
argument
to
tt
g
rather
than
through
its
closure
This
means
that
the
closure
of
tt
g
becomes
constant
and
may
be
lifted
to
toplevel
eliminating
the
runtime
allocation
The
transformation
is
implemented
by
adding
a
new
wrapper
function
in
the
manner
of
that
used
when
unboxing
specialised
arguments
The
closure
variables
are
still
free
in
the
wrapper
but
the
intention
is
that
when
the
wrapper
is
inlined
at
direct
call
sites
the
relevant
values
are
passed
directly
to
the
main
function
via
the
new
specialised
arguments
Adding
such
a
wrapper
will
penalise
indirect
calls
to
the
function
which
might
exist
in
arbitrary
places
remember
that
this
transformation
is
not
for
example
applied
only
on
functions
the
compiler
has
produced
as
a
result
of
specialisation
since
such
calls
will
bounce
through
the
wrapper
To
mitigate
this
if
a
function
is
small
enough
when
weighed
up
against
the
number
of
free
variables
being
removed
it
will
be
duplicated
by
the
transformation
to
obtain
two
versions
the
original
used
for
indirect
calls
since
we
can
do
no
better
and
the
wrapper
rewritten
function
pair
as
described
in
the
previous
paragraph
The
wrapper
rewritten
function
pair
will
only
be
used
at
direct
call
sites
of
the
function
The
wrapper
in
this
case
is
known
as
a
em
direct
call
surrogate
since
it
takes
the
place
of
another
function
the
unchanged
version
used
for
indirect
calls
at
direct
call
sites
The
tt
unbox
closures
factor
command
line
flag
which
takes
an
integer
may
be
used
to
adjust
the
point
at
which
a
function
is
deemed
large
enough
to
be
ineligible
for
duplication
The
benefit
of
duplication
is
scaled
by
the
integer
before
being
evaluated
against
the
size
paragraph
Harder
example
In
the
following
code
there
are
two
closure
variables
that
would
typically
cause
closure
allocations
One
is
called
tt
fv
and
occurs
inside
the
function
tt
baz
the
other
is
called
tt
z
and
occurs
inside
the
function
tt
bar
In
this
toy
yet
sophisticated
example
we
again
use
an
attribute
to
simulate
the
typical
situation
where
the
first
argument
of
tt
baz
is
too
large
to
inline
begin
verbatim
let
foo
c
let
rec
bar
zs
fv
match
zs
with
z
zs
let
rec
baz
f
function
a
l
let
r
fv
f
inlined
never
a
in
r
baz
f
l
in
map2
fun
y
z
y
z
2
3
4
bar
zs
fv
in
Printf
printf
d
List
length
bar
1
2
3
4
c
end
verbatim
The
code
resulting
from
applying
tt
O3
unbox
closures
to
this
code
passes
the
free
variables
via
function
arguments
in
order
to
eliminate
all
closure
allocation
in
this
example
aside
from
any
that
might
be
performed
inside
tt
printf
section
s
flambda
remove
unused
Removal
of
unused
code
and
values
subsection
ss
flambda
redundant
let
Removal
of
redundant
let
expressions
The
simplification
pass
removes
unused
tt
let
bindings
so
long
as
their
corresponding
defining
expressions
have
no
effects
See
the
section
Treatment
of
effects
below
for
the
precise
definition
of
this
term
subsection
ss
flambda
redundant
Removal
of
redundant
program
constructs
This
transformation
is
analogous
to
the
removal
of
tt
let
expressions
whose
defining
expressions
have
no
effects
It
operates
instead
on
symbol
bindings
removing
those
that
have
no
effects
subsection
ss
flambda
remove
unused
args
Removal
of
unused
arguments
This
transformation
is
only
enabled
by
default
for
specialised
arguments
It
may
be
enabled
for
all
arguments
using
the
tt
remove
unused
arguments
flag
The
pass
analyses
functions
to
determine
which
arguments
are
unused
Removal
is
effected
by
creating
a
wrapper
function
which
will
be
inlined
at
every
direct
call
site
that
accepts
the
original
arguments
and
then
discards
the
unused
ones
before
calling
the
original
function
As
a
consequence
this
transformation
may
be
detrimental
if
the
original
function
is
usually
indirectly
called
since
such
calls
will
now
bounce
through
the
wrapper
The
technique
of
em
direct
call
surrogates
used
to
reduce
this
penalty
during
unboxing
of
closure
variables
see
above
does
not
yet
apply
to
the
pass
that
removes
unused
arguments
subsection
ss
flambda
removal
closure
vars
Removal
of
unused
closure
variables
This
transformation
performs
an
analysis
across
the
whole
compilation
unit
to
determine
whether
there
exist
closure
variables
that
are
never
used
Such
closure
variables
are
then
eliminated
Note
that
this
has
to
be
a
whole
unit
analysis
because
a
projection
of
a
closure
variable
from
some
particular
closure
may
have
propagated
to
an
arbitrary
location
within
the
code
due
to
inlining
section
s
flambda
other
Other
code
transformations
subsection
ss
flambda
non
escaping
refs
Transformation
of
non
escaping
references
into
mutable
variables
Flambda
performs
a
simple
analysis
analogous
to
that
performed
elsewhere
in
the
compiler
that
can
transform
tt
ref
s
into
mutable
variables
that
may
then
be
held
in
registers
or
on
the
stack
as
appropriate
rather
than
being
allocated
on
the
OCaml
heap
This
only
happens
so
long
as
the
reference
concerned
can
be
shown
to
not
escape
from
its
defining
scope
subsection
ss
flambda
subst
closure
vars
Substitution
of
closure
variables
for
specialised
arguments
This
transformation
discovers
closure
variables
that
are
known
to
be
equal
to
specialised
arguments
Such
closure
variables
are
replaced
by
the
specialised
arguments
the
closure
variables
may
then
be
removed
by
the
removal
of
unused
closure
variables
pass
see
below
section
s
flambda
effects
Treatment
of
effects
The
Flambda
optimisers
classify
expressions
in
order
to
determine
whether
an
expression
begin
itemize
item
does
not
need
to
be
evaluated
at
all
and
or
item
may
be
duplicated
end
itemize
This
is
done
by
forming
judgements
on
the
em
effects
and
the
em
coeffects
that
might
be
performed
were
the
expression
to
be
executed
Effects
talk
about
how
the
expression
might
affect
the
world
coeffects
talk
about
how
the
world
might
affect
the
expression
Effects
are
classified
as
follows
begin
options
item
bf
No
effects
The
expression
does
not
change
the
observable
state
of
the
world
For
example
it
must
not
write
to
any
mutable
storage
call
arbitrary
external
functions
or
change
control
flow
e
g
by
raising
an
exception
Note
that
allocation
is
em
not
classed
as
having
no
effects
see
below
begin
itemize
item
It
is
assumed
in
the
compiler
that
expressions
with
no
effects
whose
results
are
not
used
may
be
eliminated
This
typically
happens
where
the
expression
in
question
is
the
defining
expression
of
a
tt
let
in
such
cases
the
tt
let
expression
will
be
eliminated
It
is
further
assumed
that
such
expressions
with
no
effects
may
be
duplicated
and
thus
possibly
executed
more
than
once
item
Exceptions
arising
from
allocation
points
for
example
out
of
memory
or
exceptions
propagated
from
finalizers
or
signal
handlers
are
treated
as
effects
out
of
the
ether
and
thus
ignored
for
our
determination
here
of
effectfulness
The
same
goes
for
floating
point
operations
that
may
cause
hardware
traps
on
some
platforms
end
itemize
item
bf
Only
generative
effects
The
expression
does
not
change
the
observable
state
of
the
world
save
for
possibly
affecting
the
state
of
the
garbage
collector
by
performing
an
allocation
Expressions
that
only
have
generative
effects
and
whose
results
are
unused
may
be
eliminated
by
the
compiler
However
unlike
expressions
with
no
effects
such
expressions
will
never
be
eligible
for
duplication
item
bf
Arbitrary
effects
All
other
expressions
end
options
There
is
a
single
classification
for
coeffects
begin
options
item
bf
No
coeffects
The
expression
does
not
observe
the
effects
in
the
sense
described
above
of
other
expressions
For
example
it
must
not
read
from
any
mutable
storage
or
call
arbitrary
external
functions
end
options
It
is
assumed
in
the
compiler
that
subject
to
data
dependencies
expressions
with
neither
effects
nor
coeffects
may
be
reordered
with
respect
to
other
expressions
section
s
flambda
static
modules
Compilation
of
statically
allocated
modules
Compilation
of
modules
that
are
able
to
be
statically
allocated
for
example
the
module
corresponding
to
an
entire
compilation
unit
as
opposed
to
a
first
class
module
dependent
on
values
computed
at
runtime
initially
follows
the
strategy
used
for
bytecode
A
sequence
of
tt
let
bindings
which
may
be
interspersed
with
arbitrary
effects
surrounds
a
record
creation
that
becomes
the
module
block
The
Flambda
specific
transformation
follows
these
bindings
are
lifted
to
toplevel
symbols
as
described
above
section
s
flambda
inhibition
Inhibition
of
optimisation
Especially
when
writing
benchmarking
suites
that
run
non
side
effecting
algorithms
in
loops
it
may
be
found
that
the
optimiser
entirely
elides
the
code
being
benchmarked
This
behaviour
can
be
prevented
by
using
the
tt
Sys
opaque
identity
function
which
indeed
behaves
as
a
normal
OCaml
function
and
does
not
possess
any
magic
semantics
The
documentation
of
the
tt
Sys
module
should
be
consulted
for
further
details
section
s
flambda
unsafe
Use
of
unsafe
operations
The
behaviour
of
the
Flambda
simplification
pass
means
that
certain
unsafe
operations
which
may
without
Flambda
or
when
using
previous
versions
of
the
compiler
be
safe
must
not
be
used
This
specifically
refers
to
functions
found
in
the
tt
Obj
module
In
particular
it
is
forbidden
to
change
any
value
for
example
using
tt
Obj
set
field
or
tt
Obj
set
tag
that
is
not
mutable
Values
returned
from
C
stubs
are
always
treated
as
mutable
The
compiler
will
emit
warning
59
if
it
detects
such
a
write
but
it
cannot
warn
in
all
cases
Here
is
an
example
of
code
that
will
trigger
the
warning
begin
verbatim
let
f
x
let
a
42
x
in
Obj
magic
a
int
ref
1
fst
a
end
verbatim
The
reason
this
is
unsafe
is
because
the
simplification
pass
believes
that
tt
fst
a
holds
the
value
tt
42
and
indeed
it
must
unless
type
soundness
has
been
broken
via
unsafe
operations
If
it
must
be
the
case
that
code
has
to
be
written
that
triggers
warning
59
but
the
code
is
known
to
actually
be
correct
for
some
definition
of
correct
then
tt
Sys
opaque
identity
may
be
used
to
wrap
the
value
before
unsafe
operations
are
performed
upon
it
Great
care
must
be
taken
when
doing
this
to
ensure
that
the
opacity
is
added
at
the
correct
place
It
must
be
emphasised
that
this
use
of
tt
Sys
opaque
identity
is
only
for
bf
exceptional
cases
It
should
not
be
used
in
normal
code
or
to
try
to
guide
the
optimiser
As
an
example
this
code
will
return
the
integer
tt
1
begin
verbatim
let
f
x
let
a
Sys
opaque
identity
42
x
in
Obj
magic
a
int
ref
1
fst
a
end
verbatim
However
the
following
code
will
still
return
tt
42
begin
verbatim
let
f
x
let
a
42
x
in
Sys
opaque
identity
Obj
magic
a
int
ref
1
fst
a
end
verbatim
High
levels
of
inlining
performed
by
Flambda
may
expose
bugs
in
code
thought
previously
to
be
correct
Take
care
for
example
not
to
add
type
annotations
that
claim
some
mutable
value
is
always
immediate
if
it
might
be
possible
for
an
unsafe
operation
to
update
it
to
a
boxed
value
section
s
flambda
glossary
Glossary
The
following
terminology
is
used
in
this
chapter
of
the
manual
begin
options
item
bf
Call
site
See
em
direct
call
site
and
em
indirect
call
site
below
item
bf
Closed
function
A
function
whose
body
has
no
free
variables
except
its
parameters
and
any
to
which
are
bound
other
functions
within
the
same
possibly
mutually
recursive
declaration
item
bf
Closure
The
runtime
representation
of
a
function
This
includes
pointers
to
the
code
of
the
function
together
with
the
values
of
any
variables
that
are
used
in
the
body
of
the
function
but
actually
defined
outside
of
the
function
in
the
enclosing
scope
The
values
of
such
variables
collectively
known
as
the
em
environment
are
required
because
the
function
may
be
invoked
from
a
place
where
the
original
bindings
of
such
variables
are
no
longer
in
scope
A
group
of
possibly
mutually
recursive
functions
defined
using
em
let
rec
all
share
a
single
closure
Note
to
developers
in
the
Flambda
source
code
a
em
closure
always
corresponds
to
a
single
function
a
em
set
of
closures
refers
to
a
group
of
such
item
bf
Closure
variable
A
member
of
the
environment
held
within
the
closure
of
a
given
function
item
bf
Constant
Some
entity
typically
an
expression
the
value
of
which
is
known
by
the
compiler
at
compile
time
Constantness
may
be
explicit
from
the
source
code
or
inferred
by
the
Flambda
optimisers
item
bf
Constant
closure
A
closure
that
is
statically
allocated
in
an
object
file
It
is
almost
always
the
case
that
the
environment
portion
of
such
a
closure
is
empty
item
bf
Defining
expression
The
expression
tt
e
in
tt
let
x
e
in
e
item
bf
Direct
call
site
A
place
in
a
program
s
code
where
a
function
is
called
and
it
is
known
at
compile
time
which
function
it
will
always
be
item
bf
Indirect
call
site
A
place
in
a
program
s
code
where
a
function
is
called
but
is
not
known
to
be
a
em
direct
call
site
item
bf
Program
A
collection
of
em
symbol
bindings
forming
the
definition
of
a
single
compilation
unit
i
e
tt
cmx
file
item
bf
Specialised
argument
An
argument
to
a
function
that
is
known
to
always
hold
a
particular
value
at
runtime
These
are
introduced
by
the
inliner
when
specialising
recursive
functions
and
the
tt
unbox
closures
pass
See
section
ref
s
flambda
specialisation
item
bf
Symbol
A
name
referencing
a
particular
place
in
an
object
file
or
executable
image
At
that
particular
place
will
be
some
constant
value
Symbols
may
be
examined
using
operating
system
specific
tools
for
example
tt
objdump
on
Linux
item
bf
Symbol
binding
Analogous
to
a
tt
let
expression
but
working
at
the
level
of
symbols
defined
in
the
object
file
The
address
of
a
symbol
is
fixed
but
it
may
be
bound
to
both
constant
and
non
constant
expressions
item
bf
Toplevel
An
expression
in
the
current
program
which
is
not
enclosed
within
any
function
declaration
item
bf
Variable
A
named
entity
to
which
some
OCaml
value
is
bound
by
a
tt
let
expression
pattern
matching
construction
or
similar
end
options
chapter
Native
debugging
gdb
lldb
label
c
native
debugger
HEVEA
cutname
native
debugger
html
section
s
native
debugger
overview
Overview
This
chapter
describes
the
support
for
debugging
OCaml
executables
built
with
the
native
code
compiler
texttt
ocamlopt
using
standard
native
debuggers
like
GDB
or
LLDB
We
will
call
this
emph
native
debugging
in
contrast
to
bytecode
debugging
supported
via
texttt
ocamldebug
chapter
ref
c
debugger
Native
debugging
is
supported
on
Linux
macOS
and
FreeBSD
platforms
Windows
support
is
not
currently
available
subsection
ss
native
debugger
dwarf
DWARF
OCaml
uses
the
href
http
dwarfstd
org
DWARF
debugging
format
to
describe
the
debugging
information
it
generates
DWARF
is
a
debugging
information
format
used
by
many
compilers
and
debuggers
to
support
source
level
debugging
It
is
used
in
the
ELF
and
Mach
O
executable
formats
The
debugging
information
includes
two
key
components
textbf
Call
Frame
Information
CFI
Describes
how
to
unwind
the
call
stack
to
generate
backtraces
OCaml
s
CFI
information
spans
across
language
boundaries
from
OCaml
code
into
C
runtime
functions
and
through
Foreign
Function
Interface
FFI
calls
when
the
foreign
language
also
provides
CFI
data
textbf
Source
Line
Mapping
Maps
each
machine
instruction
back
to
its
originating
source
location
enabling
debuggers
to
display
OCaml
source
code
and
supporting
source
level
stepping
For
example
the
instruction
at
memory
address
texttt
0xdeadbeef
might
map
to
texttt
myprogram
ml
42
OCaml
defines
its
own
calling
convention
detailing
how
arguments
are
passed
to
functions
how
values
are
returned
from
functions
and
how
registers
are
used
This
information
is
architecture
specific
and
is
documented
in
the
source
code
files
emph
asmcomp
ARCH
proc
ml
for
each
architecture
subsection
ss
native
debugger
name
mangling
Name
Mangling
When
OCaml
compiles
source
code
it
transforms
language
constructs
like
functions
and
module
names
into
emph
mangled
names
that
appear
in
the
final
executable
These
mangled
names
serve
several
purposes
begin
itemize
item
They
ensure
symbol
uniqueness
in
the
compiled
binary
item
They
encode
module
structure
and
namespace
information
item
They
appear
in
debugger
output
such
as
backtraces
and
symbol
lists
item
They
can
be
used
to
set
breakpoints
when
source
file
information
isn
t
available
end
itemize
Current
mangling
scheme
for
OCaml
5
3
onwards
begin
itemize
item
Linux
texttt
caml
MODULE
NAME
FUNCTION
NAME
NNN
item
macOS
and
Windows
MSVC
texttt
caml
MODULE
NAME
FUNCTION
NAME
NNN
end
itemize
where
texttt
NNN
is
a
unique
generated
number
textbf
Example
A
function
texttt
fib
in
module
texttt
MyMath
might
become
texttt
camlMyMath
fib
271
on
Linux
or
texttt
camlMyMath
fib
271
on
macOS
textbf
Note
OCaml
versions
before
5
1
1
used
double
underscores
texttt
caml
MODULE
NAME
FUNCTION
NAME
NNN
subsection
ss
native
debugger
frame
pointers
Frame
Pointers
Frame
pointers
provide
an
alternative
method
for
debuggers
to
walk
the
call
stack
OCaml
supports
frame
pointers
on
AMD64
and
ARM64
platforms
With
frame
pointers
each
function
maintains
a
emph
frame
pointer
that
points
to
the
base
of
its
stack
frame
the
memory
region
allocated
for
that
functions
local
variables
and
call
information
also
known
as
the
activation
frame
or
activation
record
By
chaining
these
pointers
together
with
return
addresses
debuggers
can
reconstruct
the
complete
call
stack
Frame
pointers
are
optional
not
necessary
for
debugging
and
must
be
explicitly
enabled
during
compiler
configuration
see
Profiling
section
ref
s
ocamlprof
compiling
perf
for
details
section
s
native
debugger
compilation
Compiling
for
Debugging
Before
debugging
OCaml
programs
the
native
compiler
texttt
ocamlopt
must
be
installed
with
CFI
support
which
it
is
by
default
You
can
also
explicitly
control
this
with
the
texttt
enable
cfi
configure
flag
when
building
the
compiler
To
perform
source
level
debugging
compile
all
code
with
the
texttt
g
flag
this
records
DWARF
information
for
exception
backtraces
and
generates
line
information
for
mapping
between
assembly
and
source
locations
in
OCaml
Compiling
with
texttt
g
entails
no
runtime
penalty
but
will
generate
larger
binaries
as
they
include
sections
for
debugging
information
Note
that
OCaml
libraries
and
other
dependencies
need
to
be
compiled
with
DWARF
debugging
information
failure
to
do
so
will
lose
source
level
debugging
features
for
those
sections
of
code
Debuggers
need
access
to
source
files
referenced
in
the
DWARF
information
For
dependencies
consider
using
opam
s
build
directory
preservation
begin
verbatim
First
tell
opam
to
keep
the
source
code
export
OPAMKEEPBUILDDIR
1
Then
reinstall
the
packages
to
force
redownloading
the
sources
opam
switch
reinstall
Source
code
for
packages
will
appear
inside
the
opam
switch
in
a
build
directory
e
g
opam
opam
switch
build
for
a
local
switch
or
opam
switch
name
opam
switch
build
end
verbatim
The
following
sections
demonstrate
debugging
OCaml
programs
with
GDB
and
LLDB
showing
common
workflows
and
expected
outputs
section
s
native
debugger
gdb
Using
GDB
Here
we
walk
through
debugging
a
simple
OCaml
program
using
GDB
on
Linux
showing
the
commands
to
use
and
the
expected
outputs
Note
this
session
uses
Ubuntu
24
04
LTS
on
AMD64
with
OCaml
5
4
Consider
the
following
program
begin
caml
example
verbatim
fib
ml
let
rec
fib
n
if
n
0
then
0
else
if
n
1
then
1
else
fib
n
1
fib
n
2
let
main
let
r
fib
20
in
Printf
printf
fib
20
d
r
let
main
end
caml
example
Compile
this
program
with
texttt
ocamlopt
like
so
begin
verbatim
ocamlopt
g
o
fib
exe
fib
ml
fib
exe
20
fib
20
6765
end
verbatim
When
run
this
program
prints
the
20th
Fibonacci
number
The
use
of
recursion
is
an
excuse
to
inspect
the
call
stack
Startup
a
GDB
session
for
this
program
begin
verbatim
gdb
fib
exe
end
verbatim
Breakpoints
can
be
set
using
either
the
mangled
names
produced
by
the
compiler
or
a
combination
of
file
name
and
line
number
For
example
begin
verbatim
gdb
break
camlFib
fib
press
tab
gdb
break
camlFib
fib
271
271
happens
to
be
the
unique
number
generated
Breakpoint
1
at
0x3cd50
file
fib
ml
line
2
gdb
break
fib
ml
7
breakpoint
for
main
function
Breakpoint
2
at
0x3cdc0
file
fib
ml
line
7
end
verbatim
Now
we
can
run
the
program
and
print
a
backtrace
begin
verbatim
gdb
run
Starting
program
fib
exe
Thread
debugging
using
libthread
db
enabled
Using
host
libthread
db
library
lib
x86
64
linux
gnu
libthread
db
so
1
Breakpoint
2
camlFib
main
273
at
fib
ml
7
7
let
main
gdb
continue
Continuing
Breakpoint
1
camlFib
fib
271
at
fib
ml
2
2
let
rec
fib
n
gdb
backtrace
0
camlFib
fib
270
at
fib
ml
2
1
0x0000555555590de1
in
camlFib
main
273
at
fib
ml
7
2
0x0000555555590e86
in
camlFib
entry
at
fib
ml
11
3
0x000055555558eaa7
in
caml
program
4
signal
handler
called
5
0x00005555555de126
in
caml
startup
common
pooling
optimised
out
argv
0x7fffffffe3f8
at
runtime
startup
nat
c
132
6
caml
startup
common
argv
0x7fffffffe3f8
pooling
optimised
out
at
runtime
startup
nat
c
88
7
0x00005555555de19f
in
caml
startup
exn
argv
optimised
out
at
runtime
startup
nat
c
139
8
caml
startup
argv
optimised
out
at
runtime
startup
nat
c
144
9
caml
main
argv
optimised
out
at
runtime
startup
nat
c
151
10
0x000055555558e892
in
main
argc
optimised
out
argv
optimised
out
at
runtime
main
c
37
end
verbatim
There
is
also
basic
support
for
printing
OCaml
values
using
the
built
in
Python
scripting
in
GDB
and
href
https
github
com
ocaml
ocaml
blob
trunk
tools
gdb
py
tools
gdb
py
Either
find
that
file
in
your
opam
switch
e
g
texttt
opam
5
4
0
opam
switch
sources
ocaml
compiler
5
4
0
tools
gdb
py
or
download
it
from
GitHub
Then
load
it
into
GDB
using
source
begin
verbatim
gdb
source
opam
5
4
0
opam
switch
sources
ocaml
compiler
5
4
0
tools
gdb
py
OCaml
support
module
loaded
Values
of
type
value
will
now
print
as
OCaml
values
there
is
a
Array
convenience
function
and
an
ocaml
command
is
available
for
heap
exploration
see
help
ocaml
for
more
information
gdb
p
value
rax
1
caml
14
end
verbatim
We
can
also
print
other
kinds
of
OCaml
values
In
order
to
illustrate
this
consider
the
following
program
begin
caml
example
verbatim
test
blocks
ml
type
t
s
string
i
int
let
main
a
b
print
endline
Hello
world
print
endline
a
print
endline
b
s
let
main
foo
s
bar
i
42
end
caml
example
Compile
this
program
with
texttt
ocamlopt
and
load
it
into
GDB
begin
verbatim
ocamlopt
g
o
test
blocks
exe
test
blocks
ml
gdb
test
blocks
exe
gdb
source
opam
5
4
0
opam
switch
sources
ocaml
compiler
5
4
0
tools
gdb
py
gdb
break
camlTest
blocks
main
273
Breakpoint
1
at
0x16db0
file
test
blocks
ml
line
4
gdb
run
Breakpoint
1
camlTest
blocks
main
273
at
test
blocks
ml
4
4
let
main
a
b
gdb
p
value
rax
Print
out
the
first
argument
to
main
1
caml
foo
3
gdb
p
value
rbx
Then
print
the
second
argument
2
caml
bar
42
caml
bar
3
caml
42
end
verbatim
Note
the
use
of
AMD64
register
names
texttt
rax
and
texttt
rbx
to
access
the
first
and
second
arguments
to
a
function
This
follows
the
OCaml
calling
convention
on
AMD64
where
texttt
rax
to
texttt
r13
hold
OCaml
function
arguments
and
texttt
rax
holds
function
results
Consult
the
texttt
asmcomp
ARCH
proc
ml
file
for
a
specific
architecture
for
further
information
about
OCaml
calling
conventions
Executables
may
not
include
exact
information
about
where
to
find
the
source
code
used
to
build
them
for
various
reasons
In
GDB
this
appears
as
an
absence
of
source
listings
and
a
No
such
file
or
directory
warning
message
In
this
case
GDB
supports
different
ways
to
tell
it
where
to
find
the
sources
Consult
GDB
s
href
https
sourceware
org
gdb
current
onlinedocs
gdb
html
Source
Path
html
Source
Path
documentation
for
full
details
Returning
to
texttt
fib
exe
from
earlier
the
source
file
has
been
copied
to
texttt
tmp
fib
ml
where
GDB
will
not
find
it
Here
we
use
the
GDB
command
texttt
directory
to
tell
GDB
where
to
find
the
source
files
for
texttt
fib
ml
and
the
OCaml
standard
library
begin
verbatim
gdb
fib
exe
gdb
break
camlFib
main
276
gdb
break
camlStdlib
Printf
fprintf
431
gdb
run
Breakpoint
1
0x00005555555921b0
in
camlFib
main
at
fib
ml
7
warning
9
fib
ml
No
such
file
or
directory
Update
directories
to
search
for
source
files
for
fib
ml
and
OCaml
gdb
directory
tmp
opam
5
4
0
opam
switch
sources
ocaml
compiler
5
4
0
Source
directories
searched
tmp
home
user
opam
5
4
0
opam
switch
sources
ocaml
compiler
5
4
0
cdir
cwd
gdb
list
4
else
if
n
1
then
1
5
else
fib
n
1
fib
n
2
6
7
let
main
8
let
r
fib
20
in
9
Printf
printf
fib
20
d
r
10
11
let
main
end
verbatim
subsection
ss
native
debugger
gdb
commands
GDB
Commands
Summary
of
interesting
OCaml
specific
GDB
commands
begin
options
item
break
var
locspec
Set
a
breakpoint
at
all
of
the
code
locations
matching
var
locspec
e
g
Using
the
mangled
OCaml
names
or
specifying
the
linenum
in
the
source
file
as
texttt
filename
linenum
item
backtrace
Print
the
backtrace
of
the
entire
stack
This
will
include
OCaml
source
references
identifying
which
stack
frame
maps
to
a
source
location
e
g
texttt
fib
ml
4
item
disassemble
var
addresses
Display
a
range
of
var
addresses
as
machine
instructions
Typically
used
with
the
mangled
OCaml
names
to
display
the
assembly
for
a
function
item
info
var
frame
This
command
prints
a
verbose
description
of
the
selected
stack
frame
item
list
var
linenum
Print
lines
centered
around
line
number
var
linenum
in
the
current
source
file
This
will
print
the
source
code
for
OCaml
and
the
OCaml
runtime
written
in
C
item
directory
var
dirname
Add
directory
var
dirname
to
the
front
of
the
source
path
several
directory
names
can
be
supplied
separated
by
texttt
Useful
when
directories
change
between
compilation
and
a
debug
session
end
options
See
the
href
https
sourceware
org
gdb
current
onlinedocs
gdb
html
Debugging
with
GDB
documentation
for
more
details
In
general
the
features
described
above
work
with
OCaml
failing
that
GDB
will
fall
back
to
assembly
language
debugging
GDB
is
expected
to
work
on
all
supported
Linux
architectures
section
s
native
debugger
lldb
Using
LLDB
Here
we
will
walk
through
debugging
the
earlier
fib
example
using
LLDB
on
Linux
Startup
an
LLDB
session
using
the
texttt
fib
exe
from
earlier
Note
this
session
uses
Ubuntu
24
04
LTS
on
ARM64
with
OCaml
5
4
begin
verbatim
lldb
fib
exe
Current
executable
set
to
fib
exe
aarch64
lldb
end
verbatim
Breakpoints
can
be
set
using
the
OCaml
mangled
names
or
using
a
combination
of
file
name
and
line
number
For
example
begin
verbatim
lldb
breakpoint
set
n
camlFib
fib
press
tab
for
autocomplete
lldb
breakpoint
set
n
camlFib
fib
271
Breakpoint
2
where
fib
exe
camlFib
fib
271
80
address
0x0000000000052360
lldb
breakpoint
set
f
fib
ml
l
7
breakpoint
for
line
7
in
fib
ml
Breakpoint
2
where
fib
exe
camlFib
main
272
address
0x0000000000051088
lldb
end
verbatim
Now
we
can
run
the
program
begin
verbatim
lldb
run
Process
11391
stopped
thread
1
name
fib
exe
stop
reason
breakpoint
2
1
frame
0
0x0000aaaaaaaf1088
fib
exe
camlFib
main
272
at
fib
ml
7
4
else
if
n
1
then
1
5
else
fib
n
1
fib
n
2
6
7
let
main
8
let
r
fib
20
in
9
Printf
printf
fib
20
d
r
10
lldb
continue
Process
28032
resuming
Process
28032
stopped
thread
1
name
fib
exe
stop
reason
breakpoint
2
1
frame
0
0x0000aaaaaaaf2360
fib
exe
camlFib
fib
271
at
fib
ml
5
2
let
rec
fib
n
3
if
n
0
then
0
4
else
if
n
1
then
1
5
else
fib
n
1
fib
n
2
6
7
let
main
8
let
r
fib
20
in
lldb
bt
Print
a
backtrace
thread
1
name
fib
exe
stop
reason
breakpoint
2
1
frame
0
0x0000aaaaaaaf2360
fib
exe
camlFib
fib
271
at
fib
ml
5
frame
1
0x0000aaaaaaaf23d0
fib
exe
camlFib
main
273
at
fib
ml
8
frame
2
0x0000aaaaaaaf2490
fib
exe
camlFib
entry
at
fib
ml
11
frame
3
0x0000aaaaaaaef748
fib
exe
caml
program
480
frame
4
0x0000aaaaaab4ab90
fib
exe
caml
start
program
132
frame
5
0x0000aaaaaab4a5f8
fib
exe
caml
startup
common
inlined
caml
startup
common
pooling
1430712272
argv
0x0000000000000010
at
startup
nat
c
127
9
frame
6
0x0000aaaaaab4a528
fib
exe
caml
startup
common
argv
0x0000000000000010
pooling
1430712272
at
startup
nat
c
86
7
frame
7
0x0000aaaaaab4a670
fib
exe
caml
main
inlined
caml
startup
exn
argv
unavailable
at
startup
nat
c
134
10
frame
8
0x0000aaaaaab4a66c
fib
exe
caml
main
inlined
caml
startup
argv
unavailable
at
startup
nat
c
139
15
frame
9
0x0000aaaaaab4a66c
fib
exe
caml
main
argv
unavailable
at
startup
nat
c
146
3
frame
10
0x0000aaaaaaaef3d0
fib
exe
main
argc
unavailable
argv
unavailable
at
main
c
37
3
frame
11
0x0000fffff7d784c4
libc
so
6
libc
start
call
main
main
fib
exe
main
at
main
c
31
1
argc
1
argv
0x0000fffffffffc98
at
libc
start
call
main
h
58
16
frame
12
0x0000fffff7d78598
libc
so
6
libc
start
main
impl
main
0x0000aaaaaaba0e68
argc
1
argv
0x0000fffffffffc98
init
unavailable
fini
unavailable
rtld
fini
unavailable
stack
end
unavailable
at
libc
start
c
360
3
frame
13
0x0000aaaaaaaef470
fib
exe
start
48
end
verbatim
There
is
basic
support
for
printing
OCaml
values
using
the
built
in
Python
scripting
in
LLDB
and
href
https
github
com
ocaml
ocaml
blob
trunk
tools
lldb
py
tools
lldb
py
Either
find
that
file
in
your
opam
switch
e
g
texttt
opam
5
4
0
opam
switch
sources
ocaml
compiler
5
4
0
tools
lldb
py
or
download
it
from
github
Then
load
it
into
LLDB
using
texttt
command
begin
verbatim
lldb
command
script
import
opam
5
4
0
opam
switch
sources
ocaml
compiler
5
4
0
tools
lldb
py
OCaml
support
module
loaded
Values
of
type
value
will
now
print
as
OCaml
values
and
an
ocaml
command
is
available
for
heap
exploration
see
help
ocaml
for
more
information
lldb
p
value
x0
value
41
caml
20
lldb
end
verbatim
Note
above
we
are
using
an
ARM64
Linux
machine
so
our
first
argument
is
passed
in
the
first
register
texttt
x0
We
can
also
print
out
all
kinds
of
OCaml
values
Reusing
the
texttt
test
blocks
exe
program
startup
a
new
LLDB
session
begin
verbatim
lldb
test
blocks
exe
lldb
command
script
import
opam
5
4
0
opam
switch
sources
ocaml
compiler
5
4
0
tools
gdb
py
OCaml
support
module
loaded
Values
of
type
value
will
now
print
as
OCaml
values
and
an
ocaml
command
is
available
for
heap
exploration
see
help
ocaml
for
more
information
lldb
breakpoint
set
n
camlTest
blocks
main
274
Breakpoint
1
where
test
blocks
exe
camlTest
blocks
main
274
44
address
0x000000000001a6fc
lldb
run
Process
15536
stopped
thread
1
name
test
blocks
exe
stop
reason
breakpoint
1
1
frame
0
0x0000aaaaaaaba6fc
test
blocks
exe
camlTest
blocks
main
274
at
test
blocks
ml
5
2
type
t
s
string
i
int
3
4
let
main
a
b
5
print
endline
Hello
world
6
print
endline
a
7
print
endline
b
s
8
lldb
p
value
x0
value
187649984957416
caml
Hello
world
13
lldb
p
value
x1
value
187649984957360
caml
bar
42
end
verbatim
Here
we
use
the
ARM64
registers
named
texttt
x0
and
texttt
x1
to
access
the
first
and
second
arguments
to
a
function
This
follows
the
OCaml
calling
convention
on
ARM64
where
texttt
x0
to
texttt
x15
hold
OCaml
function
arguments
Consult
the
texttt
asmcomp
ARCH
proc
ml
file
for
a
specific
architecture
for
further
information
about
OCaml
calling
conventions
LLDB
supports
a
feature
for
specifying
how
to
find
the
sources
In
an
LLDB
session
using
texttt
settings
set
target
source
map
tmp
build
my
src
path
remaps
the
build
directory
to
a
source
directory
and
supports
multiple
pairs
of
texttt
from
to
For
example
copying
the
source
file
texttt
fib
ml
to
texttt
tmp
fib
ml
and
using
an
opam
switch
for
OCaml
5
4
begin
verbatim
lldb
fib
exe
lldb
target
create
fib
exe
Current
executable
set
to
home
user
fib
exe
x86
64
lldb
br
s
n
camlStdlib
Printf
fprintf
431
Breakpoint
1
where
fib
exe
camlStdlib
Printf
fprintf
431
16
address
0x000000000007ddb0
lldb
br
s
f
fib
ml
l
9
Breakpoint
2
where
fib
exe
camlFib
main
276
66
address
0x00000000000482c2
lldb
run
Process
95112
launched
home
user
fib
exe
x86
64
Process
95112
stopped
thread
1
name
fib
exe
stop
reason
breakpoint
1
1
frame
0
0x00005555555d1db0
fib
exe
camlStdlib
Printf
fprintf
431
at
printf
ml
27
21
No
source
listing
displayed
for
printf
ml
file
settings
set
target
source
map
home
user
tmp
home
user
opam
5
4
0
opam
switch
build
ocaml
variants
5
4
0
home
user
opam
5
4
0
opam
switch
sources
ocaml
variants
5
4
0
end
verbatim
subsection
ss
native
debugger
lldb
commands
LLDB
Commands
Summary
of
interesting
OCaml
specific
LLDB
commands
begin
options
item
breakpoint
set
n
var
symbol
Set
a
breakpoint
at
code
location
matching
var
symbol
e
g
Using
the
mangled
OCaml
name
item
breakpoint
set
f
var
filename
l
var
linenum
Set
a
breakpoint
at
var
linenum
in
var
filename
e
g
texttt
fib
ml
7
item
breakpoint
set
a
var
address
Set
a
breakpoint
on
a
memory
var
address
item
backtrace
Print
the
backtrace
of
the
entire
stack
This
will
include
OCaml
source
references
identifying
which
stack
frame
maps
to
a
source
location
item
disassemble
Disassemble
specified
instructions
in
the
current
target
Useful
options
include
texttt
n
plus
mangled
OCaml
name
to
disassemble
a
specific
function
and
texttt
a
plus
an
address
to
disassemble
function
containing
this
address
item
frame
info
List
information
about
the
current
stack
frame
in
the
current
thread
item
source
Commands
for
examining
source
code
described
by
debug
information
for
the
current
target
process
item
settings
set
target
source
map
var
from
var
to
Remaps
var
from
source
paths
var
to
a
new
source
path
which
is
used
when
locating
source
code
to
display
alongside
a
debugged
program
Multiple
pairs
of
var
from
var
to
mappings
are
supported
end
options
In
general
the
features
described
above
work
with
OCaml
failing
that
LLDB
will
fall
back
to
assembly
language
debugging
LLDB
is
expected
to
work
on
all
supported
Linux
architectures
chapter
Dependency
generator
ocamldep
label
c
camldep
HEVEA
cutname
depend
html
The
ocamldep
command
scans
a
set
of
OCaml
source
files
ml
and
mli
files
for
references
to
external
compilation
units
and
outputs
dependency
lines
in
a
format
suitable
for
the
make
utility
This
ensures
that
make
will
compile
the
source
files
in
the
correct
order
and
recompile
those
files
that
need
to
when
a
source
file
is
modified
The
typical
usage
is
begin
alltt
ocamldep
var
options
mli
ml
depend
end
alltt
where
mli
ml
expands
to
all
source
files
in
the
current
directory
and
depend
is
the
file
that
should
contain
the
dependencies
See
below
for
a
typical
Makefile
Dependencies
are
generated
both
for
compiling
with
the
bytecode
compiler
ocamlc
and
with
the
native
code
compiler
ocamlopt
section
s
ocamldep
options
Options
The
following
command
line
options
are
recognized
by
ocamldep
begin
options
item
absname
Show
absolute
filenames
in
error
messages
item
all
Generate
dependencies
on
all
required
files
rather
than
assuming
implicit
dependencies
item
allow
approx
Allow
falling
back
on
a
lexer
based
approximation
when
parsing
fails
item
args
var
filename
Read
additional
newline
terminated
command
line
arguments
from
var
filename
item
args0
var
filename
Read
additional
null
character
terminated
command
line
arguments
from
var
filename
item
as
map
For
the
following
files
do
not
include
delayed
dependencies
for
module
aliases
This
option
assumes
that
they
are
compiled
using
options
no
alias
deps
w
49
and
that
those
files
or
their
interface
are
passed
with
the
map
option
when
computing
dependencies
for
other
files
Note
also
that
for
dependencies
to
be
correct
in
the
implementation
of
a
map
file
its
interface
should
not
coerce
any
of
the
aliases
it
contains
item
debug
map
Dump
the
delayed
dependency
map
for
each
map
file
item
I
var
directory
Add
the
given
directory
to
the
list
of
directories
searched
for
source
files
If
a
source
file
foo
ml
mentions
an
external
compilation
unit
Bar
a
dependency
on
that
unit
s
interface
bar
cmi
is
generated
only
if
the
source
for
bar
is
found
in
the
current
directory
or
in
one
of
the
directories
specified
with
I
Otherwise
Bar
is
assumed
to
be
a
module
from
the
standard
library
and
no
dependencies
are
generated
For
programs
that
span
multiple
directories
it
is
recommended
to
pass
ocamldep
the
same
I
options
that
are
passed
to
the
compiler
item
H
var
directory
Behaves
identically
to
I
except
that
the
H
directories
are
searched
last
This
flag
is
included
to
make
it
easier
to
invoke
ocamldep
with
the
same
options
as
the
compiler
where
H
is
used
for
transitive
dependencies
that
the
program
should
not
directly
mention
item
nocwd
Do
not
add
current
working
directory
to
the
list
of
include
directories
item
impl
var
file
Process
var
file
as
a
ml
file
item
intf
var
file
Process
var
file
as
a
mli
file
item
keywords
var
version
list
Set
keywords
according
to
the
var
version
list
specification
This
specification
starts
with
an
optional
version
number
defining
the
base
set
of
keywords
followed
by
a
var
separated
list
of
additional
keywords
to
add
to
this
base
set
Without
an
explicit
version
number
the
base
set
of
keywords
is
the
set
of
keywords
in
the
current
version
of
OCaml
Additional
keywords
that
do
not
match
any
known
keyword
in
the
current
version
of
the
language
trigger
an
error
whenever
they
are
present
in
the
source
code
item
map
var
file
Read
and
propagate
the
delayed
dependencies
for
module
aliases
in
var
file
so
that
the
following
files
will
depend
on
the
exported
aliased
modules
if
they
use
them
See
the
example
below
item
ml
synonym
var
ext
Consider
the
given
extension
with
leading
dot
to
be
a
synonym
for
ml
item
mli
synonym
var
ext
Consider
the
given
extension
with
leading
dot
to
be
a
synonym
for
mli
item
modules
Output
raw
dependencies
of
the
form
begin
verbatim
filename
Module1
Module2
ModuleN
end
verbatim
where
Module1
ldots
ModuleN
are
the
names
of
the
compilation
units
referenced
within
the
file
filename
but
these
names
are
not
resolved
to
source
file
names
Such
raw
dependencies
cannot
be
used
by
make
but
can
be
post
processed
by
other
tools
such
as
Omake
item
native
Generate
dependencies
for
a
pure
native
code
program
no
bytecode
version
When
an
implementation
file
ml
file
has
no
explicit
interface
file
mli
file
ocamldep
generates
dependencies
on
the
bytecode
compiled
file
cmo
file
to
reflect
interface
changes
This
can
cause
unnecessary
bytecode
recompilations
for
programs
that
are
compiled
to
native
code
only
The
flag
native
causes
dependencies
on
native
compiled
files
cmx
to
be
generated
instead
of
on
cmo
files
This
flag
makes
no
difference
if
all
source
files
have
explicit
mli
interface
files
item
one
line
Output
one
line
per
file
regardless
of
the
length
item
open
var
module
Assume
that
module
var
module
is
opened
before
parsing
each
of
the
following
files
item
pp
var
command
Cause
ocamldep
to
call
the
given
var
command
as
a
preprocessor
for
each
source
file
item
ppx
var
command
Pipe
abstract
syntax
trees
through
preprocessor
var
command
item
shared
Generate
dependencies
for
native
plugin
files
cmxs
in
addition
to
native
compiled
files
cmx
item
slash
Under
Windows
use
a
forward
slash
as
the
path
separator
instead
of
the
usual
backward
slash
backslash
Under
Unix
this
option
does
nothing
item
sort
Sort
files
according
to
their
dependencies
item
version
Print
version
string
and
exit
item
vnum
Print
short
version
number
and
exit
item
help
or
help
Display
a
short
usage
summary
and
exit
end
options
section
s
ocamldep
makefile
A
typical
Makefile
Here
is
a
template
Makefile
for
a
OCaml
program
begin
verbatim
OCAMLC
ocamlc
OCAMLOPT
ocamlopt
OCAMLDEP
ocamldep
INCLUDES
all
relevant
I
options
here
OCAMLFLAGS
INCLUDES
add
other
options
for
ocamlc
here
OCAMLOPTFLAGS
INCLUDES
add
other
options
for
ocamlopt
here
prog1
should
be
compiled
to
bytecode
and
is
composed
of
three
units
mod1
mod2
and
mod3
The
list
of
object
files
for
prog1
PROG1
OBJS
mod1
cmo
mod2
cmo
mod3
cmo
prog1
PROG1
OBJS
OCAMLC
o
prog1
OCAMLFLAGS
PROG1
OBJS
prog2
should
be
compiled
to
native
code
and
is
composed
of
two
units
mod4
and
mod5
The
list
of
object
files
for
prog2
PROG2
OBJS
mod4
cmx
mod5
cmx
prog2
PROG2
OBJS
OCAMLOPT
o
prog2
OCAMLFLAGS
PROG2
OBJS
Common
rules
cmo
ml
OCAMLC
OCAMLFLAGS
c
cmi
mli
OCAMLC
OCAMLFLAGS
c
cmx
ml
OCAMLOPT
OCAMLOPTFLAGS
c
Clean
up
clean
rm
f
prog1
prog2
rm
f
cm
iox
Dependencies
depend
OCAMLDEP
INCLUDES
mli
ml
depend
include
depend
end
verbatim
If
you
use
module
aliases
to
give
shorter
names
to
modules
you
need
to
change
the
above
definitions
Assuming
that
your
map
file
is
called
mylib
mli
here
are
minimal
modifications
begin
verbatim
OCAMLFLAGS
INCLUDES
open
Mylib
mylib
cmi
mylib
mli
OCAMLC
INCLUDES
no
alias
deps
w
49
c
depend
OCAMLDEP
INCLUDES
map
mylib
mli
PROG1
OBJS
cmo
ml
depend
end
verbatim
Note
that
in
this
case
you
should
not
compute
dependencies
for
mylib
mli
together
with
the
other
files
hence
the
need
to
pass
explicitly
the
list
of
files
to
process
If
mylib
mli
itself
has
dependencies
you
should
compute
them
using
as
map
chapter
The
toplevel
system
or
REPL
ocaml
label
c
camllight
HEVEA
cutname
toplevel
html
This
chapter
describes
ocaml
the
toplevel
system
for
OCaml
that
permits
interactive
use
of
the
OCaml
system
through
a
read
eval
print
loop
REPL
In
this
mode
the
system
repeatedly
reads
OCaml
phrases
from
the
input
then
typechecks
compile
and
evaluate
them
then
prints
the
inferred
type
and
result
value
if
any
End
of
file
on
standard
input
terminates
ocaml
Input
to
the
toplevel
can
span
several
lines
It
begins
after
the
sharp
prompt
printed
by
the
system
and
is
terminated
by
a
double
semicolon
followed
by
optional
white
space
and
comments
and
an
end
of
line
The
toplevel
input
consists
in
one
or
several
toplevel
phrases
with
the
following
syntax
begin
syntax
toplevel
input
definition
expr
ident
directive
argument
directive
argument
string
literal
integer
literal
value
path
true
false
end
syntax
A
phrase
can
consist
of
a
sequence
of
definitions
like
those
found
in
implementations
of
compilation
units
or
in
struct
ldots
end
module
expressions
The
definitions
can
bind
value
names
type
names
exceptions
module
names
or
module
type
names
The
toplevel
system
performs
the
bindings
then
prints
the
types
and
values
if
any
for
the
names
thus
defined
A
phrase
may
also
consist
in
a
value
expression
section
ref
s
value
expr
It
is
simply
evaluated
without
performing
any
bindings
and
its
value
is
printed
Finally
a
phrase
can
also
consist
in
a
toplevel
directive
starting
with
the
sharp
sign
These
directives
control
the
behavior
of
the
toplevel
they
are
listed
below
in
section
ref
s
toplevel
directives
begin
unix
The
toplevel
system
is
started
by
the
command
ocaml
as
follows
begin
alltt
ocaml
var
options
var
objects
interactive
mode
ocaml
var
options
var
objects
var
scriptfile
script
mode
end
alltt
var
options
are
described
below
var
objects
are
filenames
ending
in
cmo
or
cma
they
are
loaded
into
the
interpreter
immediately
after
var
options
are
set
var
scriptfile
is
any
file
name
not
ending
in
cmo
or
cma
If
no
var
scriptfile
is
given
on
the
command
line
the
toplevel
system
enters
interactive
mode
phrases
are
read
on
standard
input
results
are
printed
on
standard
output
errors
on
standard
error
End
of
file
on
standard
input
terminates
ocaml
see
also
the
quit
directive
in
section
ref
s
toplevel
directives
On
start
up
before
the
first
phrase
is
read
the
contents
of
initialization
file
are
read
as
a
sequence
of
OCaml
phrases
and
executed
as
per
the
use
directive
described
in
section
ref
s
toplevel
directives
The
evaluation
outcode
for
each
phrase
are
not
displayed
The
initialization
file
is
the
first
found
of
begin
enumerate
item
ocamlinit
in
the
current
directory
item
XDG
CONFIG
HOME
ocaml
init
ml
if
XDG
CONFIG
HOME
is
an
absolute
path
item
otherwise
on
Unix
HOME
ocaml
init
ml
or
on
Windows
ocaml
init
ml
under
LocalAppData
e
g
C
Users
Bactrian
AppData
Local
ocaml
init
ml
item
ocaml
init
ml
under
any
of
the
absolute
paths
in
XDG
CONFIG
DIRS
Paths
in
XDG
CONFIG
DIRS
are
colon
delimited
on
Unix
and
semicolon
delimited
on
Windows
item
if
XDG
CONFIG
DIRS
contained
no
absolute
paths
usr
xdg
ocaml
init
ml
on
Unix
or
ocaml
init
ml
under
any
of
LocalAppData
e
g
C
Users
Bactrian
AppData
Local
RoamingAppData
e
g
C
Users
Bactrian
AppData
Roaming
or
ProgramData
e
g
C
ProgramData
on
Windows
item
HOME
ocamlinit
if
HOME
is
non
empty
end
enumerate
The
toplevel
system
does
not
perform
line
editing
but
it
can
easily
be
used
in
conjunction
with
an
external
line
editor
such
as
ledit
or
rlwrap
An
improved
toplevel
utop
is
also
available
Another
option
is
to
use
ocaml
under
Gnu
Emacs
which
gives
the
full
editing
power
of
Emacs
command
run
caml
from
library
inf
caml
At
any
point
the
parsing
compilation
or
evaluation
of
the
current
phrase
can
be
interrupted
by
pressing
ctrl
C
or
more
precisely
by
sending
the
INTR
signal
to
the
ocaml
process
The
toplevel
then
immediately
returns
to
the
prompt
If
var
scriptfile
is
given
on
the
command
line
to
ocaml
the
toplevel
system
enters
script
mode
the
contents
of
the
file
are
read
as
a
sequence
of
OCaml
phrases
and
executed
as
per
the
use
directive
section
ref
s
toplevel
directives
The
outcome
of
the
evaluation
is
not
printed
On
reaching
the
end
of
file
the
ocaml
command
exits
immediately
No
commands
are
read
from
standard
input
Sys
argv
is
transformed
ignoring
all
OCaml
parameters
and
starting
with
the
script
file
name
in
Sys
argv
0
In
script
mode
the
first
line
of
the
script
is
ignored
if
it
starts
with
Thus
it
should
be
possible
to
make
the
script
itself
executable
and
put
as
first
line
usr
local
bin
ocaml
thus
calling
the
toplevel
system
automatically
when
the
script
is
run
However
ocaml
itself
is
a
script
on
most
installations
of
OCaml
and
Unix
kernels
usually
do
not
handle
nested
scripts
A
better
solution
is
to
put
the
following
as
the
first
line
of
the
script
begin
verbatim
usr
local
bin
ocamlrun
usr
local
bin
ocaml
end
verbatim
end
unix
section
s
toplevel
options
Options
The
following
command
line
options
are
recognized
by
the
ocaml
command
Configure
boolean
variables
used
by
the
macros
in
unified
options
etex
compfalse
natfalse
toptrue
unified
options
gathers
all
options
across
the
native
bytecode
compilers
and
toplevel
input
unified
options
tex
begin
unix
The
following
environment
variables
are
also
consulted
begin
options
item
OCAMLTOP
INCLUDE
PATH
Additional
directories
to
search
for
compiled
object
code
files
cmi
cmo
and
cma
The
specified
directories
are
considered
from
left
to
right
after
the
include
directories
specified
on
the
command
line
via
I
have
been
searched
Available
since
OCaml
4
08
item
OCAMLTOP
UTF
8
When
printing
string
values
non
ascii
bytes
0x7E
are
printed
as
decimal
escape
sequence
if
OCAMLTOP
UTF
8
is
set
to
false
Otherwise
they
are
printed
unescaped
item
TERM
When
printing
error
messages
the
toplevel
system
attempts
to
underline
visually
the
location
of
the
error
It
consults
the
TERM
variable
to
determines
the
type
of
output
terminal
and
look
up
its
capabilities
in
the
terminal
database
item
XDG
CONFIG
HOME
HOME
XDG
CONFIG
DIRS
Initialization
file
lookup
procedure
see
above
end
options
end
unix
section
s
toplevel
directives
Toplevel
directives
The
following
directives
control
the
toplevel
behavior
load
files
in
memory
and
trace
program
execution
bf
Note
all
directives
start
with
a
sharp
symbol
This
must
be
typed
before
the
directive
and
must
not
be
confused
with
the
prompt
displayed
by
the
interactive
loop
For
instance
typing
quit
will
exit
the
toplevel
loop
but
typing
quit
will
result
in
an
unbound
value
quit
error
Remark
this
list
of
options
should
be
kept
synchronized
with
the
documentation
in
toplevel
topdirs
ml
begin
options
item
General
begin
options
item
help
Prints
a
list
of
all
available
directives
with
corresponding
argument
type
if
appropriate
item
quit
Exit
the
toplevel
loop
and
terminate
the
ocaml
command
end
options
item
Loading
codes
begin
options
item
cd
var
dir
name
Change
the
current
working
directory
item
directory
var
dir
name
Add
the
given
directory
to
the
list
of
directories
searched
for
source
and
compiled
files
item
remove
directory
var
dir
name
Remove
the
given
directory
from
the
list
of
directories
searched
for
source
and
compiled
files
Do
nothing
if
the
list
does
not
contain
the
given
directory
item
load
var
file
name
Load
in
memory
a
bytecode
object
file
cmo
file
or
library
file
cma
file
produced
by
the
batch
compiler
ocamlc
item
load
rec
var
file
name
Load
in
memory
a
bytecode
object
file
cmo
file
or
library
file
cma
file
produced
by
the
batch
compiler
ocamlc
When
loading
an
object
file
that
depends
on
other
modules
which
have
not
been
loaded
yet
the
cmo
files
for
these
modules
are
searched
and
loaded
as
well
recursively
The
loading
order
is
not
specified
item
use
var
file
name
Read
compile
and
execute
source
phrases
from
the
given
file
This
is
textual
inclusion
phrases
are
processed
just
as
if
they
were
typed
on
standard
input
The
reading
of
the
file
stops
at
the
first
error
encountered
item
use
output
var
command
Execute
a
command
and
evaluate
its
output
as
if
it
had
been
captured
to
a
file
and
passed
to
use
item
mod
use
var
file
name
Similar
to
use
but
also
wrap
the
code
into
a
top
level
module
of
the
same
name
as
capitalized
file
name
without
extensions
following
semantics
of
the
compiler
end
options
For
directives
that
take
file
names
as
arguments
if
the
given
file
name
specifies
no
directory
the
file
is
searched
in
the
following
directories
begin
enumerate
item
In
script
mode
the
directory
containing
the
script
currently
executing
in
interactive
mode
the
current
working
directory
item
Directories
added
with
the
directory
directive
item
Directories
given
on
the
command
line
with
I
options
item
The
standard
library
directory
end
enumerate
item
Environment
queries
begin
options
item
show
class
var
class
path
vspace
4
7ex
item
show
class
type
var
class
path
vspace
4
7ex
item
show
exception
var
ident
vspace
4
7ex
item
show
module
var
module
path
vspace
4
7ex
item
show
module
type
var
modtype
path
vspace
4
7ex
item
show
type
var
typeconstr
vspace
4
7ex
item
show
val
var
value
path
Print
the
signature
of
the
corresponding
component
item
show
var
ident
Print
the
signatures
of
components
with
name
var
ident
in
all
the
above
categories
end
options
item
Pretty
printing
begin
options
item
install
printer
var
printer
name
This
directive
registers
the
function
named
var
printer
name
a
value
path
as
a
printer
for
values
whose
types
match
the
argument
type
of
the
function
That
is
the
toplevel
loop
will
call
var
printer
name
when
it
has
such
a
value
to
print
The
printing
function
var
printer
name
should
have
type
Format
formatter
t
unit
where
t
is
the
type
for
the
values
to
be
printed
and
should
output
its
textual
representation
for
the
value
of
type
t
on
the
given
formatter
using
the
functions
provided
by
the
Format
library
For
backward
compatibility
var
printer
name
can
also
have
type
t
unit
and
should
then
output
on
the
standard
formatter
but
this
usage
is
deprecated
item
print
depth
var
n
Limit
the
printing
of
values
to
a
maximal
depth
of
var
n
The
parts
of
values
whose
depth
exceeds
var
n
are
printed
as
ellipsis
item
print
length
var
n
Limit
the
number
of
value
nodes
printed
to
at
most
var
n
Remaining
parts
of
values
are
printed
as
ellipsis
item
remove
printer
var
printer
name
Remove
the
named
function
from
the
table
of
toplevel
printers
end
options
item
Tracing
begin
options
item
trace
var
function
name
After
executing
this
directive
all
calls
to
the
function
named
var
function
name
will
be
traced
That
is
the
argument
and
the
result
are
displayed
for
each
call
as
well
as
the
exceptions
escaping
out
of
the
function
raised
either
by
the
function
itself
or
by
another
function
it
calls
If
the
function
is
curried
each
argument
is
printed
as
it
is
passed
to
the
function
item
untrace
var
function
name
Stop
tracing
the
given
function
item
untrace
all
Stop
tracing
all
functions
traced
so
far
end
options
item
Compiler
options
begin
options
item
debug
var
bool
Turn
on
off
the
insertion
of
debugging
events
Default
is
true
item
labels
var
bool
Ignore
labels
in
function
types
if
argument
is
false
or
switch
back
to
default
behaviour
commuting
style
if
argument
is
true
item
ppx
var
file
name
After
parsing
pipe
the
abstract
syntax
tree
through
the
preprocessor
command
item
principal
var
bool
If
the
argument
is
true
check
information
paths
during
type
checking
to
make
sure
that
all
types
are
derived
in
a
principal
way
If
the
argument
is
false
do
not
check
information
paths
item
rectypes
Allow
arbitrary
recursive
types
during
type
checking
Note
once
enabled
this
option
cannot
be
disabled
because
that
would
lead
to
unsoundness
of
the
type
system
item
warn
error
var
warning
list
Treat
as
errors
the
warnings
enabled
by
the
argument
and
as
normal
warnings
the
warnings
disabled
by
the
argument
item
warnings
var
warning
list
Enable
or
disable
warnings
according
to
the
argument
end
options
end
options
section
s
toplevel
modules
The
toplevel
and
the
module
system
Toplevel
phrases
can
refer
to
identifiers
defined
in
compilation
units
with
the
same
mechanisms
as
for
separately
compiled
units
either
by
using
qualified
names
Modulename
localname
or
by
using
the
open
construct
and
unqualified
names
see
section
ref
s
names
However
before
referencing
another
compilation
unit
an
implementation
of
that
unit
must
be
present
in
memory
At
start
up
the
toplevel
system
contains
implementations
for
all
the
modules
in
the
the
standard
library
Implementations
for
user
modules
can
be
entered
with
the
load
directive
described
above
Referencing
a
unit
for
which
no
implementation
has
been
provided
results
in
the
error
Reference
to
undefined
global
Note
that
entering
open
var
Mod
merely
accesses
the
compiled
interface
cmi
file
for
var
Mod
but
does
not
load
the
implementation
of
var
Mod
and
does
not
cause
any
error
if
no
implementation
of
var
Mod
has
been
loaded
The
error
reference
to
undefined
global
var
Mod
will
occur
only
when
executing
a
value
or
module
definition
that
refers
to
var
Mod
section
s
toplevel
common
errors
Common
errors
This
section
describes
and
explains
the
most
frequently
encountered
error
messages
begin
options
item
Cannot
find
file
var
filename
The
named
file
could
not
be
found
in
the
current
directory
nor
in
the
directories
of
the
search
path
If
var
filename
has
the
format
var
mod
cmi
this
means
you
have
referenced
the
compilation
unit
var
mod
but
its
compiled
interface
could
not
be
found
Fix
compile
var
mod
mli
or
var
mod
ml
first
to
create
the
compiled
interface
var
mod
cmi
If
var
filename
has
the
format
var
mod
cmo
this
means
you
are
trying
to
load
with
load
a
bytecode
object
file
that
does
not
exist
yet
Fix
compile
var
mod
ml
first
If
your
program
spans
several
directories
this
error
can
also
appear
because
you
haven
t
specified
the
directories
to
look
into
Fix
use
the
directory
directive
to
add
the
correct
directories
to
the
search
path
item
This
expression
has
type
nth
t
1
but
is
used
with
type
nth
t
2
See
section
ref
s
comp
errors
item
Reference
to
undefined
global
var
mod
You
have
neglected
to
load
in
memory
an
implementation
for
a
module
with
load
See
section
ref
s
toplevel
modules
above
end
options
section
s
custom
toplevel
Building
custom
toplevel
systems
texttt
ocamlmktop
The
ocamlmktop
command
builds
OCaml
toplevels
that
contain
user
code
preloaded
at
start
up
The
ocamlmktop
command
takes
as
argument
a
set
of
cmo
and
cma
files
and
links
them
with
the
object
files
that
implement
the
OCaml
toplevel
The
typical
use
is
begin
verbatim
ocamlmktop
o
mytoplevel
foo
cmo
bar
cmo
gee
cmo
end
verbatim
This
creates
the
bytecode
file
mytoplevel
containing
the
OCaml
toplevel
system
plus
the
code
from
the
three
cmo
files
This
toplevel
is
directly
executable
and
is
started
by
begin
verbatim
mytoplevel
end
verbatim
This
enters
a
regular
toplevel
loop
except
that
the
code
from
foo
cmo
bar
cmo
and
gee
cmo
is
already
loaded
in
memory
just
as
if
you
had
typed
begin
verbatim
load
foo
cmo
load
bar
cmo
load
gee
cmo
end
verbatim
on
entrance
to
the
toplevel
The
modules
Foo
Bar
and
Gee
are
not
opened
though
you
still
have
to
do
begin
verbatim
open
Foo
end
verbatim
yourself
if
this
is
what
you
wish
subsection
ss
ocamlmktop
options
Options
The
following
command
line
options
are
recognized
by
ocamlmktop
begin
options
item
cclib
var
libname
Pass
the
l
var
libname
option
to
the
C
linker
when
linking
in
custom
runtime
mode
See
the
corresponding
option
for
ocamlc
in
chapter
ref
c
camlc
item
ccopt
var
option
Pass
the
given
option
to
the
C
compiler
and
linker
when
linking
in
custom
runtime
mode
See
the
corresponding
option
for
ocamlc
in
chapter
ref
c
camlc
item
custom
Link
in
custom
runtime
mode
See
the
corresponding
option
for
ocamlc
in
chapter
ref
c
camlc
item
I
var
directory
Add
the
given
directory
to
the
list
of
directories
searched
for
compiled
object
code
files
cmo
and
cma
item
o
var
exec
file
Specify
the
name
of
the
toplevel
file
produced
by
the
linker
The
default
is
a
out
end
options
section
s
ocamlnat
The
native
toplevel
texttt
ocamlnat
experimental
bf
This
section
describes
a
tool
that
is
not
yet
officially
supported
but
may
be
found
useful
OCaml
code
executing
in
the
traditional
toplevel
system
uses
the
bytecode
interpreter
When
increased
performance
is
required
or
for
testing
programs
that
will
only
execute
correctly
when
compiled
to
native
code
the
em
native
toplevel
may
be
used
instead
For
the
majority
of
installations
the
native
toplevel
will
not
have
been
installed
along
with
the
rest
of
the
OCaml
toolchain
In
such
circumstances
it
will
be
necessary
to
build
the
OCaml
distribution
from
source
From
the
built
source
tree
of
the
distribution
you
may
use
tt
make
natruntop
to
build
and
execute
a
native
toplevel
Alternatively
tt
make
ocamlnat
can
be
used
which
just
performs
the
build
step
If
the
tt
make
install
command
is
run
after
having
built
the
native
toplevel
then
the
tt
ocamlnat
program
either
from
the
source
or
the
installation
directory
may
be
invoked
directly
rather
than
using
tt
make
natruntop
chapter
The
Tail
Modulo
Constructor
program
transformation
label
c
tail
mod
cons
HEVEA
cutname
tail
mod
cons
html
Introduced
in
OCaml
4
14
Note
this
feature
is
considered
experimental
and
its
interface
may
evolve
with
user
feedback
in
the
next
few
releases
of
the
language
Consider
this
natural
implementation
of
the
List
map
function
begin
caml
example
verbatim
let
rec
map
f
l
match
l
with
x
xs
let
y
f
x
in
y
map
f
xs
end
caml
example
A
well
known
limitation
of
this
implementation
is
that
the
recursive
call
map
f
xs
is
not
in
emph
tail
position
The
runtime
needs
to
remember
to
continue
with
y
r
after
the
call
returns
a
value
r
therefore
this
function
consumes
some
amount
of
call
stack
space
on
each
recursive
call
The
stack
usage
of
map
f
li
is
proportional
to
the
length
of
li
This
is
a
correctness
issue
for
large
lists
on
systems
configured
with
limited
stack
space
the
dreaded
Stack
overflow
exception
begin
caml
example
toplevel
let
with
stack
limit
stack
limit
f
let
old
gc
settings
Gc
get
in
Gc
set
old
gc
settings
with
stack
limit
Fun
protect
finally
fun
Gc
set
old
gc
settings
f
with
stack
limit
20
000
fun
List
length
map
Fun
id
List
init
1
000
000
Fun
id
end
caml
example
In
this
implementation
of
map
the
recursive
call
happens
in
a
position
that
is
not
a
emph
tail
position
in
the
program
but
within
a
datatype
constructor
application
that
is
itself
in
emph
tail
position
We
say
that
those
positions
that
are
composed
of
tail
positions
and
constructor
applications
are
emph
tail
modulo
constructor
TMC
positions
we
sometimes
write
emph
tail
modulo
cons
for
brevity
It
is
possible
to
rewrite
programs
such
that
tail
modulo
cons
positions
become
tail
positions
after
this
transformation
the
implementation
of
map
above
becomes
emph
tail
recursive
in
the
sense
that
it
only
consumes
a
constant
amount
of
stack
space
The
OCaml
compiler
implements
this
transformation
on
demand
using
the
tail
mod
cons
or
ocaml
tail
mod
cons
attribute
on
the
function
to
transform
begin
caml
example
verbatim
let
tail
mod
cons
rec
map
f
l
match
l
with
x
xs
let
y
f
x
in
y
map
f
xs
end
caml
example
begin
caml
example
toplevel
List
length
map
Fun
id
List
init
1
000
000
Fun
id
end
caml
example
This
transformation
only
improves
calls
in
tail
modulo
cons
position
it
does
not
improve
recursive
calls
that
do
not
fit
in
this
fragment
begin
caml
example
verbatim
warning
71
does
not
work
addition
is
not
a
data
constructor
let
tail
mod
cons
rec
length
l
match
l
with
0
xs
1
length
xs
end
caml
example
It
is
of
course
possible
to
use
the
tail
mod
cons
transformation
on
functions
that
contain
some
recursive
calls
in
tail
modulo
cons
position
and
some
calls
in
other
arbitrary
positions
Only
the
tail
calls
and
tail
modulo
cons
calls
will
happen
in
constant
stack
space
paragraph
General
design
This
feature
is
provided
as
an
explicit
program
transformation
not
an
implicit
optimization
It
is
annotation
driven
the
user
is
expected
to
express
their
intent
by
adding
annotations
in
the
program
using
attributes
and
will
be
asked
to
do
so
in
any
ambiguous
situation
We
expect
it
to
be
used
mostly
by
advanced
OCaml
users
needing
to
get
some
guarantees
on
the
stack
consumption
behavior
of
their
programs
Our
recommendation
is
to
use
the
tailcall
annotation
on
all
callsites
that
should
not
consume
any
stack
space
tail
mod
cons
extends
the
set
of
functions
on
which
calls
can
be
annotated
to
be
tail
calls
helping
establish
stack
consumption
guarantees
in
more
cases
paragraph
Performance
A
standard
approach
to
get
a
tail
recursive
version
of
List
map
is
to
use
an
accumulator
to
collect
output
elements
and
reverse
it
at
the
end
of
the
traversal
begin
caml
example
verbatim
let
rec
map
f
l
map
aux
f
l
and
map
aux
f
acc
l
match
l
with
List
rev
acc
x
xs
let
y
f
x
in
map
aux
f
y
acc
xs
end
caml
example
This
version
is
tail
recursive
but
it
is
measurably
slower
than
the
simple
non
tail
recursive
version
In
contrast
the
tail
mod
cons
transformation
provides
an
implementation
that
has
comparable
performance
to
the
original
version
even
on
small
inputs
paragraph
Evaluation
order
Beware
that
the
tail
modulo
cons
transformation
has
an
effect
on
evaluation
order
the
constructor
argument
that
is
transformed
into
tail
position
will
always
be
evaluated
last
Consider
the
following
example
begin
caml
example
verbatim
type
a
two
headed
list
Nil
Consnoc
of
a
a
two
headed
list
a
let
tail
mod
cons
rec
map
f
function
Nil
Nil
Consnoc
front
body
rear
Consnoc
f
front
map
f
body
f
rear
end
caml
example
Due
to
the
tail
mod
cons
transformation
the
calls
to
f
front
and
f
rear
will
be
evaluated
before
map
f
body
In
particular
this
is
likely
to
be
different
from
the
evaluation
order
of
the
unannotated
version
The
evaluation
order
of
constructor
arguments
is
unspecified
in
OCaml
but
many
implementations
typically
use
left
to
right
or
right
to
left
This
effect
on
evaluation
order
is
one
of
the
reasons
why
the
tail
modulo
cons
transformation
has
to
be
explicitly
requested
by
the
user
instead
of
being
applied
as
an
automatic
optimization
paragraph
Why
tail
modulo
cons
Other
program
transformations
in
particular
a
transformation
to
continuation
passing
style
CPS
can
make
all
functions
tail
recursive
instead
of
targeting
only
a
small
fragment
Some
reasons
to
provide
builtin
support
for
the
less
general
tail
mod
cons
are
as
follows
begin
itemize
item
The
tail
mod
cons
transformation
preserves
the
performance
of
the
original
non
tail
recursive
version
while
a
continuation
passing
style
transformation
incurs
a
measurable
constant
factor
overhead
item
The
tail
mod
cons
transformation
cannot
be
expressed
as
a
source
to
source
transformation
of
OCaml
programs
as
it
relies
on
mutable
state
in
type
unsafe
ways
In
contrast
continuation
passing
style
versions
can
be
written
by
hand
possibly
using
a
convenient
monadic
notation
end
itemize
paragraph
Note
OCaml
call
stack
size
In
OCaml
4
x
and
earlier
bytecode
programs
respect
the
stack
limit
runtime
parameter
configuration
as
set
using
Gc
set
in
the
example
above
or
the
l
setting
of
the
OCAMLRUNPARAM
variable
Native
programs
ignore
these
settings
and
only
respect
the
operating
system
native
stack
limit
as
set
by
ulimit
on
Unix
systems
Most
operating
systems
run
with
a
relatively
low
stack
size
limit
by
default
so
stack
overflow
on
non
tail
recursive
functions
are
a
common
programming
bug
Starting
from
OCaml
5
0
native
code
does
not
use
the
native
system
stack
for
OCaml
function
calls
anymore
so
it
is
not
affected
by
the
operating
system
native
stack
size
both
native
and
bytecode
programs
respect
the
OCaml
runtime
s
own
limit
The
runtime
limit
is
set
to
a
much
higher
default
than
most
operating
system
native
stacks
with
a
limit
of
at
least
512MiB
so
stack
overflow
should
be
much
less
common
in
practice
There
is
still
a
stack
limit
by
default
as
it
remains
useful
to
quickly
catch
bugs
with
looping
non
tail
recursive
functions
Without
a
stack
limit
one
has
to
wait
for
the
whole
memory
to
be
consumed
by
the
stack
for
the
program
to
crash
which
can
take
a
long
time
and
make
the
system
unresponsive
This
means
that
the
tail
modulo
constructor
transformation
is
less
important
on
OCaml
5
it
does
improve
performance
noticeably
in
some
cases
but
it
is
not
necessary
for
basic
correctness
for
most
use
cases
section
sec
disambiguation
Disambiguation
It
may
happen
that
several
arguments
of
a
constructor
are
recursive
calls
to
a
tail
modulo
cons
function
The
transformation
can
only
turn
one
of
these
calls
into
a
tail
call
The
compiler
will
not
make
an
implicit
choice
but
ask
the
user
to
provide
an
explicit
disambiguation
Consider
this
type
of
syntactic
expressions
assuming
some
pre
existing
type
var
of
expression
variables
begin
caml
example
verbatim
type
var
some
pre
existing
type
of
variables
type
exp
Var
of
var
Let
of
binding
exp
and
binding
var
exp
end
caml
example
Consider
a
map
function
on
variables
The
direct
definition
has
two
recursive
calls
inside
arguments
of
the
Let
constructor
so
it
gets
rejected
as
ambiguous
begin
caml
example
verbatim
error
let
tail
mod
cons
rec
map
vars
f
exp
match
exp
with
Var
v
Var
f
v
Let
v
def
body
Let
f
v
map
vars
f
def
map
vars
f
body
end
caml
example
To
disambiguate
the
user
should
add
a
tailcall
attribute
to
the
recursive
call
that
should
be
transformed
to
tail
position
begin
caml
example
verbatim
let
tail
mod
cons
rec
map
vars
f
exp
match
exp
with
Var
v
Var
f
v
Let
v
def
body
Let
f
v
map
vars
f
def
map
vars
tailcall
f
body
end
caml
example
Be
aware
that
the
resulting
function
is
emph
not
tail
recursive
the
recursive
call
on
def
will
consume
stack
space
However
expression
trees
tend
to
be
right
leaning
lots
of
Let
in
sequence
rather
than
nested
inside
each
other
so
putting
the
call
on
body
in
tail
position
is
an
interesting
improvement
over
the
naive
definition
it
gives
bounded
stack
space
consumption
if
we
assume
a
bound
on
the
nesting
depth
of
Let
constructs
One
would
also
get
an
error
when
using
conflicting
annotations
asking
for
two
of
the
constructor
arguments
to
be
put
in
tail
position
begin
caml
example
verbatim
error
let
tail
mod
cons
rec
map
vars
f
exp
match
exp
with
Var
v
Var
f
v
Let
v
def
body
Let
f
v
map
vars
tailcall
f
def
map
vars
tailcall
f
body
end
caml
example
section
sec
out
of
tmc
Danger
getting
out
of
tail
mod
cons
Due
to
the
nature
of
the
tail
mod
cons
transformation
see
Section
ref
sec
details
for
a
presentation
of
transformation
begin
itemize
item
Calls
from
a
tail
mod
cons
function
to
another
tail
mod
cons
function
declared
in
the
same
recursive
binding
group
are
transformed
into
tail
calls
as
soon
as
they
occur
in
tail
position
or
tail
modulo
cons
position
in
the
source
function
item
Calls
from
a
function
emph
not
annotated
tail
mod
cons
to
a
tail
mod
cons
function
or
conversely
from
a
tail
mod
cons
function
to
a
non
tail
mod
cons
function
are
transformed
into
emph
non
tail
calls
even
if
they
syntactically
appear
in
tail
position
in
the
source
program
end
itemize
The
fact
that
calls
in
tail
position
in
the
source
program
may
become
non
tail
calls
if
they
go
from
a
tail
mod
cons
to
a
non
tail
mod
cons
function
is
surprising
and
the
transformation
will
warn
about
them
For
example
begin
caml
example
verbatim
warning
71
let
tail
mod
cons
rec
flatten
function
xs
xss
let
rec
append
flatten
xs
xss
match
xs
with
flatten
xss
x
xs
x
append
flatten
xs
xss
in
append
flatten
xs
xss
end
caml
example
Here
the
append
flatten
helper
is
not
annotated
with
tail
mod
cons
so
the
calls
append
flatten
xs
xss
and
flatten
xss
will
emph
not
be
tail
calls
The
correct
fix
here
is
to
annotate
append
flatten
to
be
tail
mod
cons
begin
caml
example
verbatim
let
tail
mod
cons
rec
flatten
function
xs
xss
let
tail
mod
cons
rec
append
flatten
xs
xss
match
xs
with
flatten
xss
x
xs
x
append
flatten
xs
xss
in
append
flatten
xs
xss
end
caml
example
The
same
warning
occurs
when
append
flatten
is
a
non
tail
mod
cons
function
of
the
same
recursive
group
using
the
tail
mod
cons
transformation
is
a
property
of
individual
functions
not
whole
recursive
groups
begin
caml
example
verbatim
warning
71
let
tail
mod
cons
rec
flatten
function
xs
xss
append
flatten
xs
xss
and
append
flatten
xs
xss
match
xs
with
flatten
xss
x
xs
x
append
flatten
xs
xss
end
caml
example
Again
the
fix
is
to
specialize
append
flatten
as
well
begin
caml
example
verbatim
let
tail
mod
cons
rec
flatten
function
xs
xss
append
flatten
xs
xss
and
tail
mod
cons
append
flatten
xs
xss
match
xs
with
flatten
xss
x
xs
x
append
flatten
xs
xss
end
caml
example
Non
recursive
functions
can
also
be
annotated
tail
mod
cons
this
is
typically
useful
for
local
bindings
to
recursive
functions
Incorrect
version
begin
caml
example
verbatim
warning
51
warning
71
let
tail
mod
cons
rec
map
vars
f
exp
let
self
exp
map
vars
f
exp
in
match
exp
with
Var
v
Var
f
v
Let
v
def
body
Let
f
v
self
def
self
tailcall
body
end
caml
example
Recommended
fix
begin
caml
example
verbatim
let
tail
mod
cons
rec
map
vars
f
exp
let
tail
mod
cons
self
exp
map
vars
f
exp
in
match
exp
with
Var
v
Var
f
v
Let
v
def
body
Let
f
v
self
def
self
tailcall
body
end
caml
example
In
other
cases
there
is
either
no
benefit
in
making
the
called
function
tail
mod
cons
or
it
is
not
possible
for
example
it
is
a
function
parameter
the
transformation
only
works
with
direct
calls
to
known
functions
For
example
consider
a
substitution
function
on
binary
trees
begin
caml
example
verbatim
warning
72
type
a
tree
Leaf
of
a
Node
of
a
tree
a
tree
let
tail
mod
cons
rec
bind
f
a
a
tree
t
a
tree
a
tree
match
t
with
Leaf
v
f
v
Node
left
right
Node
bind
f
left
bind
tailcall
f
right
end
caml
example
Here
f
is
a
function
parameter
not
a
direct
call
and
the
current
implementation
is
strictly
first
order
it
does
not
support
tail
mod
cons
arguments
In
this
case
the
user
should
indicate
that
they
realize
this
call
to
f
v
is
not
in
fact
in
tail
position
by
using
f
tailcall
false
v
begin
caml
example
verbatim
type
a
tree
Leaf
of
a
Node
of
a
tree
a
tree
let
tail
mod
cons
rec
bind
f
a
a
tree
t
a
tree
a
tree
match
t
with
Leaf
v
f
tailcall
false
v
Node
left
right
Node
bind
f
left
bind
tailcall
f
right
end
caml
example
section
sec
details
Details
on
the
transformation
To
use
this
advanced
feature
it
helps
to
be
aware
that
the
function
transformation
produces
a
specialized
function
in
destination
passing
style
Recall
our
map
example
begin
caml
example
verbatim
let
rec
map
f
l
match
l
with
x
xs
let
y
f
x
in
y
map
f
xs
end
caml
example
Below
is
a
description
of
the
transformed
program
in
pseudo
OCaml
notation
some
operations
are
not
expressible
in
OCaml
source
code
The
transformation
in
fact
happens
on
the
Lambda
intermediate
representation
of
the
OCaml
compiler
begin
verbatim
let
rec
map
f
l
match
l
with
x
xs
let
y
f
x
in
let
dst
y
mutable
Hole
in
map
dps
f
xs
dst
1
dst
and
map
dps
f
l
dst
idx
match
l
with
dst
idx
x
xs
let
y
f
x
in
let
dst
y
mutable
Hole
in
dst
idx
dst
map
dps
f
xs
dst
1
end
verbatim
The
source
version
of
map
gets
transformed
into
two
functions
a
emph
direct
style
version
that
is
also
called
map
and
a
emph
destination
passing
style
version
DPS
called
map
dps
The
destination
passing
style
version
does
not
return
a
result
directly
instead
it
writes
it
into
a
memory
location
specified
by
two
additional
function
parameters
dst
a
memory
block
and
i
a
position
within
the
memory
block
The
source
call
y
map
f
xs
gets
transformed
into
the
creation
of
a
mutable
block
y
mutable
Hole
whose
second
parameter
is
an
un
initialized
emph
hole
The
block
is
then
passed
to
map
dps
as
a
destination
parameter
with
offset
1
Notice
that
map
does
not
call
itself
recursively
it
calls
map
dps
Then
map
dps
calls
itself
recursively
in
a
tail
recursive
way
The
call
from
map
to
map
dps
is
emph
not
a
tail
call
this
is
something
that
we
could
improve
in
the
future
but
this
call
happens
only
once
when
invoking
map
f
l
with
all
list
elements
after
the
first
one
processed
in
constant
stack
by
map
dps
This
explains
the
getting
out
of
tail
mod
cons
subtleties
Consider
our
previous
example
involving
mutual
recursion
between
flatten
and
append
flatten
begin
verbatim
let
tail
mod
cons
rec
flatten
l
match
l
with
xs
xss
append
flatten
xs
xss
end
verbatim
The
call
to
append
flatten
which
syntactically
appears
in
tail
position
gets
transformed
differently
depending
on
whether
the
function
has
a
destination
passing
style
version
available
that
is
whether
it
is
itself
annotated
tail
mod
cons
begin
verbatim
if
append
flatten
dps
exists
and
flatten
dps
l
dst
i
match
l
with
dst
i
xs
xss
append
flatten
dps
xs
xss
dst
i
if
append
flatten
dps
does
not
exist
and
rec
flatten
dps
l
dst
i
match
l
with
dst
i
xs
xss
dst
i
append
flatten
xs
xss
end
verbatim
If
append
flatten
does
not
have
a
destination
passing
style
version
the
call
gets
transformed
to
a
non
tail
call
section
sec
limitations
Current
limitations
paragraph
Purely
syntactic
criterion
Just
like
tail
calls
in
general
the
notion
of
tail
modulo
constructor
position
is
purely
syntactic
some
simple
refactoring
will
move
calls
out
of
tail
modulo
constructor
position
begin
caml
example
verbatim
works
as
expected
let
tail
mod
cons
rec
map
f
li
match
li
with
x
xs
let
y
f
x
in
y
this
call
is
in
TMC
position
map
f
xs
end
caml
example
begin
caml
example
verbatim
warning
71
not
optimizable
anymore
let
tail
mod
cons
rec
map
f
li
match
li
with
x
xs
let
y
f
x
in
let
ys
this
call
is
not
in
TMC
position
anymore
map
f
xs
in
y
ys
end
caml
example
paragraph
Local
first
order
transformation
When
a
function
gets
transformed
with
tail
mod
cons
two
definitions
are
generated
one
providing
a
direct
style
interface
and
one
providing
the
destination
passing
style
version
However
not
all
calls
to
this
function
in
tail
modulo
cons
position
will
use
the
destination
passing
style
version
and
become
tail
calls
begin
itemize
item
The
transformation
is
local
only
tail
mod
cons
calls
to
foo
within
the
same
compilation
unit
as
foo
become
tail
calls
item
The
transformation
is
first
order
only
direct
calls
to
known
tail
mod
cons
functions
become
tail
calls
when
in
tail
mod
cons
position
never
calls
to
function
parameters
end
itemize
Consider
the
call
Option
map
foo
x
for
example
even
if
foo
is
called
in
tail
mod
cons
position
within
the
definition
of
Option
map
that
call
will
never
become
a
tail
call
This
would
be
the
case
even
if
the
call
to
Option
map
was
inside
the
Option
module
In
general
this
limitation
is
not
a
problem
for
recursive
functions
the
first
call
from
an
outside
module
or
a
higher
order
function
will
consume
stack
space
but
further
recursive
calls
in
tail
mod
cons
position
will
get
optimized
For
example
if
List
map
is
defined
as
a
tail
mod
cons
function
calls
from
outside
the
List
module
will
not
become
tail
calls
when
in
tail
positions
but
the
recursive
calls
within
the
definition
of
List
map
are
in
tail
modulo
cons
positions
and
do
become
tail
calls
processing
the
first
element
of
the
list
will
consume
stack
space
but
all
further
elements
are
handled
in
constant
space
These
limitations
may
be
an
issue
in
more
complex
situations
where
mutual
recursion
happens
between
functions
with
some
functions
not
annotated
tail
mod
cons
or
defined
across
different
modules
or
called
indirectly
for
example
through
function
parameters
paragraph
Non
exact
calls
to
tupled
functions
OCaml
performs
an
implicit
optimization
for
tupled
functions
which
take
a
single
parameter
that
is
a
tuple
let
f
x
y
z
Direct
calls
to
these
functions
with
a
tuple
literal
argument
like
f
a
b
c
will
call
the
tupled
function
by
passing
the
parameters
directly
instead
of
building
a
tuple
of
them
Other
calls
either
indirect
calls
or
calls
passing
a
more
complex
tuple
value
like
let
t
a
b
c
in
f
t
are
compiled
as
inexact
calls
that
go
through
a
wrapper
The
tail
mod
cons
transformation
supports
tupled
functions
but
will
only
optimize
exact
calls
in
tail
position
direct
calls
to
something
other
than
a
tuple
literal
will
not
become
tail
calls
The
user
can
manually
unpack
a
tuple
to
force
a
call
to
be
exact
let
x
y
z
t
in
f
x
y
z
If
there
is
any
doubt
as
to
whether
a
call
can
be
tail
mod
cons
optimized
or
not
one
can
use
the
tailcall
attribute
on
the
called
function
which
will
warn
if
the
transformation
is
not
possible
begin
caml
example
verbatim
warning
51
let
rec
map
f
l
match
l
with
x
xs
let
y
f
x
in
let
args
f
xs
in
this
inexact
call
cannot
be
tail
optimized
so
a
warning
will
be
raised
y
map
tailcall
args
end
caml
example
chapter
Lexer
and
parser
generators
ocamllex
ocamlyacc
label
c
ocamlyacc
HEVEA
cutname
lexyacc
html
This
chapter
describes
two
program
generators
ocamllex
that
produces
a
lexical
analyzer
from
a
set
of
regular
expressions
with
associated
semantic
actions
and
ocamlyacc
that
produces
a
parser
from
a
grammar
with
associated
semantic
actions
These
program
generators
are
very
close
to
the
well
known
lex
and
yacc
commands
that
can
be
found
in
most
C
programming
environments
This
chapter
assumes
a
working
knowledge
of
lex
and
yacc
while
it
describes
the
input
syntax
for
ocamllex
and
ocamlyacc
and
the
main
differences
with
lex
and
yacc
it
does
not
explain
the
basics
of
writing
a
lexer
or
parser
description
in
lex
and
yacc
Readers
unfamiliar
with
lex
and
yacc
are
referred
to
Compilers
principles
techniques
and
tools
by
Aho
Lam
Sethi
and
Ullman
Pearson
2006
or
Lex
Yacc
by
Levine
Mason
and
Brown
O
Reilly
1992
section
s
ocamllex
overview
Overview
of
texttt
ocamllex
The
ocamllex
command
produces
a
lexical
analyzer
from
a
set
of
regular
expressions
with
attached
semantic
actions
in
the
style
of
lex
Assuming
the
input
file
is
var
lexer
mll
executing
begin
alltt
ocamllex
var
lexer
mll
end
alltt
produces
OCaml
code
for
a
lexical
analyzer
in
file
var
lexer
ml
This
file
defines
one
lexing
function
per
entry
point
in
the
lexer
definition
These
functions
have
the
same
names
as
the
entry
points
Lexing
functions
take
as
argument
a
lexer
buffer
and
return
the
semantic
attribute
of
the
corresponding
entry
point
Lexer
buffers
are
an
abstract
data
type
implemented
in
the
standard
library
module
Lexing
The
functions
Lexing
from
channel
Lexing
from
string
and
Lexing
from
function
create
lexer
buffers
that
read
from
an
input
channel
a
character
string
or
any
reading
function
respectively
See
the
description
of
module
Lexing
in
chapter
ref
c
stdlib
When
used
in
conjunction
with
a
parser
generated
by
ocamlyacc
the
semantic
actions
compute
a
value
belonging
to
the
type
token
defined
by
the
generated
parsing
module
See
the
description
of
ocamlyacc
below
subsection
ss
ocamllex
options
Options
The
following
command
line
options
are
recognized
by
ocamllex
begin
options
item
ml
Output
code
that
does
not
use
OCaml
s
built
in
automata
interpreter
Instead
the
automaton
is
encoded
by
OCaml
functions
This
option
improves
performance
when
using
the
native
compiler
but
decreases
it
when
using
the
bytecode
compiler
item
o
var
output
file
Specify
the
name
of
the
output
file
produced
by
ocamllex
The
default
is
the
input
file
name
with
its
extension
replaced
by
ml
item
q
Quiet
mode
ocamllex
normally
outputs
informational
messages
to
standard
output
They
are
suppressed
if
option
q
is
used
item
v
or
version
Print
version
string
and
exit
item
vnum
Print
short
version
number
and
exit
item
help
or
help
Display
a
short
usage
summary
and
exit
end
options
section
s
ocamllex
syntax
Syntax
of
lexer
definitions
The
format
of
lexer
definitions
is
as
follows
begin
alltt
var
header
let
var
ident
var
regexp
ldots
refill
var
refill
handler
rule
var
entrypoint
nth
arg
1
ldots
nth
arg
n
parse
var
regexp
var
action
ldots
var
regexp
var
action
and
var
entrypoint
nth
arg
1
ldots
nth
arg
n
parse
ldots
and
ldots
var
trailer
end
alltt
Comments
are
delimited
by
and
as
in
OCaml
The
parse
keyword
can
be
replaced
by
the
shortest
keyword
with
the
semantic
consequences
explained
below
Refill
handlers
are
a
recent
optional
feature
introduced
in
4
02
documented
below
in
subsection
ref
ss
refill
handlers
subsection
ss
ocamllex
header
trailer
Header
and
trailer
The
it
header
and
it
trailer
sections
are
arbitrary
OCaml
text
enclosed
in
curly
braces
Either
or
both
can
be
omitted
If
present
the
header
text
is
copied
as
is
at
the
beginning
of
the
output
file
and
the
trailer
text
at
the
end
Typically
the
header
section
contains
the
open
directives
required
by
the
actions
and
possibly
some
auxiliary
functions
used
in
the
actions
subsection
ss
ocamllex
named
regexp
Naming
regular
expressions
Between
the
header
and
the
entry
points
one
can
give
names
to
frequently
occurring
regular
expressions
This
is
written
let
ident
regexp
In
regular
expressions
that
follow
this
declaration
the
identifier
var
ident
can
be
used
as
shorthand
for
var
regexp
subsection
ss
ocamllex
entry
points
Entry
points
The
names
of
the
entry
points
must
be
valid
identifiers
for
OCaml
values
starting
with
a
lowercase
letter
Similarly
the
arguments
texttt
var
arg
1
ldots
var
arg
n
must
be
valid
identifiers
for
OCaml
Each
entry
point
becomes
an
OCaml
function
that
takes
n
1
arguments
the
extra
implicit
last
argument
being
of
type
Lexing
lexbuf
Characters
are
read
from
the
Lexing
lexbuf
argument
and
matched
against
the
regular
expressions
provided
in
the
rule
until
a
prefix
of
the
input
matches
one
of
the
rule
The
corresponding
action
is
then
evaluated
and
returned
as
the
result
of
the
function
If
several
regular
expressions
match
a
prefix
of
the
input
the
longest
match
rule
applies
the
regular
expression
that
matches
the
longest
prefix
of
the
input
is
selected
In
case
of
tie
the
regular
expression
that
occurs
earlier
in
the
rule
is
selected
However
if
lexer
rules
are
introduced
with
the
shortest
keyword
in
place
of
the
parse
keyword
then
the
shortest
match
rule
applies
the
shortest
prefix
of
the
input
is
selected
In
case
of
tie
the
regular
expression
that
occurs
earlier
in
the
rule
is
still
selected
This
feature
is
not
intended
for
use
in
ordinary
lexical
analyzers
it
may
facilitate
the
use
of
ocamllex
as
a
simple
text
processing
tool
subsection
ss
ocamllex
regexp
Regular
expressions
The
regular
expressions
are
in
the
style
of
lex
with
a
more
OCaml
like
syntax
begin
syntax
regexp
ldots
end
syntax
begin
options
item
regular
char
escape
sequence
A
character
constant
with
the
same
syntax
as
OCaml
character
constants
Match
the
denoted
character
item
underscore
Match
any
character
item
eof
Match
the
end
of
the
lexer
input
bf
Note
On
some
systems
with
interactive
input
an
end
of
file
may
be
followed
by
more
characters
However
ocamllex
will
not
correctly
handle
regular
expressions
that
contain
eof
followed
by
something
else
item
string
character
A
string
constant
with
the
same
syntax
as
OCaml
string
constants
Match
the
corresponding
sequence
of
characters
item
character
set
Match
any
single
character
belonging
to
the
given
character
set
Valid
character
sets
are
single
character
constants
c
ranges
of
characters
c
1
c
2
all
characters
between
c
1
and
c
2
inclusive
and
the
union
of
two
or
more
character
sets
denoted
by
concatenation
item
character
set
Match
any
single
character
not
belonging
to
the
given
character
set
item
regexp
1
regexp
2
difference
of
character
sets
Regular
expressions
regexp
1
and
regexp
2
must
be
character
sets
defined
with
ldots
or
a
single
character
expression
or
underscore
Match
the
difference
of
the
two
specified
character
sets
item
regexp
repetition
Match
the
concatenation
of
zero
or
more
strings
that
match
regexp
item
regexp
strict
repetition
Match
the
concatenation
of
one
or
more
strings
that
match
regexp
item
regexp
option
Match
the
empty
string
or
a
string
matching
regexp
item
regexp
1
regexp
2
alternative
Match
any
string
that
matches
regexp
1
or
regexp
2
If
both
regexp
1
and
regexp
2
are
character
sets
this
constructions
produces
another
character
set
obtained
by
taking
the
union
of
regexp
1
and
regexp
2
item
regexp
1
regexp
2
concatenation
Match
the
concatenation
of
two
strings
the
first
matching
regexp
1
the
second
matching
regexp
2
item
regexp
Match
the
same
strings
as
regexp
item
ident
Reference
the
regular
expression
bound
to
ident
by
an
earlier
let
ident
regexp
definition
item
regexp
as
ident
Bind
the
substring
matched
by
regexp
to
identifier
ident
end
options
Concerning
the
precedences
of
operators
has
the
highest
precedence
followed
by
and
then
concatenation
then
alternation
then
as
subsection
ss
ocamllex
actions
Actions
The
actions
are
arbitrary
OCaml
expressions
They
are
evaluated
in
a
context
where
the
identifiers
defined
by
using
the
as
construct
are
bound
to
subparts
of
the
matched
string
Additionally
lexbuf
is
bound
to
the
current
lexer
buffer
Some
typical
uses
for
lexbuf
in
conjunction
with
the
operations
on
lexer
buffers
provided
by
the
Lexing
standard
library
module
are
listed
below
begin
options
item
Lexing
lexeme
lexbuf
Return
the
matched
string
item
Lexing
lexeme
char
lexbuf
n
Return
the
n
th
character
in
the
matched
string
The
first
character
corresponds
to
n
0
item
Lexing
lexeme
start
lexbuf
Return
the
absolute
position
in
the
input
text
of
the
beginning
of
the
matched
string
i
e
the
offset
of
the
first
character
of
the
matched
string
The
first
character
read
from
the
input
text
has
offset
0
item
Lexing
lexeme
end
lexbuf
Return
the
absolute
position
in
the
input
text
of
the
end
of
the
matched
string
i
e
the
offset
of
the
first
character
after
the
matched
string
The
first
character
read
from
the
input
text
has
offset
0
newcommand
sub
1
1
item
var
entrypoint
var
exp
sub
1
ldots
var
exp
sub
n
lexbuf
Where
var
entrypoint
is
the
name
of
another
entry
point
in
the
same
lexer
definition
Recursively
call
the
lexer
on
the
given
entry
point
Notice
that
lexbuf
is
the
last
argument
Useful
for
lexing
nested
comments
for
example
end
options
subsection
ss
ocamllex
variables
Variables
in
regular
expressions
The
as
construct
is
similar
to
emph
groups
as
provided
by
numerous
regular
expression
packages
The
type
of
these
variables
can
be
string
char
string
option
or
char
option
We
first
consider
the
case
of
linear
patterns
that
is
the
case
when
all
as
bound
variables
are
distinct
In
regexp
as
ident
the
type
of
ident
normally
is
string
or
string
option
except
when
regexp
is
a
character
constant
an
underscore
a
string
constant
of
length
one
a
character
set
specification
or
an
alternation
of
those
Then
the
type
of
ident
is
char
or
char
option
Option
types
are
introduced
when
overall
rule
matching
does
not
imply
matching
of
the
bound
sub
pattern
This
is
in
particular
the
case
of
regexp
as
ident
and
of
regexp
1
regexp
2
as
ident
There
is
no
linearity
restriction
over
as
bound
variables
When
a
variable
is
bound
more
than
once
the
previous
rules
are
to
be
extended
as
follows
begin
itemize
item
A
variable
is
a
char
variable
when
all
its
occurrences
bind
char
occurrences
in
the
previous
sense
item
A
variable
is
an
option
variable
when
the
overall
expression
can
be
matched
without
binding
this
variable
end
itemize
For
instance
in
a
as
x
a
as
x
the
variable
x
is
of
type
char
whereas
in
ab
as
x
a
as
x
the
variable
x
is
of
type
string
option
In
some
cases
a
successful
match
may
not
yield
a
unique
set
of
bindings
For
instance
the
matching
of
verb
aba
by
the
regular
expression
a
ab
as
x
ba
a
as
y
may
result
in
binding
either
verb
x
to
verb
ab
and
verb
y
to
verb
a
or
verb
x
to
verb
a
and
verb
y
to
verb
ba
The
automata
produced
ocamllex
on
such
ambiguous
regular
expressions
will
select
one
of
the
possible
resulting
sets
of
bindings
The
selected
set
of
bindings
is
purposely
left
unspecified
subsection
ss
refill
handlers
Refill
handlers
By
default
when
ocamllex
reaches
the
end
of
its
lexing
buffer
it
will
silently
call
the
refill
buff
function
of
lexbuf
structure
and
continue
lexing
It
is
sometimes
useful
to
be
able
to
take
control
of
refilling
action
typically
if
you
use
a
library
for
asynchronous
computation
you
may
want
to
wrap
the
refilling
action
in
a
delaying
function
to
avoid
blocking
synchronous
operations
Since
OCaml
4
02
it
is
possible
to
specify
a
var
refill
handler
a
function
that
will
be
called
when
refill
happens
It
is
passed
the
continuation
of
the
lexing
on
which
it
has
total
control
The
OCaml
expression
used
as
refill
action
should
have
a
type
that
is
an
instance
of
begin
verbatim
Lexing
lexbuf
a
Lexing
lexbuf
a
end
verbatim
where
the
first
argument
is
the
continuation
which
captures
the
processing
ocamllex
would
usually
perform
refilling
the
buffer
then
calling
the
lexing
function
again
and
the
result
type
that
instantiates
a
should
unify
with
the
result
type
of
all
lexing
rules
As
an
example
consider
the
following
lexer
that
is
parametrized
over
an
arbitrary
monad
begin
verbatim
type
token
EOL
INT
of
int
PLUS
module
Make
M
sig
type
a
t
val
return
a
a
t
val
bind
a
t
a
b
t
b
t
val
fail
string
a
t
Set
up
lexbuf
val
on
refill
Lexing
lexbuf
unit
t
end
struct
let
refill
handler
k
lexbuf
M
bind
M
on
refill
lexbuf
fun
k
lexbuf
refill
refill
handler
rule
token
parse
t
token
lexbuf
n
M
return
EOL
0
9
as
i
M
return
INT
int
of
string
i
M
return
PLUS
M
fail
unexpected
character
end
end
verbatim
subsection
ss
ocamllex
reserved
ident
Reserved
identifiers
All
identifiers
starting
with
ocaml
lex
are
reserved
for
use
by
ocamllex
do
not
use
any
such
identifier
in
your
programs
section
s
ocamlyacc
overview
Overview
of
texttt
ocamlyacc
The
ocamlyacc
command
produces
a
parser
from
a
context
free
grammar
specification
with
attached
semantic
actions
in
the
style
of
yacc
Assuming
the
input
file
is
var
grammar
mly
executing
begin
alltt
ocamlyacc
var
options
var
grammar
mly
end
alltt
produces
OCaml
code
for
a
parser
in
the
file
var
grammar
ml
and
its
interface
in
file
var
grammar
mli
The
generated
module
defines
one
parsing
function
per
entry
point
in
the
grammar
These
functions
have
the
same
names
as
the
entry
points
Parsing
functions
take
as
arguments
a
lexical
analyzer
a
function
from
lexer
buffers
to
tokens
and
a
lexer
buffer
and
return
the
semantic
attribute
of
the
corresponding
entry
point
Lexical
analyzer
functions
are
usually
generated
from
a
lexer
specification
by
the
ocamllex
program
Lexer
buffers
are
an
abstract
data
type
implemented
in
the
standard
library
module
Lexing
Tokens
are
values
from
the
concrete
type
token
defined
in
the
interface
file
var
grammar
mli
produced
by
ocamlyacc
section
s
ocamlyacc
syntax
Syntax
of
grammar
definitions
Grammar
definitions
have
the
following
format
begin
alltt
var
header
var
declarations
var
rules
var
trailer
end
alltt
Comments
are
delimited
by
verb
and
verb
as
in
OCaml
Additionally
comments
can
be
delimited
by
verb
and
verb
as
in
C
in
the
declarations
and
rules
sections
C
style
comments
do
not
nest
but
OCaml
style
comments
do
subsection
ss
ocamlyacc
header
trailer
Header
and
trailer
The
header
and
the
trailer
sections
are
OCaml
code
that
is
copied
as
is
into
file
var
grammar
ml
Both
sections
are
optional
The
header
goes
at
the
beginning
of
the
output
file
it
usually
contains
open
directives
and
auxiliary
functions
required
by
the
semantic
actions
of
the
rules
The
trailer
goes
at
the
end
of
the
output
file
subsection
ss
ocamlyacc
declarations
Declarations
Declarations
are
given
one
per
line
They
all
start
with
a
verb
sign
begin
options
item
token
constr
ldots
constr
Declare
the
given
symbols
constr
ldots
constr
as
tokens
terminal
symbols
These
symbols
are
added
as
constant
constructors
for
the
token
concrete
type
item
token
typexpr
constr
ldots
constr
Declare
the
given
symbols
constr
ldots
constr
as
tokens
with
an
attached
attribute
of
the
given
type
These
symbols
are
added
as
constructors
with
arguments
of
the
given
type
for
the
token
concrete
type
The
typexpr
part
is
an
arbitrary
OCaml
type
expression
except
that
all
type
constructor
names
must
be
fully
qualified
e
g
Modname
typename
for
all
types
except
standard
built
in
types
even
if
the
proper
verb
open
directives
e
g
verb
open
Modname
were
given
in
the
header
section
That
s
because
the
header
is
copied
only
to
the
ml
output
file
but
not
to
the
mli
output
file
while
the
typexpr
part
of
a
verb
token
declaration
is
copied
to
both
item
start
symbol
ldots
symbol
Declare
the
given
symbols
as
entry
points
for
the
grammar
For
each
entry
point
a
parsing
function
with
the
same
name
is
defined
in
the
output
module
Non
terminals
that
are
not
declared
as
entry
points
have
no
such
parsing
function
Start
symbols
must
be
given
a
type
with
the
verb
type
directive
below
item
type
typexpr
symbol
ldots
symbol
Specify
the
type
of
the
semantic
attributes
for
the
given
symbols
This
is
mandatory
for
start
symbols
only
Other
nonterminal
symbols
need
not
be
given
types
by
hand
these
types
will
be
inferred
when
running
the
output
files
through
the
OCaml
compiler
unless
the
verb
s
option
is
in
effect
The
typexpr
part
is
an
arbitrary
OCaml
type
expression
except
that
all
type
constructor
names
must
be
fully
qualified
as
explained
above
for
token
item
left
symbol
ldots
symbol
item
right
symbol
ldots
symbol
item
nonassoc
symbol
ldots
symbol
Associate
precedences
and
associativities
to
the
given
symbols
All
symbols
on
the
same
line
are
given
the
same
precedence
They
have
higher
precedence
than
symbols
declared
before
in
a
verb
left
verb
right
or
verb
nonassoc
line
They
have
lower
precedence
than
symbols
declared
after
in
a
verb
left
verb
right
or
verb
nonassoc
line
The
symbols
are
declared
to
associate
to
the
left
verb
left
to
the
right
verb
right
or
to
be
non
associative
verb
nonassoc
The
symbols
are
usually
tokens
They
can
also
be
dummy
nonterminals
for
use
with
the
verb
prec
directive
inside
the
rules
The
precedence
declarations
are
used
in
the
following
way
to
resolve
reduce
reduce
and
shift
reduce
conflicts
begin
itemize
item
Tokens
and
rules
have
precedences
By
default
the
precedence
of
a
rule
is
the
precedence
of
its
rightmost
terminal
You
can
override
this
default
by
using
the
prec
directive
in
the
rule
item
A
reduce
reduce
conflict
is
resolved
in
favor
of
the
first
rule
in
the
order
given
by
the
source
file
and
ocamlyacc
outputs
a
warning
item
A
shift
reduce
conflict
is
resolved
by
comparing
the
precedence
of
the
rule
to
be
reduced
with
the
precedence
of
the
token
to
be
shifted
If
the
precedence
of
the
rule
is
higher
then
the
rule
will
be
reduced
if
the
precedence
of
the
token
is
higher
then
the
token
will
be
shifted
item
A
shift
reduce
conflict
between
a
rule
and
a
token
with
the
same
precedence
will
be
resolved
using
the
associativity
if
the
token
is
left
associative
then
the
parser
will
reduce
if
the
token
is
right
associative
then
the
parser
will
shift
If
the
token
is
non
associative
then
the
parser
will
declare
a
syntax
error
item
When
a
shift
reduce
conflict
cannot
be
resolved
using
the
above
method
then
ocamlyacc
will
output
a
warning
and
the
parser
will
always
shift
end
itemize
end
options
subsection
ss
ocamlyacc
rules
Rules
The
syntax
for
rules
is
as
usual
begin
alltt
var
nonterminal
var
symbol
ldots
var
symbol
var
semantic
action
ldots
var
symbol
ldots
var
symbol
var
semantic
action
end
alltt
Rules
can
also
contain
the
verb
prec
it
symbol
directive
in
the
right
hand
side
part
to
override
the
default
precedence
and
associativity
of
the
rule
with
the
precedence
and
associativity
of
the
given
symbol
Semantic
actions
are
arbitrary
OCaml
expressions
that
are
evaluated
to
produce
the
semantic
attribute
attached
to
the
defined
nonterminal
The
semantic
actions
can
access
the
semantic
attributes
of
the
symbols
in
the
right
hand
side
of
the
rule
with
the
verb
notation
verb
1
is
the
attribute
for
the
first
leftmost
symbol
verb
2
is
the
attribute
for
the
second
symbol
etc
The
rules
may
contain
the
special
symbol
error
to
indicate
resynchronization
points
as
in
yacc
Actions
occurring
in
the
middle
of
rules
are
not
supported
Nonterminal
symbols
are
like
regular
OCaml
symbols
except
that
they
cannot
end
with
single
quote
subsection
ss
ocamlyacc
error
handling
Error
handling
Error
recovery
is
supported
as
follows
when
the
parser
reaches
an
error
state
no
grammar
rules
can
apply
it
calls
a
function
named
parse
error
with
the
string
syntax
error
as
argument
The
default
parse
error
function
does
nothing
and
returns
thus
initiating
error
recovery
see
below
The
user
can
define
a
customized
parse
error
function
in
the
header
section
of
the
grammar
file
The
parser
also
enters
error
recovery
mode
if
one
of
the
grammar
actions
raises
the
Parsing
Parse
error
exception
In
error
recovery
mode
the
parser
discards
states
from
the
stack
until
it
reaches
a
place
where
the
error
token
can
be
shifted
It
then
discards
tokens
from
the
input
until
it
finds
three
successive
tokens
that
can
be
accepted
and
starts
processing
with
the
first
of
these
If
no
state
can
be
uncovered
where
the
error
token
can
be
shifted
then
the
parser
aborts
by
raising
the
Parsing
Parse
error
exception
Refer
to
documentation
on
yacc
for
more
details
and
guidance
in
how
to
use
error
recovery
section
s
ocamlyacc
options
Options
The
ocamlyacc
command
recognizes
the
following
options
begin
options
item
b
it
prefix
Name
the
output
files
it
prefix
ml
it
prefix
mli
it
prefix
output
instead
of
the
default
naming
convention
item
q
This
option
has
no
effect
item
v
Generate
a
description
of
the
parsing
tables
and
a
report
on
conflicts
resulting
from
ambiguities
in
the
grammar
The
description
is
put
in
file
var
grammar
output
item
version
Print
version
string
and
exit
item
vnum
Print
short
version
number
and
exit
item
Read
the
grammar
specification
from
standard
input
The
default
output
file
names
are
stdin
ml
and
stdin
mli
item
var
file
Process
var
file
as
the
grammar
specification
even
if
its
name
starts
with
a
dash
character
This
option
must
be
the
last
on
the
command
line
end
options
At
run
time
the
ocamlyacc
generated
parser
can
be
debugged
by
setting
the
p
option
in
the
OCAMLRUNPARAM
environment
variable
see
section
ref
s
ocamlrun
options
This
causes
the
pushdown
automaton
executing
the
parser
to
print
a
trace
of
its
action
tokens
shifted
rules
reduced
etc
The
trace
mentions
rule
numbers
and
state
numbers
that
can
be
interpreted
by
looking
at
the
file
var
grammar
output
generated
by
ocamlyacc
v
section
s
lexyacc
example
A
complete
example
The
all
time
favorite
a
desk
calculator
This
program
reads
arithmetic
expressions
on
standard
input
one
per
line
and
prints
their
values
Here
is
the
grammar
definition
begin
verbatim
File
parser
mly
token
int
INT
token
PLUS
MINUS
TIMES
DIV
token
LPAREN
RPAREN
token
EOL
left
PLUS
MINUS
lowest
precedence
left
TIMES
DIV
medium
precedence
nonassoc
UMINUS
highest
precedence
start
main
the
entry
point
type
int
main
main
expr
EOL
1
expr
INT
1
LPAREN
expr
RPAREN
2
expr
PLUS
expr
1
3
expr
MINUS
expr
1
3
expr
TIMES
expr
1
3
expr
DIV
expr
1
3
MINUS
expr
prec
UMINUS
2
end
verbatim
Here
is
the
definition
for
the
corresponding
lexer
begin
verbatim
File
lexer
mll
open
Parser
The
type
token
is
defined
in
parser
mli
exception
Eof
rule
token
parse
t
token
lexbuf
skip
blanks
n
EOL
0
9
as
lxm
INT
int
of
string
lxm
PLUS
MINUS
TIMES
DIV
LPAREN
RPAREN
eof
raise
Eof
end
verbatim
Here
is
the
main
program
that
combines
the
parser
with
the
lexer
begin
verbatim
File
calc
ml
let
try
let
lexbuf
Lexing
from
channel
stdin
in
while
true
do
let
result
Parser
main
Lexer
token
lexbuf
in
print
int
result
print
newline
flush
stdout
done
with
Lexer
Eof
exit
0
end
verbatim
To
compile
everything
execute
begin
verbatim
ocamllex
lexer
mll
generates
lexer
ml
ocamlyacc
parser
mly
generates
parser
ml
and
parser
mli
ocamlc
c
parser
mli
ocamlc
c
lexer
ml
ocamlc
c
parser
ml
ocamlc
c
calc
ml
ocamlc
o
calc
lexer
cmo
parser
cmo
calc
cmo
end
verbatim
section
s
lexyacc
common
errors
Common
errors
begin
options
item
ocamllex
transition
table
overflow
automaton
is
too
big
The
deterministic
automata
generated
by
ocamllex
are
limited
to
at
most
32767
transitions
The
message
above
indicates
that
your
lexer
definition
is
too
complex
and
overflows
this
limit
This
is
commonly
caused
by
lexer
definitions
that
have
separate
rules
for
each
of
the
alphabetic
keywords
of
the
language
as
in
the
following
example
begin
verbatim
rule
token
parse
keyword1
KWD1
keyword2
KWD2
keyword100
KWD100
A
Z
a
z
A
Z
a
z
0
9
as
id
IDENT
id
end
verbatim
To
keep
the
generated
automata
small
rewrite
those
definitions
with
only
one
general
identifier
rule
followed
by
a
hashtable
lookup
to
separate
keywords
from
identifiers
begin
verbatim
let
keyword
table
Hashtbl
create
53
let
List
iter
fun
kwd
tok
Hashtbl
add
keyword
table
kwd
tok
keyword1
KWD1
keyword2
KWD2
keyword100
KWD100
rule
token
parse
A
Z
a
z
A
Z
a
z
0
9
as
id
try
Hashtbl
find
keyword
table
id
with
Not
found
IDENT
id
end
verbatim
item
ocamllex
Position
memory
overflow
too
many
bindings
The
deterministic
automata
generated
by
ocamllex
maintain
a
table
of
positions
inside
the
scanned
lexer
buffer
The
size
of
this
table
is
limited
to
at
most
255
cells
This
error
should
not
show
up
in
normal
situations
item
ocamlyacc
concurrency
safety
Parsers
generated
by
ocamlyacc
are
not
thread
safe
Those
parsers
rely
on
an
internal
work
state
which
is
shared
by
all
ocamlyacc
generated
parsers
The
href
https
cambium
inria
fr
fpottier
menhir
menhir
parser
generator
is
a
better
option
if
you
want
thread
safe
parsers
end
options
chapter
Native
code
compilation
ocamlopt
label
c
nativecomp
HEVEA
cutname
native
html
This
chapter
describes
the
OCaml
high
performance
native
code
compiler
ocamlopt
which
compiles
OCaml
source
files
to
native
code
object
files
and
links
these
object
files
to
produce
standalone
executables
The
native
code
compiler
is
only
available
on
certain
platforms
It
produces
code
that
runs
faster
than
the
bytecode
produced
by
ocamlc
at
the
cost
of
increased
compilation
time
and
executable
code
size
Compatibility
with
the
bytecode
compiler
is
extremely
high
the
same
source
code
should
run
identically
when
compiled
with
ocamlc
and
ocamlopt
It
is
not
possible
to
mix
native
code
object
files
produced
by
ocamlopt
with
bytecode
object
files
produced
by
ocamlc
a
program
must
be
compiled
entirely
with
ocamlopt
or
entirely
with
ocamlc
Native
code
object
files
produced
by
ocamlopt
cannot
be
loaded
in
the
toplevel
system
ocaml
section
s
native
overview
Overview
of
the
compiler
The
ocamlopt
command
has
a
command
line
interface
very
close
to
that
of
ocamlc
It
accepts
the
same
types
of
arguments
and
processes
them
sequentially
after
all
options
have
been
processed
begin
itemize
item
Arguments
ending
in
mli
are
taken
to
be
source
files
for
compilation
unit
interfaces
Interfaces
specify
the
names
exported
by
compilation
units
they
declare
value
names
with
their
types
define
public
data
types
declare
abstract
data
types
and
so
on
From
the
file
var
x
mli
the
ocamlopt
compiler
produces
a
compiled
interface
in
the
file
var
x
cmi
The
interface
produced
is
identical
to
that
produced
by
the
bytecode
compiler
ocamlc
item
Arguments
ending
in
ml
are
taken
to
be
source
files
for
compilation
unit
implementations
Implementations
provide
definitions
for
the
names
exported
by
the
unit
and
also
contain
expressions
to
be
evaluated
for
their
side
effects
From
the
file
var
x
ml
the
ocamlopt
compiler
produces
two
files
var
x
o
containing
native
object
code
and
var
x
cmx
containing
extra
information
for
linking
and
optimization
of
the
clients
of
the
unit
The
compiled
implementation
should
always
be
referred
to
under
the
name
var
x
cmx
when
given
a
o
or
obj
file
ocamlopt
assumes
that
it
contains
code
compiled
from
C
not
from
OCaml
The
implementation
is
checked
against
the
interface
file
var
x
mli
if
it
exists
as
described
in
the
manual
for
ocamlc
chapter
ref
c
camlc
item
Arguments
ending
in
cmx
are
taken
to
be
compiled
object
code
These
files
are
linked
together
along
with
the
object
files
obtained
by
compiling
ml
arguments
if
any
and
the
OCaml
standard
library
to
produce
a
native
code
executable
program
The
order
in
which
cmx
and
ml
arguments
are
presented
on
the
command
line
is
relevant
compilation
units
are
initialized
in
that
order
at
run
time
and
it
is
a
link
time
error
to
use
a
component
of
a
unit
before
having
initialized
it
Hence
a
given
var
x
cmx
file
must
come
before
all
cmx
files
that
refer
to
the
unit
var
x
item
Arguments
ending
in
cmxa
are
taken
to
be
libraries
of
object
code
Such
a
library
packs
in
two
files
var
lib
cmxa
and
var
lib
a
lib
a
set
of
object
files
cmx
and
o
obj
files
Libraries
are
build
with
ocamlopt
a
see
the
description
of
the
a
option
below
The
object
files
contained
in
the
library
are
linked
as
regular
cmx
files
see
above
in
the
order
specified
when
the
library
was
built
The
only
difference
is
that
if
an
object
file
contained
in
a
library
is
not
referenced
anywhere
in
the
program
then
it
is
not
linked
in
item
Arguments
ending
in
c
are
passed
to
the
C
compiler
which
generates
a
o
obj
object
file
This
object
file
is
linked
with
the
program
item
Arguments
ending
in
o
a
or
so
obj
lib
and
dll
under
Windows
are
assumed
to
be
C
object
files
and
libraries
They
are
linked
with
the
program
end
itemize
The
output
of
the
linking
phase
is
a
regular
Unix
or
Windows
executable
file
It
does
not
need
ocamlrun
to
run
The
compiler
is
able
to
emit
some
information
on
its
internal
stages
begin
itemize
item
The
following
two
paragraphs
are
a
duplicate
from
the
description
of
the
batch
compiler
cmt
files
for
the
implementation
of
the
compilation
unit
and
cmti
for
signatures
if
the
option
bin
annot
is
passed
to
it
see
the
description
of
bin
annot
below
Each
such
file
contains
a
typed
abstract
syntax
tree
AST
that
is
produced
during
the
type
checking
procedure
This
tree
contains
all
available
information
about
the
location
and
the
specific
type
of
each
term
in
the
source
file
The
AST
is
partial
if
type
checking
was
unsuccessful
These
cmt
and
cmti
files
are
typically
useful
for
code
inspection
tools
item
cmir
linear
files
for
the
implementation
of
the
compilation
unit
if
the
option
save
ir
after
scheduling
is
passed
to
it
Each
such
file
contains
a
low
level
intermediate
representation
produced
by
the
instruction
scheduling
pass
An
external
tool
can
perform
low
level
optimisations
such
as
code
layout
by
transforming
a
cmir
linear
file
To
continue
compilation
the
compiler
can
be
invoked
with
a
possibly
modified
cmir
linear
file
as
an
argument
instead
of
the
corresponding
source
file
end
itemize
section
s
native
options
Options
The
following
command
line
options
are
recognized
by
ocamlopt
The
options
pack
a
shared
c
output
obj
and
output
complete
obj
are
mutually
exclusive
Configure
boolean
variables
used
by
the
macros
in
unified
options
etex
compfalse
nattrue
topfalse
unified
options
gathers
all
options
across
the
native
bytecode
compilers
and
toplevel
input
unified
options
tex
paragraph
Options
for
the
64
bit
x86
architecture
The
64
bit
code
generator
for
Intel
AMD
x86
processors
amd64
architecture
supports
the
following
additional
options
begin
options
item
fPIC
Generate
position
independent
machine
code
This
is
the
default
item
fno
PIC
Generate
position
dependent
machine
code
end
options
paragraph
Contextual
control
of
command
line
options
The
compiler
command
line
can
be
modified
from
the
outside
with
the
following
mechanisms
These
are
experimental
and
subject
to
change
They
should
be
used
only
for
experimental
and
development
work
not
in
released
packages
begin
options
item
OCAMLPARAM
rm
environment
variable
A
set
of
arguments
that
will
be
inserted
before
or
after
the
arguments
from
the
command
line
Arguments
are
specified
in
a
comma
separated
list
of
name
value
pairs
A
is
used
to
specify
the
position
of
the
command
line
arguments
i
e
a
x
b
y
means
that
a
x
should
be
executed
before
parsing
the
arguments
and
b
y
after
Finally
an
alternative
separator
can
be
specified
as
the
first
character
of
the
string
within
the
set
item
ocaml
compiler
internal
params
rm
file
in
the
stdlib
directory
A
mapping
of
file
names
to
lists
of
arguments
that
will
be
added
to
the
command
line
and
OCAMLPARAM
arguments
end
options
section
s
native
common
errors
Common
errors
The
error
messages
are
almost
identical
to
those
of
ocamlc
See
section
ref
s
comp
errors
section
s
native
running
executable
Running
executables
produced
by
ocamlopt
Executables
generated
by
ocamlopt
are
native
stand
alone
executable
files
that
can
be
invoked
directly
They
do
not
depend
on
the
ocamlrun
bytecode
runtime
system
nor
on
dynamically
loaded
C
OCaml
stub
libraries
During
execution
of
an
ocamlopt
generated
executable
the
following
environment
variables
are
also
consulted
begin
options
item
OCAMLRUNPARAM
Same
usage
as
in
ocamlrun
see
section
ref
s
ocamlrun
options
except
that
option
l
is
ignored
the
operating
system
s
stack
size
limit
is
used
instead
item
CAMLRUNPARAM
If
OCAMLRUNPARAM
is
not
found
in
the
environment
then
CAMLRUNPARAM
will
be
used
instead
If
CAMLRUNPARAM
is
not
found
then
the
default
values
will
be
used
end
options
section
s
compat
native
bytecode
Compatibility
with
the
bytecode
compiler
This
section
lists
the
known
incompatibilities
between
the
bytecode
compiler
and
the
native
code
compiler
Except
on
those
points
the
two
compilers
should
generate
code
that
behave
identically
begin
itemize
item
Signals
are
detected
only
when
the
program
performs
an
allocation
in
the
heap
That
is
if
a
signal
is
delivered
while
in
a
piece
of
code
that
does
not
allocate
its
handler
will
not
be
called
until
the
next
heap
allocation
item
On
ARM
and
PowerPC
processors
32
and
64
bits
fused
multiply
add
FMA
instructions
can
be
generated
for
a
floating
point
multiplication
followed
by
a
floating
point
addition
or
subtraction
as
in
x
y
z
The
FMA
instruction
avoids
rounding
the
intermediate
result
x
y
which
is
generally
beneficial
but
produces
floating
point
results
that
differ
slightly
from
those
produced
by
the
bytecode
interpreter
item
The
native
code
compiler
performs
a
number
of
optimizations
that
the
bytecode
compiler
does
not
perform
especially
when
the
Flambda
optimizer
is
active
In
particular
the
native
code
compiler
identifies
and
eliminates
dead
code
i
e
computations
that
do
not
contribute
to
the
results
of
the
program
For
example
begin
verbatim
let
ignore
M
f
end
verbatim
contains
a
reference
to
compilation
unit
M
when
compiled
to
bytecode
This
reference
forces
M
to
be
linked
and
its
initialization
code
to
be
executed
The
native
code
compiler
eliminates
the
reference
to
M
hence
the
compilation
unit
M
may
not
be
linked
and
executed
A
workaround
is
to
compile
M
with
the
linkall
flag
so
that
it
will
always
be
linked
and
executed
even
if
not
referenced
See
also
the
Sys
opaque
identity
function
from
the
Sys
standard
library
module
item
Before
4
10
stack
overflows
typically
caused
by
excessively
deep
recursion
are
not
always
turned
into
a
Stack
overflow
exception
like
with
the
bytecode
compiler
The
runtime
system
makes
a
best
effort
to
trap
stack
overflows
and
raise
the
Stack
overflow
exception
but
sometimes
it
fails
and
a
segmentation
fault
or
another
system
fault
occurs
instead
end
itemize
chapter
The
debugger
ocamldebug
label
c
debugger
HEVEA
cutname
debugger
html
This
chapter
describes
the
OCaml
source
level
replay
debugger
ocamldebug
The
debugger
is
available
on
systems
that
provide
BSD
sockets
including
Windows
Under
the
native
Windows
ports
the
replay
functions
are
not
enabled
section
s
debugger
compilation
Compiling
for
debugging
Before
the
debugger
can
be
used
the
program
must
be
compiled
and
linked
with
the
g
option
all
cmo
and
cma
files
that
are
part
of
the
program
should
have
been
created
with
ocamlc
g
and
they
must
be
linked
together
with
ocamlc
g
Compiling
with
g
entails
no
penalty
on
the
running
time
of
programs
object
files
and
bytecode
executable
files
are
bigger
and
take
longer
to
produce
but
the
executable
files
run
at
exactly
the
same
speed
as
if
they
had
been
compiled
without
g
section
s
debugger
invocation
Invocation
subsection
ss
debugger
start
Starting
the
debugger
The
OCaml
debugger
is
invoked
by
running
the
program
ocamldebug
with
the
name
of
the
bytecode
executable
file
as
first
argument
begin
alltt
ocamldebug
optvar
options
var
program
optvar
arguments
end
alltt
The
arguments
following
var
program
are
optional
and
are
passed
as
command
line
arguments
to
the
program
being
debugged
See
also
the
set
arguments
command
The
following
command
line
options
are
recognized
begin
options
item
c
var
count
Set
the
maximum
number
of
simultaneously
live
checkpoints
to
var
count
item
cd
var
dir
Run
the
debugger
program
from
the
working
directory
var
dir
instead
of
the
current
directory
See
also
the
cd
command
item
emacs
Tell
the
debugger
it
is
executed
under
Emacs
See
section
ref
s
inf
debugger
for
information
on
how
to
run
the
debugger
under
Emacs
item
I
var
directory
Add
var
directory
to
the
list
of
directories
searched
for
source
files
and
compiled
files
See
also
the
directory
command
item
s
var
socket
Use
var
socket
for
communicating
with
the
debugged
program
See
the
description
of
the
command
set
socket
section
ref
ss
debugger
communication
for
the
format
of
var
socket
item
version
Print
version
string
and
exit
item
vnum
Print
short
version
number
and
exit
item
help
or
help
Display
a
short
usage
summary
and
exit
end
options
subsection
ss
debugger
init
file
Initialization
file
On
start
up
the
debugger
will
read
commands
from
an
initialization
file
before
giving
control
to
the
user
The
default
file
is
ocamldebug
in
the
current
directory
if
it
exists
otherwise
ocamldebug
in
the
user
s
home
directory
subsection
ss
debugger
exut
Exiting
the
debugger
The
command
quit
exits
the
debugger
You
can
also
exit
the
debugger
by
typing
an
end
of
file
character
usually
ctrl
D
Typing
an
interrupt
character
usually
ctrl
C
will
not
exit
the
debugger
but
will
terminate
the
action
of
any
debugger
command
that
is
in
progress
and
return
to
the
debugger
command
level
section
s
debugger
commands
Commands
A
debugger
command
is
a
single
line
of
input
It
starts
with
a
command
name
which
is
followed
by
arguments
depending
on
this
name
Examples
begin
verbatim
run
goto
1000
set
arguments
arg1
arg2
end
verbatim
A
command
name
can
be
truncated
as
long
as
there
is
no
ambiguity
For
instance
go
1000
is
understood
as
goto
1000
since
there
are
no
other
commands
whose
name
starts
with
go
For
the
most
frequently
used
commands
ambiguous
abbreviations
are
allowed
For
instance
r
stands
for
run
even
though
there
are
others
commands
starting
with
r
You
can
test
the
validity
of
an
abbreviation
using
the
help
command
If
the
previous
command
has
been
successful
a
blank
line
typing
just
RET
will
repeat
it
subsection
ss
debugger
help
Getting
help
The
OCaml
debugger
has
a
simple
on
line
help
system
which
gives
a
brief
description
of
each
command
and
variable
begin
options
item
help
Print
the
list
of
commands
item
help
var
command
Give
help
about
the
command
var
command
item
help
set
var
variable
help
show
var
variable
Give
help
about
the
variable
var
variable
The
list
of
all
debugger
variables
can
be
obtained
with
help
set
item
help
info
var
topic
Give
help
about
var
topic
Use
help
info
to
get
a
list
of
known
topics
end
options
subsection
ss
debugger
state
Accessing
the
debugger
state
begin
options
item
set
var
variable
var
value
Set
the
debugger
variable
var
variable
to
the
value
var
value
item
show
var
variable
Print
the
value
of
the
debugger
variable
var
variable
item
info
var
subject
Give
information
about
the
given
subject
For
instance
info
breakpoints
will
print
the
list
of
all
breakpoints
end
options
section
s
debugger
execution
Executing
a
program
subsection
ss
debugger
events
Events
Events
are
interesting
locations
in
the
source
code
corresponding
to
the
beginning
or
end
of
evaluation
of
interesting
sub
expressions
Events
are
the
unit
of
single
stepping
stepping
goes
to
the
next
or
previous
event
encountered
in
the
program
execution
Also
breakpoints
can
only
be
set
at
events
Thus
events
play
the
role
of
line
numbers
in
debuggers
for
conventional
languages
During
program
execution
a
counter
is
incremented
at
each
event
encountered
The
value
of
this
counter
is
referred
as
the
em
current
time
Thanks
to
reverse
execution
it
is
possible
to
jump
back
and
forth
to
any
time
of
the
execution
Here
is
where
the
debugger
events
written
event
are
located
in
the
source
code
begin
itemize
item
Following
a
function
application
begin
alltt
f
arg
event
end
alltt
item
On
entrance
to
a
function
begin
alltt
fun
x
y
z
event
end
alltt
item
On
each
case
of
a
pattern
matching
definition
function
match
ldots
with
construct
try
ldots
with
construct
begin
alltt
function
pat1
event
expr1
patN
event
exprN
end
alltt
item
Between
subexpressions
of
a
sequence
begin
alltt
expr1
event
expr2
event
event
exprN
end
alltt
item
In
the
two
branches
of
a
conditional
expression
begin
alltt
if
cond
then
event
expr1
else
event
expr2
end
alltt
item
At
the
beginning
of
each
iteration
of
a
loop
begin
alltt
while
cond
do
event
body
done
for
i
a
to
b
do
event
body
done
end
alltt
end
itemize
Exceptions
A
function
application
followed
by
a
function
return
is
replaced
by
the
compiler
by
a
jump
tail
call
optimization
In
this
case
no
event
is
put
after
the
function
application
Also
no
event
is
put
after
a
function
application
when
the
function
is
external
written
in
C
subsection
ss
debugger
starting
program
Starting
the
debugged
program
The
debugger
starts
executing
the
debugged
program
only
when
needed
This
allows
setting
breakpoints
or
assigning
debugger
variables
before
execution
starts
There
are
several
ways
to
start
execution
begin
options
item
run
Run
the
program
until
a
breakpoint
is
hit
or
the
program
terminates
item
goto
0
Load
the
program
and
stop
on
the
first
event
item
goto
var
time
Load
the
program
and
execute
it
until
the
given
time
Useful
when
you
already
know
approximately
at
what
time
the
problem
appears
Also
useful
to
set
breakpoints
on
function
values
that
have
not
been
computed
at
time
0
see
section
ref
s
breakpoints
end
options
The
execution
of
a
program
is
affected
by
certain
information
it
receives
when
the
debugger
starts
it
such
as
the
command
line
arguments
to
the
program
and
its
working
directory
The
debugger
provides
commands
to
specify
this
information
set
arguments
and
cd
These
commands
must
be
used
before
program
execution
starts
If
you
try
to
change
the
arguments
or
the
working
directory
after
starting
your
program
the
debugger
will
kill
the
program
after
asking
for
confirmation
subsection
ss
debugger
running
Running
the
program
The
following
commands
execute
the
program
forward
or
backward
starting
at
the
current
time
The
execution
will
stop
either
when
specified
by
the
command
or
when
a
breakpoint
is
encountered
begin
options
item
run
Execute
the
program
forward
from
current
time
Stops
at
next
breakpoint
or
when
the
program
terminates
item
reverse
Execute
the
program
backward
from
current
time
Mostly
useful
to
go
to
the
last
breakpoint
encountered
before
the
current
time
item
step
optvar
count
Run
the
program
and
stop
at
the
next
event
With
an
argument
do
it
var
count
times
If
var
count
is
0
run
until
the
program
terminates
or
a
breakpoint
is
hit
item
backstep
optvar
count
Run
the
program
backward
and
stop
at
the
previous
event
With
an
argument
do
it
var
count
times
item
next
optvar
count
Run
the
program
and
stop
at
the
next
event
skipping
over
function
calls
With
an
argument
do
it
var
count
times
item
previous
optvar
count
Run
the
program
backward
and
stop
at
the
previous
event
skipping
over
function
calls
With
an
argument
do
it
var
count
times
item
finish
Run
the
program
until
the
current
function
returns
item
start
Run
the
program
backward
and
stop
at
the
first
event
before
the
current
function
invocation
end
options
subsection
ss
debugger
time
travel
Time
travel
You
can
jump
directly
to
a
given
time
without
stopping
on
breakpoints
using
the
goto
command
As
you
move
through
the
program
the
debugger
maintains
an
history
of
the
successive
times
you
stop
at
The
last
command
can
be
used
to
revisit
these
times
each
last
command
moves
one
step
back
through
the
history
That
is
useful
mainly
to
undo
commands
such
as
step
and
next
begin
options
item
goto
var
time
Jump
to
the
given
time
item
last
optvar
count
Go
back
to
the
latest
time
recorded
in
the
execution
history
With
an
argument
do
it
var
count
times
item
set
history
var
size
Set
the
size
of
the
execution
history
end
options
subsection
ss
debugger
kill
Killing
the
program
begin
options
item
kill
Kill
the
program
being
executed
This
command
is
mainly
useful
if
you
wish
to
recompile
the
program
without
leaving
the
debugger
end
options
section
s
breakpoints
Breakpoints
A
breakpoint
causes
the
program
to
stop
whenever
a
certain
point
in
the
program
is
reached
It
can
be
set
in
several
ways
using
the
break
command
Breakpoints
are
assigned
numbers
when
set
for
further
reference
The
most
comfortable
way
to
set
breakpoints
is
through
the
Emacs
interface
see
section
ref
s
inf
debugger
begin
options
item
break
Set
a
breakpoint
at
the
current
position
in
the
program
execution
The
current
position
must
be
on
an
event
i
e
neither
at
the
beginning
nor
at
the
end
of
the
program
item
break
var
function
Set
a
breakpoint
at
the
beginning
of
var
function
This
works
only
when
the
functional
value
of
the
identifier
var
function
has
been
computed
and
assigned
to
the
identifier
Hence
this
command
cannot
be
used
at
the
very
beginning
of
the
program
execution
when
all
identifiers
are
still
undefined
use
goto
var
time
to
advance
execution
until
the
functional
value
is
available
item
break
optvar
module
var
line
Set
a
breakpoint
in
module
var
module
or
in
the
current
module
if
var
module
is
not
given
at
the
first
event
of
line
var
line
item
break
optvar
module
var
line
var
column
Set
a
breakpoint
in
module
var
module
or
in
the
current
module
if
var
module
is
not
given
at
the
event
closest
to
line
var
line
column
var
column
item
break
optvar
module
var
character
Set
a
breakpoint
in
module
var
module
at
the
event
closest
to
character
number
var
character
item
break
var
frag
var
pc
break
var
pc
Set
a
breakpoint
at
code
address
var
frag
var
pc
The
integer
var
frag
is
the
identifier
of
a
code
fragment
a
set
of
modules
that
have
been
loaded
at
once
either
initially
or
with
the
Dynlink
module
The
integer
var
pc
is
the
instruction
counter
within
this
code
fragment
If
var
frag
is
omitted
it
defaults
to
0
which
is
the
code
fragment
of
the
program
loaded
initially
item
delete
optvar
breakpoint
numbers
Delete
the
specified
breakpoints
Without
argument
all
breakpoints
are
deleted
after
asking
for
confirmation
item
info
breakpoints
Print
the
list
of
all
breakpoints
end
options
section
s
debugger
callstack
The
call
stack
Each
time
the
program
performs
a
function
application
it
saves
the
location
of
the
application
the
return
address
in
a
block
of
data
called
a
stack
frame
The
frame
also
contains
the
local
variables
of
the
caller
function
All
the
frames
are
allocated
in
a
region
of
memory
called
the
call
stack
The
command
backtrace
or
bt
displays
parts
of
the
call
stack
At
any
time
one
of
the
stack
frames
is
selected
by
the
debugger
several
debugger
commands
refer
implicitly
to
the
selected
frame
In
particular
whenever
you
ask
the
debugger
for
the
value
of
a
local
variable
the
value
is
found
in
the
selected
frame
The
commands
frame
up
and
down
select
whichever
frame
you
are
interested
in
When
the
program
stops
the
debugger
automatically
selects
the
currently
executing
frame
and
describes
it
briefly
as
the
frame
command
does
begin
options
item
frame
Describe
the
currently
selected
stack
frame
item
frame
var
frame
number
Select
a
stack
frame
by
number
and
describe
it
The
frame
currently
executing
when
the
program
stopped
has
number
0
its
caller
has
number
1
and
so
on
up
the
call
stack
item
backtrace
optvar
count
bt
optvar
count
Print
the
call
stack
This
is
useful
to
see
which
sequence
of
function
calls
led
to
the
currently
executing
frame
With
a
positive
argument
print
only
the
innermost
var
count
frames
With
a
negative
argument
print
only
the
outermost
var
count
frames
item
up
optvar
count
Select
and
display
the
stack
frame
just
above
the
selected
frame
that
is
the
frame
that
called
the
selected
frame
An
argument
says
how
many
frames
to
go
up
item
down
optvar
count
Select
and
display
the
stack
frame
just
below
the
selected
frame
that
is
the
frame
that
was
called
by
the
selected
frame
An
argument
says
how
many
frames
to
go
down
end
options
section
s
debugger
examining
values
Examining
variable
values
The
debugger
can
print
the
current
value
of
simple
expressions
The
expressions
can
involve
program
variables
all
the
identifiers
that
are
in
scope
at
the
selected
program
point
can
be
accessed
Expressions
that
can
be
printed
are
a
subset
of
OCaml
expressions
as
described
by
the
following
grammar
begin
syntax
simple
expr
lowercase
ident
capitalized
ident
lowercase
ident
integer
simple
expr
lowercase
ident
simple
expr
integer
simple
expr
integer
simple
expr
simple
expr
end
syntax
The
first
two
cases
refer
to
a
value
identifier
either
unqualified
or
qualified
by
the
path
to
the
structure
that
define
it
refers
to
the
result
just
computed
typically
the
value
of
a
function
application
and
is
valid
only
if
the
selected
event
is
an
after
event
typically
a
function
application
integer
refer
to
a
previously
printed
value
The
remaining
four
forms
select
part
of
an
expression
respectively
a
record
field
an
array
element
a
string
element
and
the
current
contents
of
a
reference
begin
options
item
print
var
variables
Print
the
values
of
the
given
variables
print
can
be
abbreviated
as
p
item
display
var
variables
Same
as
print
but
limit
the
depth
of
printing
to
1
Useful
to
browse
large
data
structures
without
printing
them
in
full
display
can
be
abbreviated
as
d
end
options
When
printing
a
complex
expression
a
name
of
the
form
var
integer
is
automatically
assigned
to
its
value
Such
names
are
also
assigned
to
parts
of
the
value
that
cannot
be
printed
because
the
maximal
printing
depth
is
exceeded
Named
values
can
be
printed
later
on
with
the
commands
p
var
integer
or
d
var
integer
Named
values
are
valid
only
as
long
as
the
program
is
stopped
They
are
forgotten
as
soon
as
the
program
resumes
execution
begin
options
item
set
print
depth
var
d
Limit
the
printing
of
values
to
a
maximal
depth
of
var
d
item
set
print
length
var
l
Limit
the
printing
of
values
to
at
most
var
l
nodes
printed
end
options
section
s
debugger
control
Controlling
the
debugger
subsection
ss
debugger
name
and
arguments
Setting
the
program
name
and
arguments
begin
options
item
set
program
var
file
Set
the
program
name
to
var
file
item
set
arguments
var
arguments
Give
var
arguments
as
command
line
arguments
for
the
program
end
options
A
shell
is
used
to
pass
the
arguments
to
the
debugged
program
You
can
therefore
use
wildcards
shell
variables
and
file
redirections
inside
the
arguments
To
debug
programs
that
read
from
standard
input
it
is
recommended
to
redirect
their
input
from
a
file
using
set
arguments
input
file
otherwise
input
to
the
program
and
input
to
the
debugger
are
not
properly
separated
and
inputs
are
not
properly
replayed
when
running
the
program
backwards
subsection
ss
debugger
loading
How
programs
are
loaded
The
loadingmode
variable
controls
how
the
program
is
executed
begin
options
item
set
loadingmode
direct
The
program
is
run
directly
by
the
debugger
This
is
the
default
mode
item
set
loadingmode
runtime
The
debugger
execute
the
OCaml
runtime
ocamlrun
on
the
program
Rarely
useful
moreover
it
prevents
the
debugging
of
programs
compiled
in
custom
runtime
mode
item
set
loadingmode
manual
The
user
starts
manually
the
program
when
asked
by
the
debugger
Allows
remote
debugging
see
section
ref
ss
debugger
communication
end
options
subsection
ss
debugger
search
path
Search
path
for
files
The
debugger
searches
for
source
files
and
compiled
interface
files
in
a
list
of
directories
the
search
path
The
search
path
initially
contains
the
current
directory
and
the
standard
library
directory
The
directory
command
adds
directories
to
the
path
Whenever
the
search
path
is
modified
the
debugger
will
clear
any
information
it
may
have
cached
about
the
files
begin
options
item
directory
var
directorynames
Add
the
given
directories
to
the
search
path
These
directories
are
added
at
the
front
and
will
therefore
be
searched
first
item
directory
var
directorynames
for
var
modulename
Same
as
directory
var
directorynames
but
the
given
directories
will
be
searched
only
when
looking
for
the
source
file
of
a
module
that
has
been
packed
into
var
modulename
item
directory
Reset
the
search
path
This
requires
confirmation
end
options
subsection
ss
debugger
working
dir
Working
directory
Each
time
a
program
is
started
in
the
debugger
it
inherits
its
working
directory
from
the
current
working
directory
of
the
debugger
This
working
directory
is
initially
whatever
it
inherited
from
its
parent
process
typically
the
shell
but
you
can
specify
a
new
working
directory
in
the
debugger
with
the
cd
command
or
the
cd
command
line
option
begin
options
item
cd
var
directory
Set
the
working
directory
for
ocamldebug
to
var
directory
item
pwd
Print
the
working
directory
for
ocamldebug
end
options
subsection
ss
debugger
reverse
execution
Turning
reverse
execution
on
and
off
In
some
cases
you
may
want
to
turn
reverse
execution
off
This
speeds
up
the
program
execution
and
is
also
sometimes
useful
for
interactive
programs
Normally
the
debugger
takes
checkpoints
of
the
program
state
from
time
to
time
That
is
it
makes
a
copy
of
the
current
state
of
the
program
using
the
Unix
system
call
fork
If
the
variable
var
checkpoints
is
set
to
off
the
debugger
will
not
take
any
checkpoints
begin
options
item
set
checkpoints
var
on
off
Select
whether
the
debugger
makes
checkpoints
or
not
end
options
subsection
ss
debugger
fork
Behavior
of
the
debugger
with
respect
to
fork
When
the
program
issues
a
call
to
fork
the
debugger
can
either
follow
the
child
or
the
parent
By
default
the
debugger
follows
the
parent
process
The
variable
var
follow
fork
mode
controls
this
behavior
begin
options
item
set
follow
fork
mode
var
child
parent
Select
whether
to
follow
the
child
or
the
parent
in
case
of
a
call
to
fork
end
options
subsection
ss
debugger
stop
at
new
load
Stopping
execution
when
new
code
is
loaded
The
debugger
is
compatible
with
the
Dynlink
module
However
when
an
external
module
is
not
yet
loaded
it
is
impossible
to
set
a
breakpoint
in
its
code
In
order
to
facilitate
setting
breakpoints
in
dynamically
loaded
code
the
debugger
stops
the
program
each
time
new
modules
are
loaded
This
behavior
can
be
disabled
using
the
var
break
on
load
variable
begin
options
item
set
break
on
load
var
on
off
Select
whether
to
stop
after
loading
new
code
end
options
subsection
ss
debugger
communication
Communication
between
the
debugger
and
the
program
The
debugger
communicate
with
the
program
being
debugged
through
a
Unix
socket
You
may
need
to
change
the
socket
name
for
example
if
you
need
to
run
the
debugger
on
a
machine
and
your
program
on
another
begin
options
item
set
socket
var
socket
Use
var
socket
for
communication
with
the
program
var
socket
can
be
either
a
file
name
or
an
Internet
port
specification
var
host
var
port
where
var
host
is
a
host
name
or
an
Internet
address
in
dot
notation
and
var
port
is
a
port
number
on
the
host
end
options
On
the
debugged
program
side
the
socket
name
is
passed
through
the
CAML
DEBUG
SOCKET
environment
variable
subsection
ss
debugger
fine
tuning
Fine
tuning
the
debugger
Several
variables
enables
to
fine
tune
the
debugger
Reasonable
defaults
are
provided
and
you
should
normally
not
have
to
change
them
begin
options
item
set
processcount
var
count
Set
the
maximum
number
of
checkpoints
to
var
count
More
checkpoints
facilitate
going
far
back
in
time
but
use
more
memory
and
create
more
Unix
processes
end
options
As
checkpointing
is
quite
expensive
it
must
not
be
done
too
often
On
the
other
hand
backward
execution
is
faster
when
checkpoints
are
taken
more
often
In
particular
backward
single
stepping
is
more
responsive
when
many
checkpoints
have
been
taken
just
before
the
current
time
To
fine
tune
the
checkpointing
strategy
the
debugger
does
not
take
checkpoints
at
the
same
frequency
for
long
displacements
e
g
run
and
small
ones
e
g
step
The
two
variables
bigstep
and
smallstep
contain
the
number
of
events
between
two
checkpoints
in
each
case
begin
options
item
set
bigstep
var
count
Set
the
number
of
events
between
two
checkpoints
for
long
displacements
item
set
smallstep
var
count
Set
the
number
of
events
between
two
checkpoints
for
small
displacements
end
options
The
following
commands
display
information
on
checkpoints
and
events
begin
options
item
info
checkpoints
Print
a
list
of
checkpoints
item
info
events
optvar
module
Print
the
list
of
events
in
the
given
module
the
current
module
by
default
end
options
subsection
ss
debugger
printers
User
defined
printers
Just
as
in
the
toplevel
system
section
ref
s
toplevel
directives
the
user
can
register
functions
for
printing
values
of
certain
types
For
technical
reasons
the
debugger
cannot
call
printing
functions
that
reside
in
the
program
being
debugged
The
code
for
the
printing
functions
must
therefore
be
loaded
explicitly
in
the
debugger
begin
options
item
load
printer
var
file
name
Load
in
the
debugger
the
indicated
cmo
or
cma
object
file
The
file
is
loaded
in
an
environment
consisting
only
of
the
OCaml
standard
library
plus
the
definitions
provided
by
object
files
previously
loaded
using
load
printer
If
this
file
depends
on
other
object
files
not
yet
loaded
the
debugger
automatically
loads
them
if
it
is
able
to
find
them
in
the
search
path
The
loaded
file
does
not
have
direct
access
to
the
modules
of
the
program
being
debugged
item
install
printer
var
printer
name
Register
the
function
named
var
printer
name
a
value
path
as
a
printer
for
objects
whose
types
match
the
argument
type
of
the
function
That
is
the
debugger
will
call
var
printer
name
when
it
has
such
an
object
to
print
The
printing
function
var
printer
name
must
use
the
Format
library
module
to
produce
its
output
otherwise
its
output
will
not
be
correctly
located
in
the
values
printed
by
the
toplevel
loop
The
value
path
var
printer
name
must
refer
to
one
of
the
functions
defined
by
the
object
files
loaded
using
load
printer
It
cannot
reference
the
functions
of
the
program
being
debugged
item
remove
printer
var
printer
name
Remove
the
named
function
from
the
table
of
value
printers
end
options
section
s
debugger
misc
cmds
Miscellaneous
commands
begin
options
item
list
optvar
module
optvar
beginning
optvar
end
List
the
source
of
module
var
module
from
line
number
var
beginning
to
line
number
var
end
By
default
20
lines
of
the
current
module
are
displayed
starting
10
lines
before
the
current
position
item
source
var
filename
Read
debugger
commands
from
the
script
var
filename
end
options
section
s
inf
debugger
Running
the
debugger
under
Emacs
The
most
user
friendly
way
to
use
the
debugger
is
to
run
it
under
Emacs
with
the
OCaml
mode
available
through
MELPA
and
also
at
url
https
github
com
ocaml
caml
mode
The
OCaml
debugger
is
started
under
Emacs
by
the
command
M
x
camldebug
with
argument
the
name
of
the
executable
file
var
progname
to
debug
Communication
with
the
debugger
takes
place
in
an
Emacs
buffer
named
camldebug
var
progname
The
editing
and
history
facilities
of
Shell
mode
are
available
for
interacting
with
the
debugger
In
addition
Emacs
displays
the
source
files
containing
the
current
event
the
current
position
in
the
program
execution
and
highlights
the
location
of
the
event
This
display
is
updated
synchronously
with
the
debugger
action
The
following
bindings
for
the
most
common
debugger
commands
are
available
in
the
camldebug
var
progname
buffer
begin
options
item
C
c
C
s
command
step
execute
the
program
one
step
forward
item
C
c
C
k
command
backstep
execute
the
program
one
step
backward
item
C
c
C
n
command
next
execute
the
program
one
step
forward
skipping
over
function
calls
item
Middle
mouse
button
command
display
display
named
value
var
n
under
mouse
cursor
support
incremental
browsing
of
large
data
structures
item
C
c
C
p
command
print
print
value
of
identifier
at
point
item
C
c
C
d
command
display
display
value
of
identifier
at
point
item
C
c
C
r
command
run
execute
the
program
forward
to
next
breakpoint
item
C
c
C
v
command
reverse
execute
the
program
backward
to
latest
breakpoint
item
C
c
C
l
command
last
go
back
one
step
in
the
command
history
item
C
c
C
t
command
backtrace
display
backtrace
of
function
calls
item
C
c
C
f
command
finish
run
forward
till
the
current
function
returns
item
C
c
command
up
select
the
stack
frame
below
the
current
frame
item
C
c
command
down
select
the
stack
frame
above
the
current
frame
end
options
In
all
buffers
in
OCaml
editing
mode
the
following
debugger
commands
are
also
available
begin
options
item
C
x
C
a
C
b
command
break
set
a
breakpoint
at
event
closest
to
point
item
C
x
C
a
C
p
command
print
print
value
of
identifier
at
point
item
C
x
C
a
C
d
command
display
display
value
of
identifier
at
point
end
options
chapter
Profiling
ocamlprof
perf
label
c
profiler
HEVEA
cutname
profil
html
This
chapter
describes
different
ways
to
profile
the
execution
of
OCaml
programs
section
s
ocamlprog
overview
Profiling
execution
counts
with
ocamlprof
This
section
describes
how
the
execution
of
OCaml
programs
can
be
profiled
by
recording
how
many
times
functions
are
called
and
branches
of
conditionals
are
taken
This
approach
applies
to
OCaml
programs
compiled
with
the
bytecode
and
native
backends
subsection
s
ocamlprof
compiling
Compiling
for
profiling
Before
profiling
an
execution
the
program
must
be
compiled
in
profiling
mode
using
the
ocamlcp
front
end
to
the
ocamlc
compiler
see
chapter
ref
c
camlc
or
the
ocamloptp
front
end
to
the
ocamlopt
compiler
see
chapter
ref
c
nativecomp
When
compiling
modules
separately
ocamlcp
or
ocamloptp
must
be
used
when
compiling
the
modules
production
of
cmo
or
cmx
files
and
can
also
be
used
though
this
is
not
strictly
necessary
when
linking
them
together
lparagraph
p
ocamlprof
warning
Note
If
a
module
ml
file
doesn
t
have
a
corresponding
interface
mli
file
then
compiling
it
with
ocamlcp
will
produce
object
files
cmi
and
cmo
that
are
not
compatible
with
the
ones
produced
by
ocamlc
which
may
lead
to
problems
if
the
cmi
or
cmo
is
still
around
when
switching
between
profiling
and
non
profiling
compilations
To
avoid
this
problem
you
should
always
have
a
mli
file
for
each
ml
file
The
same
problem
exists
with
ocamloptp
lparagraph
p
ocamlprof
reserved
Note
To
make
sure
your
programs
can
be
compiled
in
profiling
mode
avoid
using
any
identifier
that
begins
with
ocaml
prof
The
amount
of
profiling
information
can
be
controlled
through
the
P
option
to
ocamlcp
or
ocamloptp
followed
by
one
or
several
letters
indicating
which
parts
of
the
program
should
be
profiled
description
des
options
begin
options
item
a
all
options
item
f
function
calls
a
count
point
is
set
at
the
beginning
of
each
function
body
item
i
bf
if
ldots
then
ldots
else
ldots
count
points
are
set
in
both
bf
then
branch
and
bf
else
branch
item
l
bf
while
for
loops
a
count
point
is
set
at
the
beginning
of
the
loop
body
item
m
bf
match
branches
a
count
point
is
set
at
the
beginning
of
the
body
of
each
branch
item
t
bf
try
ldots
with
ldots
branches
a
count
point
is
set
at
the
beginning
of
the
body
of
each
branch
end
options
For
instance
compiling
with
ocamlcp
P
film
profiles
function
calls
if
ldots
then
ldots
else
ldots
loops
and
pattern
matching
Calling
ocamlcp
or
ocamloptp
without
the
P
option
defaults
to
P
fm
meaning
that
only
function
calls
and
pattern
matching
are
profiled
paragraph
Note
For
compatibility
with
previous
releases
ocamlcp
also
accepts
the
p
option
with
the
same
arguments
and
behaviour
as
P
The
ocamlcp
and
ocamloptp
commands
also
accept
all
the
options
of
the
corresponding
ocamlc
or
ocamlopt
compiler
except
the
pp
preprocessing
option
subsection
s
ocamlprof
profiling
Profiling
an
execution
Running
an
executable
that
has
been
compiled
with
ocamlcp
or
ocamloptp
records
the
execution
counts
for
the
specified
parts
of
the
program
and
saves
them
in
a
file
called
ocamlprof
dump
in
the
current
directory
If
the
environment
variable
OCAMLPROF
DUMP
is
set
when
the
program
exits
its
value
is
used
as
the
file
name
instead
of
ocamlprof
dump
The
dump
file
is
written
only
if
the
program
terminates
normally
by
calling
exit
or
by
falling
through
It
is
not
written
if
the
program
terminates
with
an
uncaught
exception
If
a
compatible
dump
file
already
exists
in
the
current
directory
then
the
profiling
information
is
accumulated
in
this
dump
file
This
allows
for
instance
the
profiling
of
several
executions
of
a
program
on
different
inputs
Note
that
dump
files
produced
by
byte
code
executables
compiled
with
ocamlcp
are
compatible
with
the
dump
files
produced
by
native
executables
compiled
with
ocamloptp
subsection
s
ocamlprof
printing
Printing
profiling
information
The
ocamlprof
command
produces
a
source
listing
of
the
program
modules
where
execution
counts
have
been
inserted
as
comments
For
instance
begin
verbatim
ocamlprof
foo
ml
end
verbatim
prints
the
source
code
for
the
foo
module
with
comments
indicating
how
many
times
the
functions
in
this
module
have
been
called
Naturally
this
information
is
accurate
only
if
the
source
file
has
not
been
modified
after
it
was
compiled
The
following
options
are
recognized
by
ocamlprof
begin
options
item
args
var
filename
Read
additional
newline
terminated
command
line
arguments
from
var
filename
item
args0
var
filename
Read
additional
null
character
terminated
command
line
arguments
from
var
filename
item
f
var
dumpfile
Specifies
an
alternate
dump
file
of
profiling
information
to
be
read
item
F
var
string
Specifies
an
additional
string
to
be
output
with
profiling
information
By
default
ocamlprof
will
annotate
programs
with
comments
of
the
form
tt
var
n
where
var
n
is
the
counter
value
for
a
profiling
point
With
option
tt
F
var
s
the
annotation
will
be
tt
var
s
var
n
item
impl
var
filename
Process
the
file
var
filename
as
an
implementation
file
even
if
its
extension
is
not
ml
item
intf
var
filename
Process
the
file
var
filename
as
an
interface
file
even
if
its
extension
is
not
mli
item
keywords
var
version
list
Set
keywords
according
to
the
var
version
list
specification
item
version
Print
version
string
and
exit
item
vnum
Print
short
version
number
and
exit
item
help
or
help
Display
a
short
usage
summary
and
exit
end
options
Profiling
with
ocamlprof
only
records
execution
counts
not
the
actual
time
spent
within
each
function
There
is
currently
no
way
to
perform
time
profiling
on
bytecode
programs
generated
by
ocamlc
section
s
ocamlprof
time
profiling
Time
profiling
with
Linux
perf
This
section
describes
how
to
use
texttt
perf
to
profile
OCaml
programs
Linux
Performance
Events
aka
texttt
perf
is
a
suite
of
tools
for
performance
observability
included
with
the
Linux
kernel
The
main
features
covered
here
are
recording
events
using
texttt
perf
record
1
and
visualising
recorded
events
using
texttt
perf
report
1
texttt
perf
has
many
additional
profiling
and
visualising
features
for
more
comprehensive
documentation
see
man
texttt
perf
1
href
https
perfwiki
github
io
main
texttt
perf
wiki
or
href
https
www
brendangregg
com
perf
html
Brendan
Gregg
s
Blog
subsection
s
ocamlprof
time
profiling
background
Background
Time
profiling
is
typically
performed
by
sampling
the
CPU
call
graph
at
frequent
intervals
to
gather
statistics
on
the
code
paths
that
are
consuming
CPU
resources
To
profile
OCaml
code
texttt
perf
needs
to
understand
the
call
graph
of
an
OCaml
program
texttt
perf
supports
multiple
options
for
recording
call
graphs
begin
itemize
item
Frame
Pointers
which
is
the
default
item
DWARF
s
Call
Frame
Information
CFI
item
Hardware
Last
Branch
Record
LBR
end
itemize
Frame
pointer
based
call
graphs
use
a
convention
where
a
register
called
the
frame
pointer
holds
the
address
for
the
beginning
of
the
stack
frame
and
the
previous
values
for
the
frame
pointer
are
stored
at
a
known
offset
from
the
current
frame
pointer
Using
this
information
the
call
graph
for
the
current
function
can
be
calculated
purely
based
on
the
current
stack
a
process
called
unwinding
On
AMD64
the
register
used
for
storing
the
frame
pointer
is
rbp
while
ARM64
uses
the
register
x29
OCaml
5
introduced
non
contiguous
stacks
as
part
of
the
implementation
of
effects
see
href
https
dl
acm
org
doi
10
1145
3453483
3454039
Retrofitting
effect
handlers
onto
OCaml
Section
5
5
Due
to
this
implementation
detail
frame
pointers
work
better
with
the
copying
nature
of
perf
DWARF
based
call
graphs
use
the
DWARF
CFI
information
to
perform
unwinding
However
this
interacts
poorly
with
the
copying
nature
of
perf
often
leading
to
truncated
call
graphs
where
not
enough
of
the
stack
has
been
copied
by
texttt
perf
It
also
produces
larger
trace
files
that
are
more
costly
to
capture
and
process
Finally
it
requires
including
CFI
debugging
information
in
your
program
resulting
in
slightly
larger
binaries
Hardware
Last
Branch
Record
LBR
uses
a
processor
provided
method
to
record
call
graphs
This
has
the
limitations
of
restricted
availability
only
on
certain
Intel
CPUs
and
a
limited
stack
depth
16
on
Haswell
and
32
since
Skylake
Of
these
options
frame
pointers
are
recommended
for
profiling
OCaml
code
It
has
the
following
advantages
begin
itemize
item
Unwinding
is
faster
to
calculate
item
Tracing
data
produced
is
smaller
item
Frame
pointers
provide
more
complete
call
graphs
particularly
when
used
with
a
Linux
distribution
that
supports
them
item
Frame
pointers
work
better
with
perf
s
copying
nature
and
OCaml
5
s
non
contiguous
stacks
end
itemize
subsection
s
ocamlprof
compiling
perf
Compiling
for
Profiling
The
process
for
compiling
an
executable
for
time
profiling
depends
on
the
OCaml
version
For
OCaml
versions
4
14
and
earlier
either
frame
pointers
or
DWARF
can
be
used
while
for
OCaml
5
0
and
later
enabling
frame
pointers
is
recommended
To
enable
frame
pointers
configure
the
compiler
with
texttt
enable
frame
pointers
Alternatively
you
can
install
an
opam
switch
with
frame
pointers
enabled
as
follows
begin
verbatim
opam
switch
create
YOUR
SWITCH
NAME
HERE
ocaml
option
fp
end
verbatim
Frame
pointer
support
for
OCaml
is
available
on
AMD64
architecture
for
Linux
starting
with
OCaml
4
12
and
on
macOS
from
OCaml
5
3
ARM64
architecture
is
supported
on
Linux
and
macOS
from
OCaml
5
4
while
other
Tier
1
architectures
POWER
RISC
V
and
s390x
are
currently
unsupported
subsection
s
ocamlprof
profiling
perf
Profiling
an
Execution
The
basic
texttt
perf
command
for
profiling
is
begin
verbatim
perf
record
F
99
call
graph
fp
PROGRAM
end
verbatim
The
texttt
F
99
option
sets
texttt
perf
to
sample
at
99Hz
reducing
excessive
data
generation
during
longer
runs
and
minimising
overlap
with
other
periodic
activities
The
texttt
call
graph
fp
instructs
texttt
perf
to
use
frame
pointers
to
get
the
call
graph
followed
by
the
OCaml
executable
you
want
to
profile
This
command
creates
a
texttt
perf
data
file
in
the
current
directory
Alternatively
use
texttt
output
to
choose
a
more
descriptive
filename
The
texttt
perf
record
command
works
by
copying
a
segment
of
the
call
stack
at
each
sample
and
recording
this
data
into
a
texttt
perf
data
file
These
samples
can
then
be
processed
after
recording
using
texttt
perf
report
to
reconstruct
the
profiled
programs
call
stack
at
every
sample
texttt
perf
uses
the
symbols
present
in
an
OCaml
executable
so
it
helps
to
understand
OCaml
s
name
mangling
scheme
to
map
names
to
OCaml
source
locations
OCaml
5
3
onwards
uses
a
mangling
scheme
of
caml
MODULE
NAME
FUNCTION
NAME
NNN
on
Linux
where
texttt
NNN
is
a
randomly
generated
number
For
macOS
and
the
Windows
MSVC
port
restored
in
OCaml
5
3
the
scheme
uses
texttt
as
the
separator
Before
OCaml
5
1
1
the
scheme
used
two
underscores
as
the
separator
e
g
caml
MODULE
NAME
FUNCTION
NAME
NNN
All
formats
are
supported
by
Linux
texttt
perf
Consider
the
following
program
begin
caml
example
verbatim
fib
ml
module
Compute
struct
let
rec
fib
n
if
n
0
then
0
else
if
n
1
then
1
else
fib
n
1
fib
n
2
end
let
main
let
r
Compute
fib
20
in
Printf
printf
fib
20
d
r
let
main
end
caml
example
This
program
produces
the
names
texttt
camlFib
main
274
for
the
texttt
main
function
and
texttt
camlFib
fib
271
for
the
texttt
fib
function
in
the
texttt
Compute
module
subsection
s
ocamlprof
printing
perf
Displaying
profiling
information
The
texttt
perf
report
command
summarises
data
in
the
texttt
perf
data
file
The
basic
texttt
perf
report
command
is
begin
verbatim
perf
report
f
no
children
i
perf
data
end
verbatim
This
command
provides
an
interactive
interface
where
you
can
navigate
through
the
accumulated
call
graphs
and
select
functions
and
threads
for
detailed
information
Alternatively
texttt
stdio
will
output
similar
data
using
a
text
based
report
written
to
stdout
Note
that
if
stack
traces
appear
broken
it
may
be
due
to
software
not
having
frame
pointer
support
enabled
Consider
the
following
program
which
calculates
the
Tak
function
begin
caml
example
verbatim
let
x
y
z
try
let
x
int
of
string
Sys
argv
1
in
let
y
int
of
string
Sys
argv
2
in
let
z
int
of
string
Sys
argv
3
in
x
y
z
with
18
12
6
let
rec
tak
x
y
z
if
x
y
then
tak
tak
x
1
y
z
tak
y
1
z
x
tak
z
1
x
y
else
z
let
main
let
r
tak
x
y
z
in
Printf
printf
tak
d
d
d
d
n
x
y
z
r
let
main
end
caml
example
The
texttt
perf
report
for
this
might
resemble
the
following
begin
verbatim
Samples
809
of
event
cycles
Event
count
approx
24701952617
Overhead
Command
Shared
Object
Symbol
100
00
tak
fp
exe
tak
fp
exe
Tak
tak
402
Tak
tak
402
Tak
tak
402
Tak
tak
402
0
00
tak
fp
exe
kernel
kallsyms
k
0xffffb9a5ff79d854
0
00
perf
exec
kernel
kallsyms
k
0xffffb9a5ff719c34
end
verbatim
For
a
more
interesting
program
implementing
a
Sudoku
solver
using
Norvig
s
Backtracking
algorithm
the
output
might
resemble
begin
verbatim
Samples
7K
of
event
cycles
P
Event
count
approx
141874642467
Overhead
Command
Shared
Object
Symbol
35
90
sudoku
norvig
e
sudoku
norvig
exe
Sudoku
norvig
pow
747
35
29
Sudoku
norvig
pow
747
17
70
Sudoku
norvig
eliminate
value
760
15
74
Sudoku
norvig
pow
747
1
03
Sudoku
norvig
fun
1435
0
61
Sudoku
norvig
eliminate
value
760
12
99
sudoku
norvig
e
sudoku
norvig
exe
BatList
findnext
1543
12
00
BatList
findnext
1543
11
71
BatList
find
all
1539
8
07
Sudoku
norvig
fun
1421
2
73
Sudoku
norvig
eliminate
948
0
90
Sudoku
norvig
assign
949
10
63
sudoku
norvig
e
sudoku
norvig
exe
Sudoku
norvig
eliminate
value
760
8
29
Sudoku
norvig
eliminate
value
760
1
93
Sudoku
norvig
pow
747
9
50
sudoku
norvig
e
kernel
kallsyms
k
asm
exc
nmi
7
24
sudoku
norvig
e
sudoku
norvig
exe
Sudoku
norvig
fun
1435
5
06
sudoku
norvig
e
sudoku
norvig
exe
caml
modify
3
10
sudoku
norvig
e
sudoku
norvig
exe
Sudoku
norvig
fun
1360
2
11
sudoku
norvig
e
sudoku
norvig
exe
Sudoku
norvig
eliminate
948
2
00
sudoku
norvig
e
sudoku
norvig
exe
Stdlib
List
iter
366
1
54
sudoku
norvig
e
sudoku
norvig
exe
Sudoku
norvig
fun
1421
1
47
sudoku
norvig
e
sudoku
norvig
exe
caml
apply2
1
42
sudoku
norvig
e
sudoku
norvig
exe
BatList
find
all
1539
1
20
sudoku
norvig
e
sudoku
norvig
exe
Sudoku
norvig
fun
1366
1
09
sudoku
norvig
e
sudoku
norvig
exe
Stdlib
List
fold
left
380
end
verbatim
Note
this
implementation
clearly
has
some
optimsation
possible
in
pow
747
a
recursive
Power
of
2
function
and
parts
of
the
OCaml
runtime
caml
modify
are
present
Profiling
data
can
also
be
visualised
as
Flame
Graphs
which
highlight
the
most
frequent
code
paths
in
stack
traces
The
original
scripts
scripts
texttt
stackcollapse
perf
pl
and
texttt
flamegraph
pl
can
be
found
at
Brendan
Gregg
s
href
https
www
brendangregg
com
flamegraphs
html
Flame
Graphs
web
page
and
work
as
follows
begin
verbatim
git
clone
https
github
com
brendangregg
FlameGraph
cd
FlameGraph
Collect
the
results
into
perf
data
perf
record
F
99
call
graph
fp
PROGRAM
perf
script
i
perf
data
stackcollapse
perf
pl
out
folded
flamegraph
pl
out
folded
flamegraph
svg
Create
the
FlameGraph
svg
end
verbatim
Alternatively
href
https
github
com
jonhoo
inferno
inferno
is
a
Rust
port
of
the
Flame
Graphs
tools
which
works
in
a
similar
way
and
is
faster
to
process
large
perf
files
begin
verbatim
cargo
install
inferno
Collect
the
results
into
perf
data
perf
script
i
perf
data
inferno
collapse
perf
stacks
folded
cat
stacks
folded
inferno
flamegraph
flamegraph
svg
end
verbatim
Some
texttt
perf
tools
e
g
texttt
perf
report
1
and
texttt
perf
annotate
1
use
DWARF
debugging
information
to
associate
symbols
with
source
code
locations
if
you
need
these
features
the
program
and
it
s
dependencies
need
to
be
compiled
with
texttt
g
to
include
debugging
information
in
the
executable
Captured
profile
data
can
also
be
processed
using
texttt
perf
script
in
various
ways
or
with
online
tools
like
href
https
www
speedscope
app
speedscope
app
and
href
https
profiler
firefox
com
profiler
firefox
com
or
any
other
tool
that
supports
texttt
perf
formatted
data
subsection
s
ocamlperf
conclusion
Conclusion
For
Time
profiling
of
native
code
standard
tools
such
as
texttt
perf
eBPF
DTrace
or
Instruments
on
macOS
are
recommended
Compiling
with
frame
pointers
enabled
is
often
necessary
for
these
tools
to
work
effectively
Profiling
with
texttt
gprof
is
no
longer
supported
Enabling
frame
pointers
can
impact
performance
on
certain
architectures
up
to
10
performance
cost
on
x86
64
has
been
measured
Users
of
this
feature
are
encouraged
to
benchmark
their
own
applications
to
assess
this
impact
section
s
ocamlprof
instruments
Time
profiling
with
macOS
Instruments
Instruments
is
an
application
performance
analyzer
and
visualizer
provided
in
XCode
on
macOS
It
includes
a
CLI
tool
xctrace
that
can
capture
Time
Profiling
information
about
OCaml
programs
there
is
also
a
GUI
application
for
running
and
visualising
profiles
Here
we
only
cover
capturing
time
profiles
with
xctrace
for
more
information
on
Instruments
consult
Apple
s
documentation
The
same
prerequisites
hold
for
Time
profiling
with
macOS
Instruments
as
for
Linux
perf
consult
Background
ref
s
ocamlprof
time
profiling
background
from
the
previous
section
for
an
explanation
of
call
graphs
and
follow
the
setup
from
Compiling
for
Profiling
ref
s
ocamlprof
compiling
perf
The
basic
texttt
xctrace
command
for
time
profiling
is
begin
verbatim
xcrun
xctrace
record
output
template
Time
Profiler
target
stdout
launch
PROGRAM
end
verbatim
The
texttt
template
Time
Profiler
selects
pre
defined
template
for
time
profiling
which
will
create
a
trace
file
with
extension
trace
that
can
be
opened
with
Instruments
Use
the
texttt
output
to
select
a
name
for
the
trace
file
by
default
xctrace
will
create
a
new
file
each
run
rather
than
overwriting
the
existing
file
The
resulting
file
can
be
opened
with
Instruments
to
view
the
profile
and
it
maybe
be
possible
to
generate
Flame
Graphs
using
href
https
github
com
jonhoo
inferno
inferno
or
the
scripts
from
href
https
github
com
brendangregg
FlameGraph
https
github
com
brendangregg
FlameGraph
lparagraph
p
ocamlprof
instruments
Note
Sometimes
Instruments
requires
adding
entitlements
to
an
OCaml
binary
before
it
is
able
to
profile
it
This
typically
shows
as
a
failure
to
launch
the
process
or
as
a
permission
error
To
work
around
this
issue
run
the
following
command
replacing
PROGRAM
with
the
program
to
trace
begin
verbatim
codesign
s
v
f
entitlements
echo
n
xml
version
1
0
encoding
UTF
8
DOCTYPE
plist
PUBLIC
Apple
DTD
PLIST
1
0
EN
https
www
apple
com
DTDs
PropertyList
1
0
dtd
plist
version
1
0
dict
key
com
apple
security
get
task
allow
key
true
dict
plist
PROGRAM
end
verbatim
For
more
details
on
entitlements
and
codesign
consult
Apple
s
documentation
section
s
ocamlprof
glossary
Glossary
The
following
terminology
is
used
in
this
chapter
of
the
manual
begin
itemize
item
bf
Call
graph
The
chain
of
function
calls
that
have
lead
to
the
current
function
also
referred
to
as
a
call
stack
item
bf
Unwinding
The
process
of
walking
up
the
call
stack
also
called
stack
unwinding
item
bf
Stack
frame
Refers
to
the
portion
of
the
stack
allocated
to
a
single
function
call
also
called
an
activation
frame
activation
record
or
simply
frame
end
itemize
chapter
The
documentation
generator
ocamldoc
label
c
ocamldoc
HEVEA
cutname
ocamldoc
html
This
chapter
describes
OCamldoc
a
tool
that
generates
documentation
from
special
comments
embedded
in
source
files
The
comments
used
by
OCamldoc
are
of
the
form
ldots
and
follow
the
format
described
in
section
ref
s
ocamldoc
comments
OCamldoc
can
produce
documentation
in
various
formats
HTML
LaTeX
TeXinfo
Unix
man
pages
and
dot
dependency
graphs
Moreover
users
can
add
their
own
custom
generators
as
explained
in
section
ref
s
ocamldoc
custom
generators
In
this
chapter
we
use
the
word
em
element
to
refer
to
any
of
the
following
parts
of
an
OCaml
source
file
a
type
declaration
a
value
a
module
an
exception
a
module
type
a
type
constructor
a
record
field
a
class
a
class
type
a
class
method
a
class
value
or
a
class
inheritance
clause
section
s
ocamldoc
usage
Usage
subsection
ss
ocamldoc
invocation
Invocation
OCamldoc
is
invoked
via
the
command
ocamldoc
as
follows
begin
alltt
ocamldoc
var
options
var
sourcefiles
end
alltt
subsubsection
sss
ocamldoc
output
Options
for
choosing
the
output
format
The
following
options
determine
the
format
for
the
generated
documentation
begin
options
item
html
Generate
documentation
in
HTML
default
format
The
generated
HTML
pages
are
stored
in
the
current
directory
or
in
the
directory
specified
with
the
bf
tt
d
option
You
can
customize
the
style
of
the
generated
pages
by
editing
the
generated
style
css
file
or
by
providing
your
own
style
sheet
using
option
css
style
The
file
style
css
is
not
generated
if
it
already
exists
or
if
css
style
is
used
item
latex
Generate
documentation
in
LaTeX
default
format
The
generated
LaTeX
document
is
saved
in
file
ocamldoc
out
or
in
the
file
specified
with
the
bf
tt
o
option
The
document
uses
the
style
file
ocamldoc
sty
This
file
is
generated
when
using
the
latex
option
if
it
does
not
already
exist
You
can
change
this
file
to
customize
the
style
of
your
LaTeX
documentation
item
texi
Generate
documentation
in
TeXinfo
default
format
The
generated
LaTeX
document
is
saved
in
file
ocamldoc
out
or
in
the
file
specified
with
the
bf
tt
o
option
item
man
Generate
documentation
as
a
set
of
Unix
man
pages
The
generated
pages
are
stored
in
the
current
directory
or
in
the
directory
specified
with
the
bf
tt
d
option
item
dot
Generate
a
dependency
graph
for
the
toplevel
modules
in
a
format
suitable
for
displaying
and
processing
by
dot
The
dot
tool
is
available
from
url
https
graphviz
org
The
textual
representation
of
the
graph
is
written
to
the
file
ocamldoc
out
or
to
the
file
specified
with
the
bf
tt
o
option
Use
dot
ocamldoc
out
to
display
it
item
g
var
file
cm
o
a
xs
Dynamically
load
the
given
file
which
defines
a
custom
documentation
generator
See
section
ref
ss
ocamldoc
compilation
and
usage
This
option
is
supported
by
the
ocamldoc
command
to
load
cmo
and
cma
files
and
by
its
native
code
version
ocamldoc
opt
to
load
cmxs
files
If
the
given
file
is
a
simple
one
and
does
not
exist
in
the
current
directory
then
ocamldoc
looks
for
it
in
the
custom
generators
default
directory
and
in
the
directories
specified
with
optional
i
options
item
customdir
Display
the
custom
generators
default
directory
item
i
var
directory
Add
the
given
directory
to
the
path
where
to
look
for
custom
generators
end
options
subsubsection
sss
ocamldoc
options
General
options
begin
options
item
d
var
dir
Generate
files
in
directory
var
dir
rather
than
the
current
directory
item
dump
var
file
Dump
collected
information
into
var
file
This
information
can
be
read
with
the
load
option
in
a
subsequent
invocation
of
ocamldoc
item
hide
var
modules
Hide
the
given
complete
module
names
in
the
generated
documentation
var
modules
is
a
list
of
complete
module
names
separated
by
without
blanks
For
instance
Stdlib
M2
M3
item
inv
merge
ml
mli
Reverse
the
precedence
of
implementations
and
interfaces
when
merging
All
elements
in
implementation
files
are
kept
and
the
bf
tt
m
option
indicates
which
parts
of
the
comments
in
interface
files
are
merged
with
the
comments
in
implementation
files
item
keep
code
Always
keep
the
source
code
for
values
methods
and
instance
variables
when
available
item
load
var
file
Load
information
from
var
file
which
has
been
produced
by
ocamldoc
dump
Several
load
options
can
be
given
item
m
var
flags
Specify
merge
options
between
interfaces
and
implementations
see
section
ref
ss
ocamldoc
merge
for
details
var
flags
can
be
one
or
several
of
the
following
characters
begin
options
item
d
merge
description
item
a
merge
author
item
v
merge
version
item
l
merge
see
item
s
merge
since
item
b
merge
before
item
o
merge
deprecated
item
p
merge
param
item
e
merge
raise
item
r
merge
return
item
A
merge
everything
end
options
item
no
custom
tags
Do
not
allow
custom
tags
see
section
ref
ss
ocamldoc
tags
item
no
stop
Keep
elements
placed
after
between
the
special
comment
s
see
section
ref
s
ocamldoc
comments
item
o
var
file
Output
the
generated
documentation
to
var
file
instead
of
ocamldoc
out
This
option
is
meaningful
only
in
conjunction
with
the
bf
tt
latex
bf
tt
texi
or
bf
tt
dot
options
item
pp
var
command
Pipe
sources
through
preprocessor
var
command
item
impl
var
filename
Process
the
file
var
filename
as
an
implementation
file
even
if
its
extension
is
not
ml
item
intf
var
filename
Process
the
file
var
filename
as
an
interface
file
even
if
its
extension
is
not
mli
item
text
var
filename
Process
the
file
var
filename
as
a
text
file
even
if
its
extension
is
not
txt
item
sort
Sort
the
list
of
top
level
modules
before
generating
the
documentation
item
stars
Remove
blank
characters
until
the
first
asterisk
in
each
line
of
comments
item
t
var
title
Use
var
title
as
the
title
for
the
generated
documentation
item
intro
var
file
Use
content
of
var
file
as
ocamldoc
text
to
use
as
introduction
HTML
LaTeX
and
TeXinfo
only
For
HTML
the
file
is
used
to
create
the
whole
index
html
file
item
v
Verbose
mode
Display
progress
information
item
version
Print
version
string
and
exit
item
vnum
Print
short
version
number
and
exit
item
warn
error
Treat
Ocamldoc
warnings
as
errors
item
hide
warnings
Do
not
print
OCamldoc
warnings
item
help
or
help
Display
a
short
usage
summary
and
exit
end
options
subsubsection
sss
ocamldoc
type
checking
Type
checking
options
OCamldoc
calls
the
OCaml
type
checker
to
obtain
type
information
The
following
options
impact
the
type
checking
phase
They
have
the
same
meaning
as
for
the
ocamlc
and
ocamlopt
commands
begin
options
item
I
var
directory
Add
var
directory
to
the
list
of
directories
search
for
compiled
interface
files
cmi
files
item
H
var
directory
Like
I
but
the
H
directories
are
searched
last
and
the
program
may
not
directly
refer
to
the
modules
added
to
the
search
path
this
way
item
nolabels
Ignore
non
optional
labels
in
types
item
rectypes
Allow
arbitrary
recursive
types
See
the
rectypes
option
to
ocamlc
end
options
subsubsection
sss
ocamldoc
html
Options
for
generating
HTML
pages
The
following
options
apply
in
conjunction
with
the
html
option
begin
options
item
all
params
Display
the
complete
list
of
parameters
for
functions
and
methods
item
charset
var
charset
Add
information
about
character
encoding
being
var
charset
default
is
iso
8859
1
item
colorize
code
Colorize
the
OCaml
code
enclosed
in
and
using
colors
to
emphasize
keywords
etc
If
the
code
fragments
are
not
syntactically
correct
no
color
is
added
item
css
style
var
filename
Use
var
filename
as
the
Cascading
Style
Sheet
file
item
index
only
Generate
only
index
files
item
short
functors
Use
a
short
form
to
display
functors
begin
alltt
module
M
functor
A
Module
functor
B
Module2
sig
end
end
alltt
is
displayed
as
begin
alltt
module
M
A
Module
B
Module2
sig
end
end
alltt
end
options
subsubsection
sss
ocamldoc
latex
Options
for
generating
LaTeX
files
The
following
options
apply
in
conjunction
with
the
latex
option
begin
options
item
latex
value
prefix
var
prefix
Give
a
prefix
to
use
for
the
labels
of
the
values
in
the
generated
LaTeX
document
The
default
prefix
is
the
empty
string
You
can
also
use
the
options
tt
latex
type
prefix
tt
latex
exception
prefix
tt
latex
module
prefix
tt
latex
module
type
prefix
tt
latex
class
prefix
tt
latex
class
type
prefix
tt
latex
attribute
prefix
and
tt
latex
method
prefix
These
options
are
useful
when
you
have
for
example
a
type
and
a
value
with
the
same
name
If
you
do
not
specify
prefixes
LaTeX
will
complain
about
multiply
defined
labels
item
latextitle
var
n
style
Associate
style
number
var
n
to
the
given
LaTeX
sectioning
command
var
style
e
g
section
or
subsection
LaTeX
only
This
is
useful
when
including
the
generated
document
in
another
LaTeX
document
at
a
given
sectioning
level
The
default
association
is
1
for
section
2
for
subsection
3
for
subsubsection
4
for
paragraph
and
5
for
subparagraph
item
noheader
Suppress
header
in
generated
documentation
item
notoc
Do
not
generate
a
table
of
contents
item
notrailer
Suppress
trailer
in
generated
documentation
item
sepfiles
Generate
one
tex
file
per
toplevel
module
instead
of
the
global
ocamldoc
out
file
end
options
subsubsection
sss
ocamldoc
info
Options
for
generating
TeXinfo
files
The
following
options
apply
in
conjunction
with
the
texi
option
begin
options
item
esc8
Escape
accented
characters
in
Info
files
item
info
entry
Specify
Info
directory
entry
item
info
section
Specify
section
of
Info
directory
item
noheader
Suppress
header
in
generated
documentation
item
noindex
Do
not
build
index
for
Info
files
item
notrailer
Suppress
trailer
in
generated
documentation
end
options
subsubsection
sss
ocamldoc
dot
Options
for
generating
dot
graphs
The
following
options
apply
in
conjunction
with
the
dot
option
begin
options
item
dot
colors
var
colors
Specify
the
colors
to
use
in
the
generated
dot
code
When
generating
module
dependencies
ocamldoc
uses
different
colors
for
modules
depending
on
the
directories
in
which
they
reside
When
generating
types
dependencies
ocamldoc
uses
different
colors
for
types
depending
on
the
modules
in
which
they
are
defined
var
colors
is
a
list
of
color
names
separated
by
as
in
Red
Blue
Green
The
available
colors
are
the
ones
supported
by
the
dot
tool
item
dot
include
all
Include
all
modules
in
the
dot
output
not
only
modules
given
on
the
command
line
or
loaded
with
the
bf
tt
load
option
item
dot
reduce
Perform
a
transitive
reduction
of
the
dependency
graph
before
outputting
the
dot
code
This
can
be
useful
if
there
are
a
lot
of
transitive
dependencies
that
clutter
the
graph
item
dot
types
Output
dot
code
describing
the
type
dependency
graph
instead
of
the
module
dependency
graph
end
options
subsubsection
sss
ocamldoc
man
Options
for
generating
man
files
The
following
options
apply
in
conjunction
with
the
man
option
begin
options
item
man
mini
Generate
man
pages
only
for
modules
module
types
classes
and
class
types
instead
of
pages
for
all
elements
item
man
suffix
var
suffix
Set
the
suffix
used
for
generated
man
filenames
Default
is
3o
as
in
List
3o
item
man
section
var
section
Set
the
section
number
used
for
generated
man
filenames
Default
is
3
end
options
subsection
ss
ocamldoc
merge
Merging
of
module
information
Information
on
a
module
can
be
extracted
either
from
the
mli
or
ml
file
or
both
depending
on
the
files
given
on
the
command
line
When
both
mli
and
ml
files
are
given
for
the
same
module
information
extracted
from
these
files
is
merged
according
to
the
following
rules
begin
itemize
item
Only
elements
values
types
classes
declared
in
the
mli
file
are
kept
In
other
terms
definitions
from
the
ml
file
that
are
not
exported
in
the
mli
file
are
not
documented
item
Descriptions
of
elements
and
descriptions
in
tags
are
handled
as
follows
If
a
description
for
the
same
element
or
in
the
same
tag
of
the
same
element
is
present
in
both
files
then
the
description
of
the
ml
file
is
concatenated
to
the
one
in
the
mli
file
if
the
corresponding
m
flag
is
given
on
the
command
line
If
a
description
is
present
in
the
ml
file
and
not
in
the
mli
file
the
ml
description
is
kept
In
either
case
all
the
information
given
in
the
mli
file
is
kept
end
itemize
subsection
ss
ocamldoc
rules
Coding
rules
The
following
rules
must
be
respected
in
order
to
avoid
name
clashes
resulting
in
cross
reference
errors
begin
itemize
item
In
a
module
there
must
not
be
two
modules
two
module
types
or
a
module
and
a
module
type
with
the
same
name
In
the
default
HTML
generator
modules
ab
and
AB
will
be
printed
to
the
same
file
on
case
insensitive
file
systems
item
In
a
module
there
must
not
be
two
classes
two
class
types
or
a
class
and
a
class
type
with
the
same
name
item
In
a
module
there
must
not
be
two
values
two
types
or
two
exceptions
with
the
same
name
item
Values
defined
in
tuple
as
in
let
x
y
z
1
2
3
are
not
kept
by
OCamldoc
item
Avoid
the
following
construction
begin
caml
eval
module
Foo
struct
module
Bar
struct
let
x
1
end
end
end
caml
eval
begin
caml
example
verbatim
open
Foo
which
has
a
module
Bar
with
a
value
x
module
Foo
struct
module
Bar
struct
let
x
1
end
end
let
dummy
Bar
x
end
caml
example
In
this
case
OCamldoc
will
associate
Bar
x
to
the
x
of
module
Foo
defined
just
above
instead
of
to
the
Bar
x
defined
in
the
opened
module
Foo
end
itemize
section
s
ocamldoc
comments
Syntax
of
documentation
comments
Comments
containing
documentation
material
are
called
em
special
comments
and
are
written
between
and
Special
comments
must
start
exactly
with
Comments
beginning
with
and
more
than
two
are
ignored
subsection
ss
ocamldoc
placement
Placement
of
documentation
comments
OCamldoc
can
associate
comments
to
some
elements
of
the
language
encountered
in
the
source
files
The
association
is
made
according
to
the
locations
of
comments
with
respect
to
the
language
elements
The
locations
of
comments
in
mli
and
ml
files
are
different
subsubsection
sss
ocamldoc
mli
Comments
in
mli
files
A
special
comment
is
associated
to
an
element
if
it
is
placed
before
or
after
the
element
A
special
comment
before
an
element
is
associated
to
this
element
if
begin
itemize
item
There
is
no
blank
line
or
another
special
comment
between
the
special
comment
and
the
element
However
a
regular
comment
can
occur
between
the
special
comment
and
the
element
item
The
special
comment
is
not
already
associated
to
the
previous
element
item
The
special
comment
is
not
the
first
one
of
a
toplevel
module
end
itemize
A
special
comment
after
an
element
is
associated
to
this
element
if
there
is
no
blank
line
or
comment
between
the
special
comment
and
the
element
There
are
two
exceptions
for
constructors
and
record
fields
in
type
definitions
the
associated
comment
can
only
be
placed
after
the
constructor
or
field
definition
without
blank
lines
or
other
comments
between
them
The
special
comment
for
a
constructor
with
another
constructor
following
must
be
placed
before
the
character
separating
the
two
constructors
The
following
sample
interface
file
foo
mli
illustrates
the
placement
rules
for
comments
in
mli
files
begin
caml
eval
class
cl
object
end
end
caml
eval
begin
caml
example
signature
The
first
special
comment
of
the
file
is
the
comment
associated
with
the
whole
module
Special
comments
can
be
placed
between
elements
and
are
kept
by
the
OCamldoc
tool
but
are
not
associated
to
any
element
tags
in
these
comments
are
ignored
Comments
like
the
one
above
with
more
than
two
asterisks
are
ignored
The
comment
for
function
f
val
f
int
int
int
The
continuation
of
the
comment
for
function
f
Comment
for
exception
My
exception
even
with
a
simple
comment
between
the
special
comment
and
the
exception
Hello
I
m
a
simple
comment
exception
My
exception
of
int
int
int
Comment
for
type
weather
type
weather
Rain
of
int
The
comment
for
constructor
Rain
Sun
The
comment
for
constructor
Sun
Comment
for
type
weather2
type
weather2
Rain
of
int
The
comment
for
constructor
Rain
Sun
The
comment
for
constructor
Sun
I
can
continue
the
comment
for
type
weather2
here
because
there
is
already
a
comment
associated
to
the
last
constructor
The
comment
for
type
my
record
type
my
record
foo
int
Comment
for
field
foo
bar
string
Comment
for
field
bar
Continuation
of
comment
for
type
my
record
Comment
for
foo
val
foo
string
This
comment
is
associated
to
foo
and
not
to
bar
val
bar
string
This
comment
is
associated
to
bar
The
comment
for
class
my
class
class
my
class
object
A
comment
to
describe
inheritance
from
cl
inherit
cl
The
comment
for
attribute
tutu
val
mutable
tutu
string
The
comment
for
attribute
toto
val
toto
int
This
comment
is
not
attached
to
titi
since
there
is
a
blank
line
before
titi
but
is
kept
as
a
comment
in
the
class
val
titi
string
Comment
for
method
toto
method
toto
string
Comment
for
method
m
method
m
float
int
end
The
comment
for
the
class
type
my
class
type
class
type
my
class
type
object
The
comment
for
variable
x
val
mutable
x
int
The
comment
for
method
m
method
m
int
int
end
The
comment
for
module
Foo
module
Foo
sig
The
comment
for
x
val
x
int
A
special
comment
that
is
kept
but
not
associated
to
any
element
end
The
comment
for
module
type
my
module
type
module
type
my
module
type
sig
The
comment
for
value
x
val
x
int
The
comment
for
module
M
module
M
sig
The
comment
for
value
y
val
y
int
end
end
end
caml
example
subsubsection
sss
ocamldoc
comments
ml
Comments
in
tt
ml
files
A
special
comment
is
associated
to
an
element
if
it
is
placed
before
the
element
and
there
is
no
blank
line
between
the
comment
and
the
element
Meanwhile
there
can
be
a
simple
comment
between
the
special
comment
and
the
element
There
are
two
exceptions
for
constructors
and
record
fields
in
type
definitions
whose
associated
comment
must
be
placed
after
the
constructor
or
field
definition
without
blank
line
between
them
The
special
comment
for
a
constructor
with
another
constructor
following
must
be
placed
before
the
character
separating
the
two
constructors
The
following
example
of
file
toto
ml
shows
where
to
place
comments
in
a
ml
file
begin
caml
example
verbatim
The
first
special
comment
of
the
file
is
the
comment
associated
to
the
whole
module
The
comment
for
function
f
let
f
x
y
x
y
This
comment
is
not
attached
to
any
element
since
there
is
another
special
comment
just
before
the
next
element
Comment
for
exception
My
exception
even
with
a
simple
comment
between
the
special
comment
and
the
exception
A
simple
comment
exception
My
exception
of
int
int
int
Comment
for
type
weather
type
weather
Rain
of
int
The
comment
for
constructor
Rain
Sun
The
comment
for
constructor
Sun
The
comment
for
type
my
record
type
my
record
foo
int
Comment
for
field
foo
bar
string
Comment
for
field
bar
The
comment
for
class
my
class
class
my
class
object
A
comment
to
describe
inheritance
from
cl
inherit
cl
The
comment
for
the
instance
variable
tutu
val
mutable
tutu
tutu
The
comment
for
toto
val
toto
1
val
titi
titi
Comment
for
method
toto
method
toto
tutu
Comment
for
method
m
method
m
f
float
1
end
The
comment
for
class
type
my
class
type
class
type
my
class
type
object
The
comment
for
the
instance
variable
x
val
mutable
x
int
The
comment
for
method
m
method
m
int
int
end
The
comment
for
module
Foo
module
Foo
struct
The
comment
for
x
let
x
0
A
special
comment
in
the
class
but
not
associated
to
any
element
end
The
comment
for
module
type
my
module
type
module
type
my
module
type
sig
Comment
for
value
x
val
x
int
end
end
caml
example
subsection
ss
ocamldoc
stop
The
Stop
special
comment
The
special
comment
tells
OCamldoc
to
discard
elements
placed
after
this
comment
up
to
the
end
of
the
current
class
class
type
module
or
module
type
or
up
to
the
next
stop
comment
For
instance
begin
caml
example
signature
class
type
foo
object
comment
for
method
m
method
m
string
This
method
won
t
appear
in
the
documentation
method
bar
int
end
This
value
appears
in
the
documentation
since
the
Stop
special
comment
in
the
class
does
not
affect
the
parent
module
of
the
class
val
foo
string
The
value
bar
does
not
appear
in
the
documentation
val
bar
string
The
type
t
appears
since
in
the
documentation
since
the
previous
stop
comment
toggled
off
the
no
documentation
mode
type
t
string
end
caml
example
The
bf
tt
no
stop
option
to
ocamldoc
causes
the
Stop
special
comments
to
be
ignored
subsection
ss
ocamldoc
syntax
Syntax
of
documentation
comments
The
inside
of
documentation
comments
ldots
consists
of
free
form
text
with
optional
formatting
annotations
followed
by
optional
em
tags
giving
more
specific
information
about
parameters
version
authors
ldots
The
tags
are
distinguished
by
a
leading
character
Thus
a
documentation
comment
has
the
following
shape
begin
verbatim
The
comment
begins
with
a
description
which
is
text
formatted
according
to
the
rules
described
in
the
next
section
The
description
continues
until
the
first
non
escaped
character
author
Mr
Smith
param
x
description
for
parameter
x
end
verbatim
Some
elements
support
only
a
subset
of
all
tags
Tags
that
are
not
relevant
to
the
documented
element
are
simply
ignored
For
instance
all
tags
are
ignored
when
documenting
type
constructors
record
fields
and
class
inheritance
clauses
Similarly
a
param
tag
on
a
class
instance
variable
is
ignored
At
last
is
the
empty
documentation
comment
enable
section
numbering
for
subsubsections
PR
6189
item
3
setcounter
secnumdepth
3
subsection
ss
ocamldoc
formatting
Text
formatting
Here
is
the
BNF
grammar
for
the
simple
markup
language
used
to
format
text
descriptions
newpage
begin
syntax
text
text
element
end
syntax
begin
syntax
inline
text
inline
text
element
end
syntax
noindent
begin
syntaxleft
nonterm
text
element
is
end
syntaxleft
begin
tabular
rlp
10cm
inline
text
element
nt
blank
line
force
a
new
line
end
tabular
noindent
begin
syntaxleft
nonterm
inline
text
element
is
end
syntaxleft
begin
tabular
rlp
10cm
0
ldots
9
inline
text
format
text
as
a
section
header
the
integer
following
indicates
the
sectioning
level
0
ldots
9
nt
label
inline
text
same
but
also
associate
the
name
nt
label
to
the
current
point
This
point
can
be
referenced
by
its
fully
qualified
label
in
a
command
just
like
any
other
element
b
inline
text
set
text
in
bold
i
inline
text
set
text
in
italic
e
inline
text
emphasize
text
C
inline
text
center
text
L
inline
text
left
align
text
R
inline
text
right
align
text
ul
list
build
a
list
ol
list
build
an
enumerated
list
string
inline
text
put
a
link
to
the
given
address
given
as
string
on
the
given
text
string
set
the
given
string
in
source
code
style
string
set
the
given
string
in
preformatted
source
code
style
v
string
v
set
the
given
string
in
verbatim
style
string
target
specific
content
LaTeX
code
by
default
see
details
in
ref
sss
ocamldoc
target
specific
syntax
string
insert
a
cross
reference
to
an
element
see
section
ref
sss
ocamldoc
crossref
for
the
syntax
of
cross
references
string
inline
text
insert
a
cross
reference
with
the
given
text
modules
string
string
insert
an
index
table
for
the
given
module
names
Used
in
HTML
only
indexlist
insert
a
table
of
links
to
the
various
indexes
types
values
modules
Used
in
HTML
only
inline
text
set
text
in
superscript
inline
text
set
text
in
subscript
nt
escaped
string
typeset
the
given
string
as
is
special
characters
and
must
be
escaped
by
a
end
tabular
subsubsection
sss
ocamldoc
list
List
formatting
begin
syntax
list
inline
text
li
inline
text
end
syntax
A
shortcut
syntax
exists
for
lists
and
enumerated
lists
begin
verbatim
Here
is
a
b
list
item
1
item
2
item
3
The
list
is
ended
by
the
blank
line
end
verbatim
is
equivalent
to
begin
verbatim
Here
is
a
b
list
ul
item
1
item
2
item
3
The
list
is
ended
by
the
blank
line
end
verbatim
The
same
shortcut
is
available
for
enumerated
lists
using
instead
of
Note
that
only
one
list
can
be
defined
by
this
shortcut
in
nested
lists
subsubsection
sss
ocamldoc
crossref
Cross
reference
formatting
Cross
references
are
fully
qualified
element
names
as
in
the
example
Foo
Bar
t
This
is
an
ambiguous
reference
as
it
may
designate
a
type
name
a
value
name
a
class
name
etc
It
is
possible
to
make
explicit
the
intended
syntactic
class
using
type
Foo
Bar
t
to
designate
a
type
and
val
Foo
Bar
t
a
value
of
the
same
name
The
list
of
possible
syntactic
class
is
as
follows
begin
center
begin
tabular
rl
multicolumn
1
c
tag
multicolumn
1
c
syntactic
class
hline
module
module
modtype
module
type
class
class
classtype
class
type
val
value
type
type
exception
exception
attribute
attribute
method
class
method
section
ocamldoc
section
const
variant
constructor
recfield
record
field
end
tabular
end
center
In
the
case
of
variant
constructors
or
record
fields
the
constructor
or
field
name
should
be
preceded
by
the
name
of
the
corresponding
type
to
avoid
the
ambiguity
of
several
types
having
the
same
constructor
names
For
example
the
constructor
Node
of
the
type
tree
will
be
referenced
as
tree
Node
or
const
tree
Node
or
possibly
Mod1
Mod2
tree
Node
from
outside
the
module
subsubsection
sss
ocamldoc
preamble
First
sentence
In
the
description
of
a
value
type
exception
module
module
type
class
or
class
type
the
em
first
sentence
is
sometimes
used
in
indexes
or
when
just
a
part
of
the
description
is
needed
The
first
sentence
is
composed
of
the
first
characters
of
the
description
until
begin
itemize
item
the
first
dot
followed
by
a
blank
or
item
the
first
blank
line
end
itemize
outside
of
the
following
text
formatting
ul
list
ol
list
string
string
v
string
v
string
string
text
text
subsubsection
sss
ocamldoc
target
specific
syntax
Target
specific
formatting
The
content
inside
foo
is
target
specific
and
will
be
interpreted
only
by
the
backend
foo
and
ignored
by
other
backends
The
backends
of
the
distribution
are
latex
html
texi
and
man
If
no
target
is
specified
syntax
latex
is
chosen
by
default
Custom
generators
may
support
their
own
target
prefix
subsubsection
sss
ocamldoc
html
tags
Recognized
HTML
tags
The
HTML
tags
b
b
code
code
i
i
ul
ul
ol
ol
li
li
center
center
and
h
0
9
h
0
9
can
be
used
instead
of
respectively
b
i
ul
ol
li
C
and
0
9
disable
section
numbering
for
subsubsections
setcounter
secnumdepth
2
subsection
ss
ocamldoc
tags
Documentation
tags
tags
subsubsection
sss
ocamldoc
builtin
tags
Predefined
tags
The
following
table
gives
the
list
of
predefined
tags
with
their
syntax
and
meaning
begin
tabular
p
5cm
p
10cm
hline
author
string
The
author
of
the
element
One
author
per
author
tag
There
may
be
several
author
tags
for
the
same
element
hline
deprecated
text
The
text
should
describe
when
the
element
was
deprecated
what
to
use
as
a
replacement
and
possibly
the
reason
for
deprecation
hline
param
id
text
Associate
the
given
description
text
to
the
given
parameter
name
id
This
tag
is
used
for
functions
methods
classes
and
functors
hline
raise
Exc
text
Explain
that
the
element
may
raise
the
exception
Exc
hline
return
text
Describe
the
return
value
and
its
possible
values
This
tag
is
used
for
functions
and
methods
hline
see
URL
text
Add
a
reference
to
the
URL
with
the
given
text
as
comment
hline
see
nt
filename
text
Add
a
reference
to
the
given
file
name
written
between
single
quotes
with
the
given
text
as
comment
hline
see
nt
document
name
text
Add
a
reference
to
the
given
document
name
written
between
double
quotes
with
the
given
text
as
comment
hline
since
string
Indicate
when
the
element
was
introduced
hline
before
nt
version
text
Associate
the
given
description
text
to
the
given
nt
version
in
order
to
document
compatibility
issues
hline
version
string
The
version
number
for
the
element
hline
end
tabular
subsubsection
sss
ocamldoc
custom
tags
Custom
tags
You
can
use
custom
tags
in
the
documentation
comments
but
they
will
have
no
effect
if
the
generator
used
does
not
handle
them
To
use
a
custom
tag
for
example
foo
just
put
foo
with
some
text
in
your
comment
as
in
begin
verbatim
My
comment
to
show
you
a
custom
tag
foo
this
is
the
text
argument
to
the
foo
custom
tag
end
verbatim
To
handle
custom
tags
you
need
to
define
a
custom
generator
as
explained
in
section
ref
ss
ocamldoc
handling
custom
tags
section
s
ocamldoc
custom
generators
Custom
generators
OCamldoc
operates
in
two
steps
begin
enumerate
item
analysis
of
the
source
files
item
generation
of
documentation
through
a
documentation
generator
which
is
an
object
of
class
Odoc
args
class
generator
end
enumerate
Users
can
provide
their
own
documentation
generator
to
be
used
during
step
2
instead
of
the
default
generators
All
the
information
retrieved
during
the
analysis
step
is
available
through
the
Odoc
info
module
which
gives
access
to
all
the
types
and
functions
representing
the
elements
found
in
the
given
modules
with
their
associated
description
The
files
you
can
use
to
define
custom
generators
are
installed
in
the
ocamldoc
sub
directory
of
the
OCaml
standard
library
subsection
ss
ocamldoc
generators
The
generator
modules
The
type
of
a
generator
module
depends
on
the
kind
of
generated
documentation
Here
is
the
list
of
generator
module
types
with
the
name
of
the
generator
class
in
the
module
begin
itemize
item
for
HTML
Odoc
html
Html
generator
class
html
item
for
LaTeX
Odoc
latex
Latex
generator
class
latex
item
for
TeXinfo
Odoc
texi
Texi
generator
class
texi
item
for
man
pages
Odoc
man
Man
generator
class
man
item
for
graphviz
dot
Odoc
dot
Dot
generator
class
dot
item
for
other
kinds
Odoc
gen
Base
class
generator
end
itemize
That
is
to
define
a
new
generator
one
must
implement
a
module
with
the
expected
signature
and
with
the
given
generator
class
providing
the
generate
method
as
entry
point
to
make
the
generator
generates
documentation
for
a
given
list
of
modules
begin
verbatim
method
generate
Odoc
info
Module
t
module
list
unit
end
verbatim
noindent
This
method
will
be
called
with
the
list
of
analysed
and
possibly
merged
Odoc
info
t
module
structures
It
is
recommended
to
inherit
from
the
current
generator
of
the
same
kind
as
the
one
you
want
to
define
Doing
so
it
is
possible
to
load
various
custom
generators
to
combine
improvements
brought
by
each
one
This
is
done
using
first
class
modules
see
chapter
ref
s
first
class
modules
The
easiest
way
to
define
a
custom
generator
is
the
following
this
example
here
extending
the
current
HTML
generator
We
don
t
have
to
know
if
this
is
the
original
HTML
generator
defined
in
ocamldoc
or
if
it
has
been
extended
already
by
a
previously
loaded
custom
generator
begin
verbatim
module
Generator
G
Odoc
html
Html
generator
struct
class
html
object
self
inherit
G
html
as
html
method
generate
module
list
end
end
let
Odoc
args
extend
html
generator
module
Generator
Odoc
gen
Html
functor
end
verbatim
To
know
which
methods
to
override
and
or
which
methods
are
available
have
a
look
at
the
different
base
implementations
depending
on
the
kind
of
generator
you
are
extending
newcommand
ocamldocsrc
2
href
https
github
com
ocaml
ocaml
blob
ocamlversion
ocamldoc
odoc
1
ml
2
begin
itemize
item
for
HTML
ocamldocsrc
html
odoc
html
ml
item
for
LaTeX
ocamldocsrc
latex
odoc
latex
ml
item
for
TeXinfo
ocamldocsrc
texi
odoc
texi
ml
item
for
man
pages
ocamldocsrc
man
odoc
man
ml
item
for
graphviz
dot
ocamldocsrc
dot
odoc
dot
ml
end
itemize
subsection
ss
ocamldoc
handling
custom
tags
Handling
custom
tags
Making
a
custom
generator
handle
custom
tags
see
ref
sss
ocamldoc
custom
tags
is
very
simple
subsubsection
sss
ocamldoc
html
generator
For
HTML
Here
is
how
to
develop
a
HTML
generator
handling
your
custom
tags
The
class
Odoc
html
Generator
html
inherits
from
the
class
Odoc
html
info
containing
a
field
tag
functions
which
is
a
list
pairs
composed
of
a
custom
tag
e
g
foo
and
a
function
taking
a
text
and
returning
HTML
code
of
type
string
To
handle
a
new
tag
bar
extend
the
current
HTML
generator
and
complete
the
tag
functions
field
begin
verbatim
module
Generator
G
Odoc
html
Html
generator
struct
class
html
object
self
inherit
G
html
Return
HTML
code
for
the
given
text
of
a
bar
tag
method
html
of
bar
t
your
code
here
initializer
tag
functions
bar
self
html
of
bar
tag
functions
end
end
let
Odoc
args
extend
html
generator
module
Generator
Odoc
gen
Html
functor
end
verbatim
Another
method
of
the
class
Odoc
html
info
will
look
for
the
function
associated
to
a
custom
tag
and
apply
it
to
the
text
given
to
the
tag
If
no
function
is
associated
to
a
custom
tag
then
the
method
prints
a
warning
message
on
stderr
subsubsection
sss
ocamldoc
other
generators
For
other
generators
You
can
act
the
same
way
for
other
kinds
of
generators
section
s
ocamldoc
adding
flags
Adding
command
line
options
The
command
line
analysis
is
performed
after
loading
the
module
containing
the
documentation
generator
thus
allowing
command
line
options
to
be
added
to
the
list
of
existing
ones
Adding
an
option
can
be
done
with
the
function
begin
verbatim
Odoc
args
add
option
string
Arg
spec
string
unit
end
verbatim
noindent
Note
Existing
command
line
options
can
be
redefined
using
this
function
subsection
ss
ocamldoc
compilation
and
usage
Compilation
and
usage
subsubsection
sss
ocamldoc
generator
class
Defining
a
custom
generator
class
in
one
file
Let
custom
ml
be
the
file
defining
a
new
generator
class
Compilation
of
custom
ml
can
be
performed
by
the
following
command
begin
alltt
ocamlc
I
ocamldoc
c
custom
ml
end
alltt
noindent
The
file
custom
cmo
is
created
and
can
be
used
this
way
begin
alltt
ocamldoc
g
custom
cmo
var
other
options
var
source
files
end
alltt
noindent
Options
selecting
a
built
in
generator
to
ocamldoc
such
as
html
have
no
effect
if
a
custom
generator
of
the
same
kind
is
provided
using
g
If
the
kinds
do
not
match
the
selected
built
in
generator
is
used
and
the
custom
one
is
ignored
subsubsection
sss
ocamldoc
modular
generator
Defining
a
custom
generator
class
in
several
files
It
is
possible
to
define
a
generator
class
in
several
modules
which
are
defined
in
several
files
var
nth
file
1
ml
i
var
nth
file
2
ml
i
var
nth
file
n
ml
i
A
cma
library
file
must
be
created
including
all
these
files
The
following
commands
create
the
custom
cma
file
from
files
var
nth
file
1
ml
i
var
nth
file
n
ml
i
begin
alltt
ocamlc
I
ocamldoc
c
var
nth
file
1
ml
textrm
i
textrm
ocamlc
I
ocamldoc
c
var
nth
file
2
ml
textrm
i
textrm
ocamlc
I
ocamldoc
c
var
nth
file
n
ml
textrm
i
textrm
ocamlc
o
custom
cma
a
var
nth
file
1
cmo
var
nth
file
2
cmo
var
nth
file
n
cmo
end
alltt
noindent
Then
the
following
command
uses
custom
cma
as
custom
generator
begin
alltt
ocamldoc
g
custom
cma
var
other
options
var
source
files
end
alltt
chapter
Runtime
tracing
with
runtime
events
label
c
runtime
tracing
HEVEA
cutname
runtime
tracing
html
This
chapter
describes
the
runtime
events
tracing
system
which
enables
continuous
extraction
of
performance
information
from
the
OCaml
runtime
with
very
low
overhead
The
system
and
interfaces
are
low
level
and
tightly
coupled
to
the
runtime
implementation
it
is
intended
for
end
users
to
rely
on
tooling
to
consume
and
visualise
data
of
interest
Data
emitted
includes
begin
itemize
item
Event
times
of
garbage
collector
and
runtime
phases
item
Minor
and
major
heap
sizings
and
utilization
item
Allocation
and
promotion
rates
between
heaps
end
itemize
Additional
events
can
be
declared
and
consumed
providing
higher
level
monitoring
capabilities
to
OCaml
libraries
They
are
referred
to
as
em
custom
events
section
s
runtime
tracing
overview
Overview
There
are
three
main
classes
of
events
emitted
by
the
runtime
events
system
begin
description
item
Spans
Events
spanning
over
a
duration
in
time
For
example
the
runtime
events
tracing
system
emits
a
span
event
that
starts
when
a
minor
collection
begins
in
the
OCaml
garbage
collector
and
ends
when
the
collection
is
completed
Spans
can
contain
other
spans
e
g
other
span
events
may
be
emitted
that
begin
after
a
minor
collection
has
begun
and
end
before
it
does
item
Lifecycle
events
Events
that
occur
at
a
moment
in
time
For
example
when
a
domain
terminates
a
corresponding
lifecycle
event
is
emitted
item
Counters
Events
that
include
a
measurement
of
some
quantity
of
interest
For
example
the
number
of
words
promoted
from
the
minor
to
the
major
heap
during
the
last
minor
garbage
collection
is
emitted
as
a
counter
event
end
description
The
runtime
events
tracing
system
is
designed
to
be
used
in
different
contexts
begin
description
item
Self
monitoring
OCaml
programs
and
libraries
can
install
their
own
callbacks
to
listen
for
runtime
events
and
react
to
them
programmatically
for
example
to
export
events
to
disk
or
over
the
network
item
External
monitoring
An
external
process
can
consume
the
runtime
events
of
an
OCaml
program
whose
runtime
tracing
system
has
been
enabled
by
setting
the
corresponding
environment
variable
end
description
The
runtime
events
tracing
system
logs
events
to
a
em
ring
buffer
Consequently
old
events
are
being
overwritten
by
new
events
Consumers
can
either
continuously
consume
events
or
choose
to
only
do
so
in
response
to
some
circumstance
e
g
if
a
particular
query
or
operation
takes
longer
than
expected
to
complete
section
s
runtime
tracing
architecture
Architecture
The
runtime
tracing
system
conceptually
consists
of
two
parts
1
the
event
sources
which
emit
events
and
2
the
events
transport
that
ingests
and
transports
these
events
subsection
s
runtime
tracing
event
sources
Event
sources
Event
sources
are
event
emitting
points
There
are
a
number
of
such
sources
in
the
OCaml
runtime
system
These
are
further
split
into
two
sets
1
event
sources
that
are
always
available
and
2
event
sources
that
are
only
available
in
the
instrumented
runtime
Event
sources
in
the
instrumented
runtime
are
primarily
of
interest
to
developers
of
the
OCaml
runtime
and
garbage
collector
and
at
present
only
consist
of
major
heap
allocation
size
counter
events
The
full
set
of
events
emitted
by
event
sources
and
their
documentation
can
be
found
in
ifouthtml
moduleref
libref
Runtime
events
Module
texttt
Runtime
events
else
section
ref
Runtime
events
fi
subsection
s
runtime
tracing
ingestion
Events
transport
The
events
transport
part
of
the
system
ingests
events
emitted
by
the
event
sources
and
makes
them
available
to
consumers
subsubsection
s
runtime
tracing
ringbuffers
Ring
buffers
Events
are
transported
using
a
data
structure
known
as
a
em
ring
buffer
This
data
structure
consists
of
two
pointers
into
a
linear
backing
array
the
tail
pointer
points
to
a
location
where
new
events
can
be
written
and
the
head
pointer
points
to
the
oldest
event
in
the
buffer
that
can
be
read
When
insufficient
space
is
available
in
the
backing
array
to
write
new
events
the
head
pointer
is
advanced
and
the
oldest
events
are
overwritten
by
new
ones
The
ring
buffer
implementation
used
in
runtime
events
can
be
written
by
at
most
one
producer
at
a
time
but
can
be
read
simultaneously
by
multiple
consumers
without
coordination
from
the
producer
There
is
a
unique
ring
buffer
for
every
running
domain
and
on
domain
termination
ring
buffers
may
be
re
used
for
newly
spawned
domains
Ring
buffers
are
only
allocated
including
for
the
main
domain
when
runtime
events
are
enabled
The
ring
buffers
themselves
are
stored
in
a
memory
mapped
file
with
the
processes
identifier
as
the
name
and
the
extension
events
this
enables
them
to
be
read
from
outside
the
main
OCaml
process
See
moduleref
libref
Runtime
events
texttt
Runtime
events
for
more
information
subsubsection
s
runtime
tracing
apis
Consumption
APIs
The
runtime
event
tracing
system
provides
both
OCaml
and
C
APIs
which
are
cursor
based
and
polling
driven
The
high
level
process
for
consuming
events
is
as
follows
begin
enumerate
item
A
cursor
is
created
via
texttt
Runtime
events
create
cursor
for
either
the
current
process
or
an
external
process
specified
by
a
path
and
PID
item
texttt
Runtime
events
Callbacks
create
is
called
to
register
a
callback
function
to
receive
the
events
item
The
cursor
is
polled
via
texttt
Runtime
events
read
poll
using
the
callbacks
created
in
the
previous
step
For
each
matching
event
in
the
ring
buffers
the
provided
callback
functions
are
called
In
addition
to
the
emitted
events
callbacks
are
given
the
emitter
domain
s
ID
and
the
emission
timestamp
end
enumerate
section
s
runtime
tracing
usage
Usage
subsection
s
runtime
tracing
ocaml
apis
With
OCaml
APIs
We
start
with
a
simple
example
that
prints
the
name
begin
and
end
times
of
events
emitted
by
the
runtime
event
tracing
system
begin
verbatim
let
runtime
begin
ts
phase
Printf
printf
Begin
t
s
t
Ld
n
Runtime
events
runtime
phase
name
phase
Runtime
events
Timestamp
to
int64
ts
let
runtime
end
ts
phase
Printf
printf
End
t
s
t
Ld
n
Runtime
events
runtime
phase
name
phase
Runtime
events
Timestamp
to
int64
ts
let
Runtime
events
start
let
cursor
Runtime
events
create
cursor
None
in
let
callbacks
Runtime
events
Callbacks
create
runtime
begin
runtime
end
in
while
true
do
let
list
ref
ref
in
for
later
fake
GC
work
for
1
to
100
do
here
we
do
some
fake
GC
work
list
ref
for
1
to
10
do
list
ref
Sys
opaque
identity
ref
42
list
ref
done
Gc
full
major
done
ignore
Runtime
events
read
poll
cursor
callbacks
None
Unix
sleep
1
done
end
verbatim
The
next
step
is
to
compile
and
link
the
program
with
the
runtime
events
library
This
can
be
done
as
follows
begin
verbatim
ocamlopt
I
runtime
events
I
unix
unix
cmxa
runtime
events
cmxa
example
ml
o
example
end
verbatim
When
using
the
em
dune
build
system
this
example
can
be
built
as
follows
begin
verbatim
executable
name
example
modules
example
libraries
unix
runtime
events
end
verbatim
Running
the
compiled
binary
of
the
example
gives
an
output
similar
to
begin
verbatim
Begin
explicit
gc
full
major
24086187297852
Begin
stw
leader
24086187298594
Begin
minor
24086187299404
Begin
minor
global
roots
24086187299807
End
minor
global
roots
24086187331461
Begin
minor
remembered
set
24086187331631
Begin
minor
finalizers
oldify
24086187544312
End
minor
finalizers
oldify
24086187544704
Begin
minor
remembered
set
promote
24086187544879
End
minor
remembered
set
promote
24086187606414
End
minor
remembered
set
24086187606584
Begin
minor
finalizers
admin
24086187606854
End
minor
finalizers
admin
24086187607152
Begin
minor
local
roots
24086187607329
Begin
minor
local
roots
promote
24086187609699
End
minor
local
roots
promote
24086187610539
End
minor
local
roots
24086187610709
End
minor
24086187611746
Begin
minor
clear
24086187612238
End
minor
clear
24086187612580
End
stw
leader
24086187613209
end
verbatim
This
is
an
example
of
self
monitoring
where
a
program
explicitly
starts
listening
to
runtime
events
and
monitors
itself
For
external
monitoring
a
program
does
not
need
to
be
aware
of
the
existence
of
runtime
events
Runtime
events
can
be
controlled
via
the
environment
variable
OCAML
RUNTIME
EVENTS
START
which
when
set
will
cause
the
runtime
tracing
system
to
be
started
at
program
initialization
We
could
remove
Runtime
events
start
from
the
previous
example
and
instead
call
the
program
as
below
to
produce
the
same
result
begin
verbatim
OCAML
RUNTIME
EVENTS
START
1
example
end
verbatim
subsubsection
s
runtime
tracing
environment
variables
Environment
variables
Environment
variables
can
be
used
to
control
different
aspects
of
the
runtime
event
tracing
system
The
following
environment
variables
are
available
begin
itemize
item
OCAML
RUNTIME
EVENTS
START
if
set
will
cause
the
runtime
events
system
to
be
started
as
part
of
the
OCaml
runtime
initialization
item
OCAML
RUNTIME
EVENTS
DIR
sets
the
directory
where
the
events
files
containing
the
runtime
event
tracing
system
s
ring
buffers
will
be
located
If
not
present
the
program
s
working
directory
will
be
used
item
OCAML
RUNTIME
EVENTS
PRESERVE
if
set
will
make
the
OCaml
runtime
preserve
the
runtime
events
ring
buffer
files
past
the
termination
of
the
OCaml
program
This
can
be
useful
for
monitoring
very
short
running
programs
If
not
set
the
events
files
of
the
OCaml
program
will
be
deleted
at
program
termination
end
itemize
The
size
of
the
runtime
events
ring
buffers
can
be
configured
via
OCAMLRUNPARAM
see
section
ref
s
ocamlrun
options
for
more
information
subsubsection
s
runtime
tracing
instrumented
runtime
Building
with
the
instrumented
runtime
Some
events
are
only
emitted
by
the
instrumented
runtime
To
receive
them
the
OCaml
program
needs
to
be
compiled
and
linked
against
the
instrumented
runtime
For
our
example
program
from
earlier
this
is
achieved
as
follows
begin
verbatim
ocamlopt
runtime
variant
i
I
runtime
events
I
unix
unix
cmxa
runtime
events
cmxa
example
ml
o
example
end
verbatim
And
for
dune
begin
verbatim
executable
name
example
modules
example
flags
runtime
variant
i
libraries
unix
runtime
events
end
verbatim
subsection
s
runtime
tracing
tooling
With
tooling
Programmatic
access
to
events
is
intended
primarily
for
writers
of
observability
libraries
and
tooling
for
end
users
The
flexible
API
enables
use
of
the
performance
data
from
runtime
events
for
logging
and
monitoring
purposes
In
this
section
we
cover
several
utilities
in
the
texttt
runtime
events
tools
package
which
provide
simple
ways
of
extracting
and
summarising
data
from
runtime
events
The
trace
utility
in
particular
produces
similar
data
to
the
previous
eventlog
instrumentation
system
available
in
OCaml
4
12
to
4
14
First
install
texttt
runtime
events
tools
in
an
OCaml
5
0
opam
switch
begin
verbatim
opam
install
runtime
events
tools
end
verbatim
This
should
install
the
olly
tool
in
your
path
You
can
now
generate
runtime
traces
for
programs
compiled
with
OCaml
5
0
using
the
trace
subcommand
begin
verbatim
olly
trace
trace
json
your
program
exe
args
end
verbatim
Runtime
tracing
data
will
be
generated
in
the
json
Trace
Event
Format
to
trace
json
This
can
then
be
loaded
into
the
Chrome
tracing
viewer
or
into
ifouthtml
ahref
https
ui
perfetto
dev
Perfetto
else
Perfetto
fi
to
visualize
the
collected
trace
subsubsection
s
runtime
tracing
latency
Measuring
GC
latency
The
olly
utility
also
includes
a
latency
subcommand
which
consumes
runtime
events
data
and
on
program
completion
emits
a
parseable
histogram
summary
of
pause
durations
It
can
be
run
as
follows
begin
verbatim
olly
latency
your
program
exe
args
end
verbatim
This
should
produce
an
output
similar
to
the
following
begin
verbatim
GC
latency
profile
Mean
ms
2
46
Stddev
ms
3
87
Min
ms
0
01
max
ms
9
17
Percentile
Latency
ms
25
0000
0
01
50
0000
0
23
60
0000
0
23
70
0000
0
45
75
0000
0
45
80
0000
0
45
85
0000
0
45
90
0000
9
17
95
0000
9
17
96
0000
9
17
97
0000
9
17
98
0000
9
17
99
0000
9
17
99
9000
9
17
99
9900
9
17
99
9990
9
17
99
9999
9
17
100
0000
9
17
end
verbatim
section
s
runtime
tracing
custom
events
Custom
events
subsection
s
runtime
tracing
custom
events
overview
Overview
The
runtime
events
system
supports
defining
custom
events
Identified
by
a
globally
unique
name
they
are
emitted
with
payloads
of
built
in
texttt
unit
texttt
int
texttt
span
and
user
defined
types
To
understand
the
manipulation
of
custom
events
it
is
useful
to
know
how
they
are
transported
and
stored
their
representation
consists
of
a
name
string
in
fact
an
index
into
an
array
of
all
custom
names
and
an
arbitrary
byte
sequence
Custom
event
types
can
be
emph
registered
by
providing
encoding
and
decoding
functions
to
and
from
a
byte
sequence
via
the
function
texttt
Runtime
events
Type
register
Defining
a
new
custom
event
whether
its
payload
is
of
a
built
in
type
or
a
custom
type
is
done
via
another
registration
function
texttt
Runtime
events
User
register
This
function
records
the
association
between
the
custom
event
s
name
its
type
and
a
emph
tag
The
tag
is
then
used
when
emitting
or
consuming
custom
events
it
acts
as
a
shorthand
for
the
event
name
Once
an
event
is
registered
values
for
that
event
are
emitted
using
texttt
Runtime
events
User
write
To
summarize
for
a
user
to
emit
and
consume
custom
events
using
a
custom
type
they
need
to
begin
enumerate
item
register
the
custom
type
item
extend
the
texttt
Runtime
events
User
tag
variant
with
a
new
constructor
item
register
the
new
custom
event
binding
together
the
custom
event
name
the
new
tag
and
the
new
custom
type
item
emit
instances
of
the
event
using
texttt
Runtime
events
User
write
item
indicate
a
callback
which
should
receive
all
events
of
the
custom
type
using
texttt
Runtime
events
Callbacks
add
user
event
to
register
it
inside
a
texttt
Runtime
events
Callbacks
t
object
to
be
used
when
polling
see
section
ref
s
runtime
tracing
ocaml
apis
above
item
emph
Optional
if
there
are
distinct
events
registered
with
the
same
custom
type
In
that
callback
pattern
match
on
the
event
tag
in
order
to
discriminate
between
different
event
tags
of
the
same
custom
type
end
enumerate
Note
that
if
the
emitter
and
the
consumer
are
different
programs
both
must
perform
steps
1
to
3
to
register
custom
events
and
custom
event
types
if
any
Note
that
the
tag
values
need
not
be
the
same
in
both
programs
the
only
values
that
should
match
are
the
names
Unregistered
events
for
user
defined
types
are
currently
ignored
As
a
fallback
unregistered
custom
events
of
a
built
in
type
are
available
but
are
all
tagged
texttt
UNK
unknown
There
are
thus
three
cases
for
the
consumer
when
an
event
is
received
begin
itemize
item
event
is
registered
payload
and
tag
are
available
item
event
is
not
registered
and
has
a
built
in
event
type
unit
int
span
only
the
payload
is
available
item
event
is
not
registered
and
has
a
custom
event
type
event
is
dropped
end
itemize
Note
that
event
consumers
bind
callbacks
to
event
emph
types
so
they
can
work
as
generic
listeners
interpreting
payloads
coming
from
events
that
were
not
registered
Because
this
only
works
for
events
of
built
in
types
it
can
be
useful
to
emit
events
in
pairs
an
event
of
a
custom
type
with
an
event
of
a
built
in
type
enabling
the
design
of
a
specialized
consumer
while
staying
compatible
with
generic
tracing
tools
subsection
s
runtime
tracing
custom
events
usage
Tracing
custom
events
an
example
The
following
program
uses
the
texttt
Runtime
events
User
and
texttt
Runtime
events
Type
modules
to
declare
two
custom
events
providing
texttt
span
and
texttt
int
values
The
texttt
tag
extensible
variant
is
extended
with
texttt
CustomSpan
and
texttt
CustomInt
begin
verbatim
type
Runtime
events
User
tag
CustomSpan
CustomInt
let
count
span
Runtime
events
User
register
count
span
CustomSpan
Runtime
events
Type
span
let
count
value
Runtime
events
User
register
count
value
CustomInt
Runtime
events
Type
int
let
count
Runtime
events
User
write
count
span
Begin
for
i
1
to
5
do
Runtime
events
User
write
count
value
i
done
Runtime
events
User
write
count
span
End
let
Runtime
events
start
for
1
to
3
do
count
done
end
verbatim
On
the
consumer
side
one
can
use
the
provided
event
tag
and
type
to
match
on
the
relevant
events
For
the
sake
of
completeness
we
assume
that
the
consumer
is
a
different
program
and
repeat
the
definition
of
the
new
tag
constructors
as
well
as
the
registering
of
the
custom
events
begin
verbatim
type
Runtime
events
User
tag
CustomSpan
CustomInt
let
count
span
Runtime
events
User
register
count
span
CustomSpan
Runtime
events
Type
span
let
count
value
Runtime
events
User
register
count
value
CustomInt
Runtime
events
Type
int
let
span
event
handler
domain
id
ts
event
value
we
re
only
interested
in
our
CustomSpan
event
match
Runtime
events
User
tag
event
value
with
CustomSpan
Runtime
events
Type
Begin
Printf
printf
count
begin
n
CustomSpan
End
Printf
printf
count
end
n
let
int
event
handler
domain
id
ts
event
value
we
re
only
interested
in
our
CustomInt
event
match
Runtime
events
User
tag
event
with
CustomInt
Printf
printf
count
d
n
value
let
let
open
Runtime
events
in
let
cursor
create
cursor
None
in
let
callbacks
Callbacks
create
Callbacks
add
user
event
Type
span
span
event
handler
Callbacks
add
user
event
Type
int
int
event
handler
in
for
0
to
100
do
ignore
read
poll
cursor
callbacks
None
done
end
verbatim
Giving
the
following
output
begin
verbatim
count
begin
count
1
count
2
count
3
count
4
count
5
count
end
count
begin
count
1
count
2
end
verbatim
This
file
describes
the
native
bytecode
compiler
and
toplevel
options
Since
specific
options
can
exist
in
only
a
subset
of
toplevel
bytecode
compiler
native
compiler
and
their
description
might
differ
across
this
subset
this
file
uses
macros
to
adapt
the
description
tool
by
tool
long
def
comp
1
ifcomp
1
else
fi
long
is
needed
for
multiparagraph
macros
long
def
nat
1
ifnat
1
else
fi
long
def
top
1
iftop
1
else
fi
long
def
notop
1
iftop
else
1
fi
Note
that
the
previous
definitions
relies
on
the
three
boolean
values
top
nat
and
comp
The
manual
section
must
therefore
set
these
boolean
values
accordingly
The
macros
comp
nat
top
adds
a
supplementary
text
if
we
are
respectively
in
the
bytecode
compiler
native
compiler
toplevel
section
The
toplevel
options
are
quite
different
from
the
compilers
options
It
is
therefore
useful
to
have
also
a
substractive
notop
macro
that
prints
its
content
only
outside
of
the
topvel
section
For
instance
to
add
an
option
foo
that
applies
to
the
native
and
bytecode
compiler
one
can
write
notop
item
foo
Similarly
an
option
bar
only
available
in
the
native
compiler
can
be
introduced
with
nat
item
bar
These
macros
can
be
also
used
to
add
information
that
are
only
relevant
to
some
tools
or
differ
slightly
from
one
tool
to
another
For
instance
we
define
the
following
macro
for
the
pairs
cma
cmxa
cmo
cmxo
and
ocamlc
ocamlopt
def
cma
comp
cma
nat
cmxa
def
cmo
comp
cmo
nat
cmx
def
qcmo
machine
cmo
def
qcma
machine
cma
def
ocamlx
comp
ocamlc
nat
ocamlopt
begin
options
notop
item
a
Build
a
library
nat
cmxa
and
a
lib
files
comp
cma
file
with
the
object
files
nat
cmx
and
o
obj
files
comp
cmo
files
given
on
the
command
line
instead
of
linking
them
into
an
executable
file
The
name
of
the
library
must
be
set
with
the
o
option
If
comp
custom
cclib
or
ccopt
options
are
passed
on
the
command
line
these
options
are
stored
in
the
resulting
qcma
library
Then
linking
with
this
library
automatically
adds
back
the
comp
custom
cclib
and
ccopt
options
as
if
they
had
been
provided
on
the
command
line
unless
the
noautolink
option
is
given
notop
item
absname
Force
error
messages
to
show
absolute
paths
for
file
names
item
no
absname
Do
not
try
to
show
absolute
filenames
in
error
messages
notop
item
annot
Deprecated
since
OCaml
4
11
Please
use
bin
annot
instead
notop
item
args
var
filename
Read
additional
newline
terminated
command
line
arguments
from
var
filename
top
It
is
not
possible
to
pass
a
var
scriptfile
via
file
to
the
toplevel
top
item
args0
var
filename
Read
additional
null
character
terminated
command
line
arguments
from
var
filename
top
It
is
not
possible
to
pass
a
var
scriptfile
via
file
to
the
toplevel
top
notop
item
bin
annot
Dump
detailed
information
about
the
compilation
types
bindings
tail
calls
etc
in
binary
format
The
information
for
file
var
src
ml
resp
var
src
mli
is
put
into
file
var
src
cmt
resp
var
src
cmti
In
case
of
a
type
error
dump
all
the
information
inferred
by
the
type
checker
before
the
error
The
cmt
and
cmti
files
produced
by
bin
annot
contain
more
information
and
are
much
more
compact
than
the
files
produced
by
annot
notop
notop
item
c
Compile
only
Suppress
the
linking
phase
of
the
compilation
Source
code
files
are
turned
into
compiled
files
but
no
executable
file
is
produced
This
option
is
useful
to
compile
modules
separately
notop
notop
item
cc
var
ccomp
Use
var
ccomp
as
the
C
linker
nat
called
to
build
the
final
executable
comp
when
linking
in
custom
runtime
mode
see
the
custom
option
and
as
the
C
compiler
for
compiling
c
source
files
When
linking
object
files
produced
by
a
C
compiler
such
as
g
or
clang
it
is
recommended
to
use
cc
c
notop
notop
item
cclib
l
var
libname
Pass
the
l
var
libname
option
to
the
comp
C
linker
comp
when
linking
in
custom
runtime
mode
see
the
custom
option
This
causes
the
given
C
library
to
be
linked
with
the
program
notop
notop
item
ccopt
var
option
Pass
the
given
option
to
the
C
compiler
and
linker
comp
When
linking
in
custom
runtime
mode
for
instance
nat
For
instance
ccopt
L
var
dir
causes
the
C
linker
to
search
for
C
libraries
in
directory
var
dir
comp
See
the
custom
option
notop
notop
item
cmi
file
var
filename
Use
the
given
interface
file
to
type
check
the
ML
source
file
to
compile
When
this
option
is
not
specified
the
compiler
looks
for
a
var
mli
file
with
the
same
base
name
than
the
implementation
it
is
compiling
and
in
the
same
directory
If
such
a
file
is
found
the
compiler
looks
for
a
corresponding
var
cmi
file
in
the
included
directories
and
reports
an
error
if
it
fails
to
find
one
notop
notop
item
color
var
mode
Enable
or
disable
colors
in
compiler
messages
especially
warnings
and
errors
The
following
modes
are
supported
begin
description
item
auto
use
heuristics
to
enable
colors
only
if
the
output
supports
them
an
ANSI
compatible
tty
terminal
item
always
enable
colors
unconditionally
item
never
disable
color
output
end
description
The
environment
variable
OCAML
COLOR
is
considered
if
color
is
not
provided
Its
values
are
auto
always
never
as
above
If
color
is
not
provided
OCAML
COLOR
is
not
set
and
the
environment
variable
NO
COLOR
is
set
then
color
output
is
disabled
Otherwise
the
default
setting
is
auto
and
the
current
heuristic
checks
that
the
TERM
environment
variable
exists
and
is
not
empty
or
dumb
and
that
isatty
stderr
holds
notop
notop
item
error
style
var
mode
Control
the
way
error
messages
and
warnings
are
printed
The
following
modes
are
supported
begin
description
item
short
only
print
the
error
and
its
location
item
contextual
like
short
but
also
display
the
source
code
snippet
corresponding
to
the
location
of
the
error
end
description
The
default
setting
is
contextual
The
environment
variable
OCAML
ERROR
STYLE
is
considered
if
error
style
is
not
provided
Its
values
are
short
contextual
as
above
notop
comp
item
compat
32
Check
that
the
generated
bytecode
executable
can
run
on
32
bit
platforms
and
signal
an
error
if
it
cannot
This
is
useful
when
compiling
bytecode
on
a
64
bit
machine
comp
nat
item
compact
Optimize
the
produced
code
for
space
rather
than
for
time
This
results
in
slightly
smaller
but
slightly
slower
programs
The
default
is
to
optimize
for
speed
nat
notop
item
config
Print
the
version
number
of
machine
ocamlx
and
a
detailed
summary
of
its
configuration
then
exit
notop
notop
item
config
var
var
var
Print
the
value
of
a
specific
configuration
variable
from
the
config
output
then
exit
If
the
variable
does
not
exist
the
exit
code
is
non
zero
This
option
is
only
available
since
OCaml
4
08
so
script
authors
should
have
a
fallback
for
older
versions
notop
comp
item
custom
Link
in
custom
runtime
mode
In
the
default
linking
mode
the
linker
produces
bytecode
that
is
intended
to
be
executed
with
the
shared
runtime
system
ocamlrun
In
the
custom
runtime
mode
the
linker
produces
an
output
file
that
contains
both
the
runtime
system
and
the
bytecode
for
the
program
The
resulting
file
is
larger
but
it
can
be
executed
directly
even
if
the
ocamlrun
command
is
not
installed
Moreover
the
custom
runtime
mode
enables
static
linking
of
OCaml
code
with
user
defined
C
functions
as
described
in
chapter
ref
c
intf
c
begin
unix
Never
use
the
strip
command
on
executables
produced
by
ocamlc
custom
this
would
remove
the
bytecode
part
of
the
executable
end
unix
begin
unix
Security
warning
never
set
the
setuid
or
setgid
bits
on
executables
produced
by
ocamlc
custom
this
would
make
them
vulnerable
to
attacks
end
unix
comp
notop
item
depend
var
ocamldep
args
Compute
dependencies
as
the
ocamldep
command
would
do
The
remaining
arguments
are
interpreted
as
if
they
were
given
to
the
ocamldep
command
notop
comp
item
dllib
l
var
libname
Arrange
for
the
C
shared
library
dll
var
libname
so
dll
var
libname
dll
under
Windows
to
be
loaded
dynamically
by
the
run
time
system
ocamlrun
at
program
start
up
time
comp
comp
item
dllpath
var
dir
Adds
the
directory
var
dir
to
the
run
time
search
path
for
shared
C
libraries
At
link
time
shared
libraries
are
searched
in
the
standard
search
path
the
one
corresponding
to
the
I
option
The
dllpath
option
simply
stores
var
dir
in
the
produced
executable
file
where
ocamlrun
can
find
it
and
use
it
as
described
in
section
ref
s
ocamlrun
dllpath
comp
notop
item
for
pack
var
module
path
Generate
an
object
file
qcmo
nat
and
o
obj
files
that
can
later
be
included
as
a
sub
module
with
the
given
access
path
of
a
compilation
unit
constructed
with
pack
For
instance
machine
ocamlx
for
pack
P
c
A
ml
will
generate
machine
a
cmo
nat
and
a
o
files
that
can
later
be
used
with
machine
ocamlx
pack
o
P
cmo
a
cmo
Note
you
can
still
pack
a
module
that
was
compiled
without
for
pack
but
in
this
case
exceptions
will
be
printed
with
the
wrong
names
notop
notop
item
g
Add
debugging
information
while
compiling
and
linking
This
option
is
required
in
order
to
comp
be
able
to
debug
the
program
with
ocamldebug
see
chapter
ref
c
debugger
and
to
produce
stack
backtraces
when
the
program
terminates
on
an
uncaught
exception
see
section
ref
s
ocamlrun
options
notop
notop
item
no
g
Do
not
record
debugging
information
default
notop
notop
item
i
Cause
the
compiler
to
print
all
defined
names
with
their
inferred
types
or
their
definitions
when
compiling
an
implementation
ml
file
No
compiled
files
cmo
and
cmi
files
are
produced
This
can
be
useful
to
check
the
types
inferred
by
the
compiler
Also
since
the
output
follows
the
syntax
of
interfaces
it
can
help
in
writing
an
explicit
interface
mli
file
for
a
file
just
redirect
the
standard
output
of
the
compiler
to
a
mli
file
and
edit
that
file
to
remove
all
declarations
of
unexported
names
notop
item
i
variance
Cause
the
compiler
to
print
the
computed
variance
of
type
parameters
for
every
type
declaration
Without
this
option
variance
is
printed
only
for
private
types
or
types
without
a
manifest
e
g
abstract
types
item
I
var
directory
Add
the
given
directory
to
the
list
of
directories
searched
for
nat
compiled
interface
files
cmi
compiled
object
code
files
cmx
and
libraries
cmxa
comp
compiled
interface
files
cmi
compiled
object
code
files
cmo
libraries
cma
and
C
libraries
specified
with
cclib
lxxx
top
source
and
compiled
files
By
default
the
current
directory
is
searched
first
then
the
standard
library
directory
Directories
added
with
I
are
searched
after
the
current
directory
in
the
order
in
which
they
were
given
on
the
command
line
but
before
the
standard
library
directory
See
also
option
nostdlib
If
the
given
directory
starts
with
it
is
taken
relative
to
the
standard
library
directory
For
instance
I
unix
adds
the
subdirectory
unix
of
the
standard
library
to
the
search
path
top
Directories
can
also
be
added
to
the
list
once
the
toplevel
is
running
with
the
directory
directive
section
ref
s
toplevel
directives
top
notop
item
H
var
directory
Behaves
identically
to
I
except
that
a
programs
may
not
directly
refer
to
modules
added
to
the
search
path
this
way
and
b
these
directories
are
searched
after
any
I
directories
This
makes
it
possible
to
provide
the
compiler
with
compiled
interface
and
object
code
files
for
the
current
program
s
transitive
dependencies
the
dependencies
of
its
dependencies
without
allowing
them
to
silently
become
direct
dependencies
notop
top
item
init
var
file
Load
the
given
file
instead
of
the
default
initialization
file
The
default
initialization
file
is
the
first
found
of
begin
enumerate
item
ocamlinit
in
the
current
directory
item
XDG
CONFIG
HOME
ocaml
init
ml
if
XDG
CONFIG
HOME
is
an
absolute
path
item
otherwise
on
Unix
HOME
ocaml
init
ml
or
on
Windows
ocaml
init
ml
under
LocalAppData
e
g
C
Users
Bactrian
AppData
Local
ocaml
init
ml
item
ocaml
init
ml
under
any
of
the
absolute
paths
in
XDG
CONFIG
DIRS
Paths
in
XDG
CONFIG
DIRS
are
colon
delimited
on
Unix
and
semicolon
delimited
on
Windows
item
if
XDG
CONFIG
DIRS
contained
no
absolute
paths
usr
xdg
ocaml
init
ml
on
Unix
or
ocaml
init
ml
under
any
of
LocalAppData
e
g
C
Users
Bactrian
AppData
Local
RoamingAppData
e
g
C
Users
Bactrian
AppData
Roaming
or
ProgramData
e
g
C
ProgramData
on
Windows
item
HOME
ocamlinit
if
HOME
is
non
empty
end
enumerate
top
notop
item
impl
var
filename
Compile
the
file
var
filename
as
an
implementation
file
even
if
its
extension
is
not
ml
notop
nat
item
inline
var
n
Set
aggressiveness
of
inlining
to
var
n
where
var
n
is
a
positive
integer
Specifying
inline
0
prevents
all
functions
from
being
inlined
except
those
whose
body
is
smaller
than
the
call
site
Thus
inlining
causes
no
expansion
in
code
size
The
default
aggressiveness
inline
1
allows
slightly
larger
functions
to
be
inlined
resulting
in
a
slight
expansion
in
code
size
Higher
values
for
the
inline
option
cause
larger
and
larger
functions
to
become
candidate
for
inlining
but
can
result
in
a
serious
increase
in
code
size
nat
notop
item
intf
var
filename
Compile
the
file
var
filename
as
an
interface
file
even
if
its
extension
is
not
mli
notop
notop
item
intf
suffix
var
string
Recognize
file
names
ending
with
var
string
as
interface
files
instead
of
the
default
mli
notop
item
keywords
var
version
list
Set
keywords
according
to
the
var
version
list
specification
This
specification
starts
with
an
optional
version
number
defining
the
base
set
of
keywords
followed
by
a
var
separated
list
of
additional
keywords
to
add
to
this
base
set
Without
an
explicit
version
number
the
base
set
of
keywords
is
the
set
of
keywords
in
the
current
version
of
OCaml
Additional
keywords
that
do
not
match
any
known
keyword
in
the
current
version
of
the
language
trigger
an
error
whenever
they
are
present
in
the
source
code
item
labels
Labels
are
not
ignored
in
types
labels
may
be
used
in
applications
and
labelled
parameters
can
be
given
in
any
order
This
is
the
default
notop
item
linkall
Force
all
modules
contained
in
libraries
to
be
linked
in
If
this
flag
is
not
given
unreferenced
modules
are
not
linked
in
When
building
a
library
option
a
setting
the
linkall
option
forces
all
subsequent
links
of
programs
involving
that
library
to
link
all
the
modules
contained
in
the
library
When
compiling
a
module
option
c
setting
the
linkall
option
ensures
that
this
module
will
always
be
linked
if
it
is
put
in
a
library
and
this
library
is
linked
notop
nat
item
linscan
Use
linear
scan
register
allocation
Compiling
with
this
allocator
is
faster
than
with
the
usual
graph
coloring
allocator
sometimes
quite
drastically
so
for
long
functions
and
modules
On
the
other
hand
the
generated
code
can
be
a
bit
slower
nat
comp
item
make
runtime
Build
a
custom
runtime
system
in
the
file
specified
by
option
o
incorporating
the
C
object
files
and
libraries
given
on
the
command
line
This
custom
runtime
system
can
be
used
later
to
execute
bytecode
executables
produced
with
the
ocamlc
use
runtime
var
runtime
name
option
See
section
ref
ss
custom
runtime
for
more
information
comp
notop
item
match
context
rows
Set
the
number
of
rows
of
context
used
for
optimization
during
pattern
matching
compilation
The
default
value
is
32
Lower
values
cause
faster
compilation
but
less
optimized
code
This
advanced
option
is
meant
for
use
in
the
event
that
a
pattern
match
heavy
program
leads
to
significant
increases
in
compilation
time
notop
notop
item
no
alias
deps
Do
not
record
dependencies
for
module
aliases
See
section
ref
s
module
alias
for
more
information
notop
item
no
app
funct
Deactivates
the
applicative
behaviour
of
functors
With
this
option
each
functor
application
generates
new
types
in
its
result
and
applying
the
same
functor
twice
to
the
same
argument
yields
two
incompatible
structures
nat
item
no
float
const
prop
Deactivates
the
constant
propagation
for
floating
point
operations
This
option
should
be
given
if
the
program
changes
the
float
rounding
mode
during
its
execution
nat
item
noassert
Do
not
compile
assertion
checks
Note
that
the
special
form
assert
false
is
always
compiled
because
it
is
typed
specially
notop
This
flag
has
no
effect
when
linking
already
compiled
files
notop
item
noautolink
When
linking
qcma
libraries
ignore
comp
custom
cclib
and
ccopt
options
potentially
contained
in
the
libraries
if
these
options
were
given
when
building
the
libraries
This
can
be
useful
if
a
library
contains
incorrect
specifications
of
C
libraries
or
C
options
in
this
case
during
linking
set
noautolink
and
pass
the
correct
C
libraries
and
options
on
the
command
line
nat
item
nodynlink
Allow
the
compiler
to
use
some
optimizations
that
are
valid
only
for
code
that
is
statically
linked
to
produce
a
non
relocatable
executable
The
generated
code
cannot
be
linked
to
produce
a
shared
library
nor
a
position
independent
executable
PIE
Many
operating
systems
produce
PIEs
by
default
causing
errors
when
linking
code
compiled
with
nodynlink
Either
do
not
use
nodynlink
or
pass
the
option
ccopt
no
pie
at
link
time
nat
item
nolabels
Ignore
non
optional
labels
in
types
Labels
cannot
be
used
in
applications
and
parameter
order
becomes
strict
top
item
noprompt
Do
not
display
any
prompt
when
waiting
for
input
top
top
item
nopromptcont
Do
not
display
the
secondary
prompt
when
waiting
for
continuation
lines
in
multi
line
inputs
This
should
be
used
e
g
when
running
ocaml
in
an
emacs
window
top
item
nostdlib
top
Do
not
include
the
standard
library
directory
in
the
list
of
directories
searched
for
source
and
compiled
files
top
comp
Do
not
include
the
standard
library
directory
in
the
list
of
directories
searched
for
compiled
interface
files
cmi
compiled
object
code
files
cmo
libraries
cma
and
C
libraries
specified
with
cclib
lxxx
See
also
option
I
comp
nat
Do
not
automatically
add
the
standard
library
directory
to
the
list
of
directories
searched
for
compiled
interface
files
cmi
compiled
object
code
files
cmx
and
libraries
cmxa
See
also
option
I
nat
notop
item
o
var
output
file
Specify
the
name
of
the
output
file
to
produce
For
executable
files
the
default
output
name
is
a
out
under
Unix
and
camlprog
exe
under
Windows
If
the
a
option
is
given
specify
the
name
of
the
library
produced
If
the
pack
option
is
given
specify
the
name
of
the
packed
object
file
produced
If
the
output
obj
or
output
complete
obj
options
are
given
specify
the
name
of
the
produced
object
file
nat
If
the
shared
option
is
given
specify
the
name
of
plugin
file
produced
comp
If
the
c
option
is
given
specify
the
name
of
the
object
file
produced
for
the
em
next
source
file
that
appears
on
the
command
line
notop
notop
item
opaque
When
the
native
compiler
compiles
an
implementation
by
default
it
produces
a
cmx
file
containing
information
for
cross
module
optimization
It
also
expects
cmx
files
to
be
present
for
the
dependencies
of
the
currently
compiled
source
and
uses
them
for
optimization
Since
OCaml
4
03
the
compiler
will
emit
a
warning
if
it
is
unable
to
locate
the
cmx
file
of
one
of
those
dependencies
The
opaque
option
available
since
4
04
disables
cross
module
optimization
information
for
the
currently
compiled
unit
When
compiling
mli
interface
using
opaque
marks
the
compiled
cmi
interface
so
that
subsequent
compilations
of
modules
that
depend
on
it
will
not
rely
on
the
corresponding
cmx
file
nor
warn
if
it
is
absent
When
the
native
compiler
compiles
a
ml
implementation
using
opaque
generates
a
cmx
that
does
not
contain
any
cross
module
optimization
information
Using
this
option
may
degrade
the
quality
of
generated
code
but
it
reduces
compilation
time
both
on
clean
and
incremental
builds
Indeed
with
the
native
compiler
when
the
implementation
of
a
compilation
unit
changes
all
the
units
that
depend
on
it
may
need
to
be
recompiled
because
the
cross
module
information
may
have
changed
If
the
compilation
unit
whose
implementation
changed
was
compiled
with
opaque
no
such
recompilation
needs
to
occur
This
option
can
thus
be
used
for
example
to
get
faster
edit
compile
test
feedback
loops
notop
notop
item
open
var
Module
Opens
the
given
module
before
processing
the
interface
or
implementation
files
If
several
open
options
are
given
they
are
processed
in
order
just
as
if
the
statements
open
var
Module1
open
var
ModuleN
were
added
at
the
top
of
each
file
notop
notop
item
output
obj
Cause
the
linker
to
produce
a
C
object
file
instead
of
comp
a
bytecode
executable
file
nat
an
executable
file
This
is
useful
to
wrap
OCaml
code
as
a
C
library
callable
from
any
C
program
See
chapter
ref
c
intf
c
section
ref
ss
c
embedded
code
The
name
of
the
output
object
file
must
be
set
with
the
o
option
This
option
can
also
be
used
to
produce
a
comp
C
source
file
c
extension
or
a
compiled
shared
dynamic
library
so
extension
dll
under
Windows
notop
comp
item
output
complete
exe
Build
a
self
contained
executable
by
linking
a
C
object
file
containing
the
bytecode
program
the
OCaml
runtime
system
and
any
other
static
C
code
given
to
ocamlc
The
resulting
effect
is
similar
to
custom
except
that
the
bytecode
is
embedded
in
the
C
code
so
it
is
no
longer
accessible
to
tools
such
as
ocamldebug
On
the
other
hand
the
resulting
binary
is
resistant
to
strip
comp
notop
item
output
complete
obj
Same
as
output
obj
options
except
the
object
file
produced
includes
the
runtime
and
autolink
libraries
notop
nat
item
pack
Build
an
object
file
cmx
and
o
obj
files
and
its
associated
compiled
interface
cmi
that
combines
the
cmx
object
files
given
on
the
command
line
making
them
appear
as
sub
modules
of
the
output
cmx
file
The
name
of
the
output
cmx
file
must
be
given
with
the
o
option
For
instance
begin
verbatim
ocamlopt
pack
o
P
cmx
A
cmx
B
cmx
C
cmx
end
verbatim
generates
compiled
files
P
cmx
P
o
and
P
cmi
describing
a
compilation
unit
having
three
sub
modules
A
B
and
C
corresponding
to
the
contents
of
the
object
files
A
cmx
B
cmx
and
C
cmx
These
contents
can
be
referenced
as
P
A
P
B
and
P
C
in
the
remainder
of
the
program
The
cmx
object
files
being
combined
must
have
been
compiled
with
the
appropriate
for
pack
option
In
the
example
above
A
cmx
B
cmx
and
C
cmx
must
have
been
compiled
with
ocamlopt
for
pack
P
Multiple
levels
of
packing
can
be
achieved
by
combining
pack
with
for
pack
Consider
the
following
example
begin
verbatim
ocamlopt
for
pack
P
Q
c
A
ml
ocamlopt
pack
o
Q
cmx
for
pack
P
A
cmx
ocamlopt
for
pack
P
c
B
ml
ocamlopt
pack
o
P
cmx
Q
cmx
B
cmx
end
verbatim
The
resulting
P
cmx
object
file
has
sub
modules
P
Q
P
Q
A
and
P
B
nat
comp
item
pack
Build
a
bytecode
object
file
cmo
file
and
its
associated
compiled
interface
cmi
that
combines
the
object
files
given
on
the
command
line
making
them
appear
as
sub
modules
of
the
output
cmo
file
The
name
of
the
output
cmo
file
must
be
given
with
the
o
option
For
instance
begin
verbatim
ocamlc
pack
o
p
cmo
a
cmo
b
cmo
c
cmo
end
verbatim
generates
compiled
files
p
cmo
and
p
cmi
describing
a
compilation
unit
having
three
sub
modules
A
B
and
C
corresponding
to
the
contents
of
the
object
files
a
cmo
b
cmo
and
c
cmo
These
contents
can
be
referenced
as
P
A
P
B
and
P
C
in
the
remainder
of
the
program
comp
notop
item
pp
var
command
Cause
the
compiler
to
call
the
given
var
command
as
a
preprocessor
for
each
source
file
The
output
of
var
command
is
redirected
to
an
intermediate
file
which
is
compiled
If
there
are
no
compilation
errors
the
intermediate
file
is
deleted
afterwards
notop
item
ppx
var
command
After
parsing
pipe
the
abstract
syntax
tree
through
the
preprocessor
var
command
The
module
Ast
mapper
described
in
ifouthtml
chapter
ref
c
parsinglib
ahref
compilerlibref
Ast
mapper
html
texttt
Ast
mapper
else
section
ref
Ast
mapper
fi
implements
the
external
interface
of
a
preprocessor
item
principal
Check
information
path
during
type
checking
to
make
sure
that
all
types
are
derived
in
a
principal
way
When
using
labelled
arguments
and
or
polymorphic
methods
this
flag
is
required
to
ensure
future
versions
of
the
compiler
will
be
able
to
infer
types
correctly
even
if
internal
algorithms
change
All
programs
accepted
in
principal
mode
are
also
accepted
in
the
default
mode
with
equivalent
types
but
different
binary
signatures
and
this
may
slow
down
type
checking
yet
it
is
a
good
idea
to
use
it
once
before
publishing
source
code
item
rectypes
Allow
arbitrary
recursive
types
during
type
checking
By
default
only
recursive
types
where
the
recursion
goes
through
an
object
type
are
supported
notop
Note
that
once
you
have
created
an
interface
using
this
flag
you
must
use
it
again
for
all
dependencies
notop
item
runtime
variant
var
suffix
Add
the
var
suffix
string
to
the
name
of
the
runtime
library
used
by
the
program
Currently
only
one
such
suffix
is
supported
d
and
only
if
the
OCaml
compiler
was
configured
with
option
with
debug
runtime
This
suffix
gives
the
debug
version
of
the
runtime
which
is
useful
for
debugging
pointer
problems
in
low
level
code
such
as
C
stubs
notop
nat
item
S
Keep
the
assembly
code
produced
during
the
compilation
The
assembly
code
for
the
source
file
var
x
ml
is
saved
in
the
file
var
x
s
nat
item
safe
string
Enforce
the
separation
between
types
string
and
bytes
thereby
making
strings
read
only
This
is
the
default
and
enforced
since
OCaml
5
0
item
safer
matching
Do
not
use
type
information
to
optimize
pattern
matching
This
allows
to
detect
match
failures
even
if
a
pattern
matching
was
wrongly
assumed
to
be
exhaustive
This
only
impacts
GADT
and
polymorphic
variant
compilation
nat
item
save
ir
after
var
pass
Save
intermediate
representation
after
the
given
compilation
pass
to
a
file
The
currently
supported
passes
and
the
corresponding
file
extensions
are
scheduling
cmir
linear
This
experimental
feature
enables
external
tools
to
inspect
and
manipulate
compiler
s
intermediate
representation
of
the
program
using
compiler
libs
library
see
ifouthtml
chapter
ref
c
parsinglib
and
ahref
compilerlibref
Compiler
libs
html
texttt
Compiler
libs
else
section
ref
Compiler
libs
fi
nat
nat
item
shared
Build
a
plugin
usually
cmxs
that
can
be
dynamically
loaded
with
the
Dynlink
module
The
name
of
the
plugin
must
be
set
with
the
o
option
A
plugin
can
include
a
number
of
OCaml
modules
and
libraries
and
extra
native
objects
o
obj
a
lib
files
Building
native
plugins
is
only
supported
for
some
operating
system
Under
some
systems
currently
only
Linux
AMD
64
all
the
OCaml
code
linked
in
a
plugin
must
have
been
compiled
without
the
nodynlink
flag
Some
constraints
might
also
apply
to
the
way
the
extra
native
objects
have
been
compiled
under
Linux
AMD
64
they
must
contain
only
position
independent
code
nat
item
short
paths
When
a
type
is
visible
under
several
module
paths
use
the
shortest
one
when
printing
the
type
s
name
in
inferred
interfaces
and
error
and
warning
messages
Identifier
names
starting
with
an
underscore
or
containing
double
underscores
incur
a
penalty
of
10
when
computing
their
length
top
item
stdin
Read
the
standard
input
as
a
script
file
rather
than
starting
an
interactive
session
top
notop
item
stop
after
var
pass
Stop
compilation
after
the
given
compilation
pass
The
currently
supported
passes
are
parsing
typing
nat
scheduling
emit
notop
item
strict
sequence
Force
the
left
hand
part
of
each
sequence
to
have
type
unit
item
strict
formats
Reject
invalid
formats
that
were
accepted
in
legacy
format
implementations
You
should
use
this
flag
to
detect
and
fix
such
invalid
formats
as
they
will
be
rejected
by
future
OCaml
versions
notop
item
unboxed
types
When
a
type
is
unboxable
i
e
a
record
with
a
single
argument
or
a
concrete
datatype
with
a
single
constructor
of
one
argument
it
will
be
unboxed
unless
annotated
with
ocaml
boxed
notop
notop
item
no
unboxed
types
When
a
type
is
unboxable
it
will
be
boxed
unless
annotated
with
ocaml
unboxed
This
is
the
default
notop
item
unsafe
Turn
bound
checking
off
for
array
and
string
accesses
the
v
i
and
s
i
constructs
Programs
compiled
with
unsafe
are
therefore
comp
slightly
faster
but
unsafe
anything
can
happen
if
the
program
accesses
an
array
or
string
outside
of
its
bounds
notop
Additionally
turn
off
the
check
for
zero
divisor
in
integer
division
and
modulus
operations
With
unsafe
an
integer
division
or
modulus
by
zero
can
halt
the
program
or
continue
with
an
unspecified
result
instead
of
raising
a
Division
by
zero
exception
notop
item
unsafe
string
Identify
the
types
string
and
bytes
thereby
making
strings
writable
This
is
intended
for
compatibility
with
old
source
code
and
should
not
be
used
with
new
software
This
option
raises
an
error
unconditionally
since
OCaml
5
0
comp
item
use
runtime
var
runtime
name
Generate
a
bytecode
executable
file
that
can
be
executed
on
the
custom
runtime
system
var
runtime
name
built
earlier
with
ocamlc
make
runtime
var
runtime
name
See
section
ref
ss
custom
runtime
for
more
information
comp
item
v
Print
the
version
number
of
the
compiler
and
the
location
of
the
standard
library
directory
then
exit
item
verbose
Print
all
external
commands
before
they
are
executed
nat
in
particular
invocations
of
the
assembler
C
compiler
and
linker
comp
in
particular
invocations
of
the
C
compiler
and
linker
in
custom
mode
Useful
to
debug
C
library
problems
notop
item
version
or
vnum
Print
the
version
number
of
the
compiler
in
short
form
e
g
3
11
0
then
exit
notop
top
item
version
Print
version
string
and
exit
item
vnum
Print
short
version
number
and
exit
item
no
version
Do
not
print
the
version
banner
at
startup
top
item
w
var
warning
list
Enable
disable
or
mark
as
fatal
the
warnings
specified
by
the
argument
var
warning
list
Each
warning
can
be
em
enabled
or
em
disabled
and
each
warning
can
be
em
fatal
or
em
non
fatal
If
a
warning
is
disabled
it
isn
t
displayed
and
doesn
t
affect
compilation
in
any
way
even
if
it
is
fatal
If
a
warning
is
enabled
it
is
displayed
normally
by
the
compiler
whenever
the
source
code
triggers
it
If
it
is
enabled
and
fatal
the
compiler
will
also
stop
with
an
error
after
displaying
it
The
var
warning
list
argument
is
a
sequence
of
warning
specifiers
with
no
separators
between
them
A
warning
specifier
is
one
of
the
following
begin
options
item
var
num
Enable
warning
number
var
num
item
var
num
Disable
warning
number
var
num
item
var
num
Enable
and
mark
as
fatal
warning
number
var
num
item
var
num1
var
num2
Enable
warnings
in
the
given
range
item
var
num1
var
num2
Disable
warnings
in
the
given
range
item
var
num1
var
num2
Enable
and
mark
as
fatal
warnings
in
the
given
range
item
var
letter
Enable
the
set
of
warnings
corresponding
to
var
letter
The
letter
may
be
uppercase
or
lowercase
item
var
letter
Disable
the
set
of
warnings
corresponding
to
var
letter
The
letter
may
be
uppercase
or
lowercase
item
var
letter
Enable
and
mark
as
fatal
the
set
of
warnings
corresponding
to
var
letter
The
letter
may
be
uppercase
or
lowercase
item
var
uppercase
letter
Enable
the
set
of
warnings
corresponding
to
var
uppercase
letter
item
var
lowercase
letter
Disable
the
set
of
warnings
corresponding
to
var
lowercase
letter
end
options
Alternatively
var
warning
list
can
specify
a
single
warning
using
its
mnemonic
name
see
below
as
follows
begin
options
item
var
name
Enable
warning
var
name
item
var
name
Disable
warning
var
name
item
var
name
Enable
and
mark
as
fatal
warning
var
name
end
options
Warning
numbers
letters
and
names
which
are
not
currently
defined
are
ignored
The
warnings
are
as
follows
the
name
following
each
number
specifies
the
mnemonic
for
that
warning
begin
options
input
warnings
help
tex
end
options
The
default
setting
is
w
a
4
6
7
9
27
29
32
42
44
45
48
50
60
It
is
displayed
by
machine
ocamlx
help
Note
that
warnings
5
and
10
are
not
always
triggered
depending
on
the
internals
of
the
type
checker
item
warn
error
var
warning
list
Mark
as
fatal
the
warnings
specified
in
the
argument
var
warning
list
The
compiler
will
stop
with
an
error
when
one
of
these
warnings
is
emitted
The
var
warning
list
has
the
same
meaning
as
for
the
w
option
a
sign
or
an
uppercase
letter
marks
the
corresponding
warnings
as
fatal
a
sign
or
a
lowercase
letter
turns
them
back
into
non
fatal
warnings
and
a
sign
both
enables
and
marks
as
fatal
the
corresponding
warnings
Note
it
is
not
recommended
to
use
warning
sets
i
e
letters
as
arguments
to
warn
error
in
production
code
because
this
can
break
your
build
when
future
versions
of
OCaml
add
some
new
warnings
The
default
setting
is
warn
error
a
no
warning
is
fatal
item
warn
help
Show
the
description
of
all
available
warning
numbers
notop
item
where
Print
the
location
of
the
standard
library
then
exit
notop
notop
item
with
runtime
The
pair
of
options
texttt
with
runtime
and
texttt
without
runtime
give
precise
control
over
the
way
the
runtime
is
linked
texttt
with
runtime
is
the
default
In
summary
it
instructs
to
include
the
runtime
system
or
a
reference
to
the
default
path
of
the
runtime
system
in
the
generated
program
executable
object
file
The
detailed
behaviour
depends
on
the
compiler
and
options
used
For
ocamlc
in
its
default
linking
mode
no
use
of
texttt
custom
or
texttt
output
texttt
with
runtime
creates
a
file
which
can
be
executed
whereas
texttt
without
runtime
creates
a
pure
bytecode
image
which
must
be
explicitly
passed
to
a
runtime
i
e
texttt
foo
vs
texttt
ocamlrun
foo
For
all
other
uses
of
ocamlc
and
ocamlopt
texttt
with
runtime
and
texttt
without
runtime
control
whether
the
compiler
passes
flags
for
linking
with
the
installed
runtime
texttt
with
runtime
or
whether
the
user
is
required
to
pass
them
texttt
without
runtime
For
more
information
about
the
options
texttt
custom
and
texttt
output
see
their
documentation
and
section
ref
ss
c
embedded
code
of
the
manual
notop
item
without
runtime
The
compiler
does
not
include
the
runtime
system
nor
a
reference
to
it
in
the
generated
program
executable
or
object
file
it
must
be
supplied
separately
See
option
texttt
with
runtime
for
details
item
var
file
notop
Process
var
file
as
a
file
name
even
if
it
starts
with
a
dash
character
top
Use
var
file
as
a
script
file
name
even
when
it
starts
with
a
hyphen
item
help
or
help
Display
a
short
usage
summary
and
exit
end
options
chapter
Batch
compilation
ocamlc
label
c
camlc
HEVEA
cutname
comp
html
This
chapter
describes
the
OCaml
batch
compiler
ocamlc
which
compiles
OCaml
source
files
to
bytecode
object
files
and
links
these
object
files
to
produce
standalone
bytecode
executable
files
These
executable
files
are
then
run
by
the
bytecode
interpreter
ocamlrun
section
s
comp
overview
Overview
of
the
compiler
The
ocamlc
command
has
a
command
line
interface
similar
to
the
one
of
most
C
compilers
It
accepts
several
types
of
arguments
and
processes
them
sequentially
after
all
options
have
been
processed
begin
itemize
item
Arguments
ending
in
mli
are
taken
to
be
source
files
for
compilation
unit
interfaces
Interfaces
specify
the
names
exported
by
compilation
units
they
declare
value
names
with
their
types
define
public
data
types
declare
abstract
data
types
and
so
on
From
the
file
var
x
mli
the
ocamlc
compiler
produces
a
compiled
interface
in
the
file
var
x
cmi
item
Arguments
ending
in
ml
are
taken
to
be
source
files
for
compilation
unit
implementations
Implementations
provide
definitions
for
the
names
exported
by
the
unit
and
also
contain
expressions
to
be
evaluated
for
their
side
effects
From
the
file
var
x
ml
the
ocamlc
compiler
produces
compiled
object
bytecode
in
the
file
var
x
cmo
If
the
interface
file
var
x
mli
exists
the
implementation
var
x
ml
is
checked
against
the
corresponding
compiled
interface
var
x
cmi
which
is
assumed
to
exist
If
no
interface
var
x
mli
is
provided
the
compilation
of
var
x
ml
produces
a
compiled
interface
file
var
x
cmi
in
addition
to
the
compiled
object
code
file
var
x
cmo
The
file
var
x
cmi
produced
corresponds
to
an
interface
that
exports
everything
that
is
defined
in
the
implementation
var
x
ml
item
Arguments
ending
in
cmo
are
taken
to
be
compiled
object
bytecode
These
files
are
linked
together
along
with
the
object
files
obtained
by
compiling
ml
arguments
if
any
and
the
OCaml
standard
library
to
produce
a
standalone
executable
program
The
order
in
which
cmo
and
ml
arguments
are
presented
on
the
command
line
is
relevant
compilation
units
are
initialized
in
that
order
at
run
time
and
it
is
a
link
time
error
to
use
a
component
of
a
unit
before
having
initialized
it
Hence
a
given
var
x
cmo
file
must
come
before
all
cmo
files
that
refer
to
the
unit
var
x
item
Arguments
ending
in
cma
are
taken
to
be
libraries
of
object
bytecode
A
library
of
object
bytecode
packs
in
a
single
file
a
set
of
object
bytecode
files
cmo
files
Libraries
are
built
with
ocamlc
a
see
the
description
of
the
a
option
below
The
object
files
contained
in
the
library
are
linked
as
regular
cmo
files
see
above
in
the
order
specified
when
the
cma
file
was
built
The
only
difference
is
that
if
an
object
file
contained
in
a
library
is
not
referenced
anywhere
in
the
program
then
it
is
not
linked
in
item
Arguments
ending
in
c
are
passed
to
the
C
compiler
which
generates
a
o
object
file
obj
under
Windows
This
object
file
is
linked
with
the
program
if
the
custom
flag
is
set
see
the
description
of
custom
below
item
Arguments
ending
in
o
or
a
obj
or
lib
under
Windows
are
assumed
to
be
C
object
files
and
libraries
They
are
passed
to
the
C
linker
when
linking
in
custom
mode
see
the
description
of
custom
below
item
Arguments
ending
in
so
dll
under
Windows
are
assumed
to
be
C
shared
libraries
DLLs
During
linking
they
are
searched
for
external
C
functions
referenced
from
the
OCaml
code
and
their
names
are
written
in
the
generated
bytecode
executable
The
run
time
system
ocamlrun
then
loads
them
dynamically
at
program
start
up
time
end
itemize
The
output
of
the
linking
phase
is
a
file
containing
compiled
bytecode
that
can
be
executed
by
the
OCaml
bytecode
interpreter
the
command
named
ocamlrun
If
a
out
is
the
name
of
the
file
produced
by
the
linking
phase
the
command
begin
alltt
ocamlrun
a
out
nth
arg
1
nth
arg
2
ldots
nth
arg
n
end
alltt
executes
the
compiled
code
contained
in
a
out
passing
it
as
arguments
the
character
strings
nth
arg
1
to
nth
arg
n
See
chapter
ref
c
runtime
for
more
details
On
most
systems
the
file
produced
by
the
linking
phase
can
be
run
directly
as
in
begin
alltt
a
out
nth
arg
1
nth
arg
2
ldots
nth
arg
n
end
alltt
The
produced
file
has
the
executable
bit
set
and
it
manages
to
launch
the
bytecode
interpreter
by
itself
The
compiler
is
able
to
emit
some
information
on
its
internal
stages
It
can
output
cmt
files
for
the
implementation
of
the
compilation
unit
and
cmti
for
signatures
if
the
option
bin
annot
is
passed
to
it
see
the
description
of
bin
annot
below
Each
such
file
contains
a
typed
abstract
syntax
tree
AST
that
is
produced
during
the
type
checking
procedure
This
tree
contains
all
available
information
about
the
location
and
the
specific
type
of
each
term
in
the
source
file
The
AST
is
partial
if
type
checking
was
unsuccessful
These
cmt
and
cmti
files
are
typically
useful
for
code
inspection
tools
section
s
comp
options
Options
The
following
command
line
options
are
recognized
by
ocamlc
The
options
pack
a
c
output
obj
and
output
complete
obj
are
mutually
exclusive
Define
boolean
variables
used
by
the
macros
in
unified
options
etex
newif
ifcomp
comptrue
newif
ifnat
natfalse
newif
iftop
topfalse
unified
options
gathers
all
options
across
the
native
bytecode
compilers
and
toplevel
input
unified
options
tex
paragraph
contextual
cli
control
Contextual
control
of
command
line
options
The
compiler
command
line
can
be
modified
from
the
outside
with
the
following
mechanisms
These
are
experimental
and
subject
to
change
They
should
be
used
only
for
experimental
and
development
work
not
in
released
packages
begin
options
item
OCAMLPARAM
rm
environment
variable
A
set
of
arguments
that
will
be
inserted
before
or
after
the
arguments
from
the
command
line
Arguments
are
specified
in
a
comma
separated
list
of
name
value
pairs
A
is
used
to
specify
the
position
of
the
command
line
arguments
i
e
a
x
b
y
means
that
a
x
should
be
executed
before
parsing
the
arguments
and
b
y
after
Finally
an
alternative
separator
can
be
specified
as
the
first
character
of
the
string
within
the
set
item
ocaml
compiler
internal
params
rm
file
in
the
stdlib
directory
A
mapping
of
file
names
to
lists
of
arguments
that
will
be
added
to
the
command
line
and
OCAMLPARAM
arguments
end
options
section
s
modules
file
system
Modules
and
the
file
system
This
short
section
is
intended
to
clarify
the
relationship
between
the
names
of
the
modules
corresponding
to
compilation
units
and
the
names
of
the
files
that
contain
their
compiled
interface
and
compiled
implementation
The
compiler
always
derives
the
module
name
by
taking
the
capitalized
base
name
of
the
source
file
ml
or
mli
file
That
is
it
strips
the
leading
directory
name
if
any
as
well
as
the
ml
or
mli
suffix
then
it
set
the
first
letter
to
uppercase
in
order
to
comply
with
the
requirement
that
module
names
must
be
capitalized
For
instance
compiling
the
file
mylib
misc
ml
provides
an
implementation
for
the
module
named
Misc
Other
compilation
units
may
refer
to
components
defined
in
mylib
misc
ml
under
the
names
Misc
var
name
they
can
also
do
open
Misc
then
use
unqualified
names
var
name
The
cmi
and
cmo
files
produced
by
the
compiler
have
the
same
base
name
as
the
source
file
Hence
the
compiled
files
always
have
their
base
name
equal
modulo
capitalization
of
the
first
letter
to
the
name
of
the
module
they
describe
for
cmi
files
or
implement
for
cmo
files
When
the
compiler
encounters
a
reference
to
a
free
module
identifier
Mod
it
looks
in
the
search
path
for
a
file
named
Mod
cmi
or
mod
cmi
and
loads
the
compiled
interface
contained
in
that
file
As
a
consequence
renaming
cmi
files
is
not
advised
the
name
of
a
cmi
file
must
always
correspond
to
the
name
of
the
compilation
unit
it
implements
It
is
admissible
to
move
them
to
another
directory
if
their
base
name
is
preserved
and
the
correct
I
options
are
given
to
the
compiler
The
compiler
will
flag
an
error
if
it
loads
a
cmi
file
that
has
been
renamed
Compiled
bytecode
files
cmo
files
on
the
other
hand
can
be
freely
renamed
once
created
That
s
because
the
linker
never
attempts
to
find
by
itself
the
cmo
file
that
implements
a
module
with
a
given
name
it
relies
instead
on
the
user
providing
the
list
of
cmo
files
by
hand
section
s
comp
errors
Common
errors
This
section
describes
and
explains
the
most
frequently
encountered
error
messages
begin
options
item
Cannot
find
file
var
filename
The
named
file
could
not
be
found
in
the
current
directory
nor
in
the
directories
of
the
search
path
The
var
filename
is
either
a
compiled
interface
file
cmi
file
or
a
compiled
bytecode
file
cmo
file
If
var
filename
has
the
format
var
mod
cmi
this
means
you
are
trying
to
compile
a
file
that
references
identifiers
from
module
var
mod
but
you
have
not
yet
compiled
an
interface
for
module
var
mod
Fix
compile
var
mod
mli
or
var
mod
ml
first
to
create
the
compiled
interface
var
mod
cmi
If
var
filename
has
the
format
var
mod
cmo
this
means
you
are
trying
to
link
a
bytecode
object
file
that
does
not
exist
yet
Fix
compile
var
mod
ml
first
If
your
program
spans
several
directories
this
error
can
also
appear
because
you
haven
t
specified
the
directories
to
look
into
Fix
add
the
correct
I
options
to
the
command
line
item
Corrupted
compiled
interface
var
filename
The
compiler
produces
this
error
when
it
tries
to
read
a
compiled
interface
file
cmi
file
that
has
the
wrong
structure
This
means
something
went
wrong
when
this
cmi
file
was
written
the
disk
was
full
the
compiler
was
interrupted
in
the
middle
of
the
file
creation
and
so
on
This
error
can
also
appear
if
a
cmi
file
is
modified
after
its
creation
by
the
compiler
Fix
remove
the
corrupted
cmi
file
and
rebuild
it
item
This
expression
has
type
nth
t
1
but
is
used
with
type
nth
t
2
This
is
by
far
the
most
common
type
error
in
programs
Type
nth
t
1
is
the
type
inferred
for
the
expression
the
part
of
the
program
that
is
displayed
in
the
error
message
by
looking
at
the
expression
itself
Type
nth
t
2
is
the
type
expected
by
the
context
of
the
expression
it
is
deduced
by
looking
at
how
the
value
of
this
expression
is
used
in
the
rest
of
the
program
If
the
two
types
nth
t
1
and
nth
t
2
are
not
compatible
then
the
error
above
is
produced
In
some
cases
it
is
hard
to
understand
why
the
two
types
nth
t
1
and
nth
t
2
are
incompatible
For
instance
the
compiler
can
report
that
expression
of
type
foo
cannot
be
used
with
type
foo
and
it
really
seems
that
the
two
types
foo
are
compatible
This
is
not
always
true
Two
type
constructors
can
have
the
same
name
but
actually
represent
different
types
This
can
happen
if
a
type
constructor
is
redefined
Example
begin
verbatim
type
foo
A
B
let
f
function
A
0
B
1
type
foo
C
D
f
C
end
verbatim
This
result
in
the
error
message
expression
C
of
type
foo
cannot
be
used
with
type
foo
item
The
type
of
this
expression
var
t
contains
type
variables
that
cannot
be
generalized
Type
variables
a
b
ldots
in
a
type
var
t
can
be
in
either
of
two
states
generalized
which
means
that
the
type
var
t
is
valid
for
all
possible
instantiations
of
the
variables
and
not
generalized
which
means
that
the
type
var
t
is
valid
only
for
one
instantiation
of
the
variables
In
a
let
binding
let
var
name
var
expr
the
type
checker
normally
generalizes
as
many
type
variables
as
possible
in
the
type
of
var
expr
However
this
leads
to
unsoundness
a
well
typed
program
can
crash
in
conjunction
with
polymorphic
mutable
data
structures
To
avoid
this
generalization
is
performed
at
let
bindings
only
if
the
bound
expression
var
expr
belongs
to
the
class
of
syntactic
values
which
includes
constants
identifiers
functions
tuples
of
syntactic
values
etc
In
all
other
cases
for
instance
var
expr
is
a
function
application
a
polymorphic
mutable
could
have
been
created
and
generalization
is
therefore
turned
off
for
all
variables
occurring
in
contravariant
or
non
variant
branches
of
the
type
For
instance
if
the
type
of
a
non
value
is
a
list
the
variable
is
generalizable
list
is
a
covariant
type
constructor
but
not
in
a
list
a
list
the
left
branch
of
is
contravariant
or
a
ref
ref
is
non
variant
Non
generalized
type
variables
in
a
type
cause
no
difficulties
inside
a
given
structure
or
compilation
unit
the
contents
of
a
ml
file
or
an
interactive
session
but
they
cannot
be
allowed
inside
signatures
nor
in
compiled
interfaces
cmi
file
because
they
could
be
used
inconsistently
later
Therefore
the
compiler
flags
an
error
when
a
structure
or
compilation
unit
defines
a
value
var
name
whose
type
contains
non
generalized
type
variables
There
are
two
ways
to
fix
this
error
begin
itemize
item
Add
a
type
constraint
or
a
mli
file
to
give
a
monomorphic
type
without
type
variables
to
var
name
For
instance
instead
of
writing
begin
verbatim
let
sort
int
list
List
sort
Stdlib
compare
inferred
type
a
list
a
list
with
a
not
generalized
end
verbatim
write
begin
verbatim
let
sort
int
list
List
sort
Stdlib
compare
int
list
int
list
end
verbatim
item
If
you
really
need
var
name
to
have
a
polymorphic
type
turn
its
defining
expression
into
a
function
by
adding
an
extra
parameter
For
instance
instead
of
writing
begin
verbatim
let
map
length
List
map
Array
length
inferred
type
a
array
list
int
list
with
a
not
generalized
end
verbatim
write
begin
verbatim
let
map
length
lv
List
map
Array
length
lv
end
verbatim
end
itemize
item
Reference
to
undefined
global
var
mod
This
error
appears
when
trying
to
link
an
incomplete
or
incorrectly
ordered
set
of
files
Either
you
have
forgotten
to
provide
an
implementation
for
the
compilation
unit
named
var
mod
on
the
command
line
typically
the
file
named
var
mod
cmo
or
a
library
containing
that
file
Fix
add
the
missing
ml
or
cmo
file
to
the
command
line
Or
you
have
provided
an
implementation
for
the
module
named
var
mod
but
it
comes
too
late
on
the
command
line
the
implementation
of
var
mod
must
come
before
all
bytecode
object
files
that
reference
var
mod
Fix
change
the
order
of
ml
and
cmo
files
on
the
command
line
Of
course
you
will
always
encounter
this
error
if
you
have
mutually
recursive
functions
across
modules
That
is
function
Mod1
f
calls
function
Mod2
g
and
function
Mod2
g
calls
function
Mod1
f
In
this
case
no
matter
what
permutations
you
perform
on
the
command
line
the
program
will
be
rejected
at
link
time
Fixes
begin
itemize
item
Put
f
and
g
in
the
same
module
item
Parameterize
one
function
by
the
other
That
is
instead
of
having
begin
verbatim
mod1
ml
let
f
x
Mod2
g
mod2
ml
let
g
y
Mod1
f
end
verbatim
define
begin
verbatim
mod1
ml
let
f
g
x
g
mod2
ml
let
rec
g
y
Mod1
f
g
end
verbatim
and
link
mod1
cmo
before
mod2
cmo
item
Use
a
reference
to
hold
one
of
the
two
functions
as
in
begin
verbatim
mod1
ml
let
forward
g
ref
fun
x
failwith
forward
g
type
let
f
x
forward
g
mod2
ml
let
g
y
Mod1
f
let
Mod1
forward
g
g
end
verbatim
end
itemize
item
The
external
function
var
f
is
not
available
This
error
appears
when
trying
to
link
code
that
calls
external
functions
written
in
C
As
explained
in
chapter
ref
c
intf
c
such
code
must
be
linked
with
C
libraries
that
implement
the
required
var
f
C
function
If
the
C
libraries
in
question
are
not
shared
libraries
DLLs
the
code
must
be
linked
in
custom
runtime
mode
Fix
add
the
required
C
libraries
to
the
command
line
and
possibly
the
custom
option
end
options
section
s
comp
warnings
Warning
reference
This
section
describes
and
explains
in
detail
some
warnings
subsection
ss
warn6
Warning
6
Label
omitted
in
function
application
OCaml
supports
labels
omitted
full
applications
if
the
function
has
a
known
arity
all
the
arguments
are
unlabeled
and
their
number
matches
the
number
of
non
optional
parameters
then
labels
are
ignored
and
non
optional
parameters
are
matched
in
their
definition
order
Optional
arguments
are
defaulted
begin
verbatim
let
f
x
y
x
y
let
test
f
2
3
let
test
f
2
3
Warning
6
labels
omitted
labels
x
y
were
omitted
in
the
application
of
this
function
end
verbatim
This
support
for
labels
omitted
application
was
introduced
when
labels
were
added
to
OCaml
to
ease
the
progressive
introduction
of
labels
in
a
codebase
However
it
has
the
downside
of
weakening
the
labeling
discipline
if
you
use
labels
to
prevent
callers
from
mistakenly
reordering
two
parameters
of
the
same
type
labels
omitted
make
this
mistake
possible
again
Warning
6
warns
when
labels
omitted
applications
are
used
to
discourage
their
use
When
labels
were
introduced
this
warning
was
not
enabled
by
default
so
users
would
use
labels
omitted
applications
often
without
noticing
Over
time
it
has
become
idiomatic
to
enable
this
warning
to
avoid
argument
order
mistakes
The
warning
is
now
on
by
default
since
OCaml
4
13
Labels
omitted
applications
are
not
recommended
anymore
but
users
wishing
to
preserve
this
transitory
style
can
disable
the
warning
explicitly
subsection
ss
warn9
Warning
9
missing
fields
in
a
record
pattern
When
pattern
matching
on
records
it
can
be
useful
to
match
only
few
fields
of
a
record
Eliding
fields
can
be
done
either
implicitly
or
explicitly
by
ending
the
record
pattern
with
However
implicit
field
elision
is
at
odd
with
pattern
matching
exhaustiveness
checks
Enabling
warning
9
prioritizes
exhaustiveness
checks
over
the
convenience
of
implicit
field
elision
and
will
warn
on
implicit
field
elision
in
record
patterns
In
particular
this
warning
can
help
to
spot
exhaustive
record
pattern
that
may
need
to
be
updated
after
the
addition
of
new
fields
to
a
record
type
begin
verbatim
type
a
point
x
a
y
a
let
dx
x
x
implicit
field
elision
trigger
warning
9
let
dy
y
y
explicit
field
elision
do
not
trigger
warning
9
end
verbatim
subsection
ss
warn52
Warning
52
fragile
constant
pattern
Some
constructors
such
as
the
exception
constructors
Failure
and
Invalid
argument
take
as
parameter
a
string
value
holding
a
text
message
intended
for
the
user
These
text
messages
are
usually
not
stable
over
time
call
sites
building
these
constructors
may
refine
the
message
in
a
future
version
to
make
it
more
explicit
etc
Therefore
it
is
dangerous
to
match
over
the
precise
value
of
the
message
For
example
until
OCaml
4
02
Array
iter2
would
raise
the
exception
begin
verbatim
Invalid
argument
arrays
must
have
the
same
length
end
verbatim
Since
4
03
it
raises
the
more
helpful
message
begin
verbatim
Invalid
argument
Array
iter2
arrays
must
have
the
same
length
end
verbatim
but
this
means
that
any
code
of
the
form
begin
verbatim
try
with
Invalid
argument
arrays
must
have
the
same
length
end
verbatim
is
now
broken
and
may
suffer
from
uncaught
exceptions
Warning
52
is
there
to
prevent
users
from
writing
such
fragile
code
in
the
first
place
It
does
not
occur
on
every
matching
on
a
literal
string
but
only
in
the
case
in
which
library
authors
expressed
their
intent
to
possibly
change
the
constructor
parameter
value
in
the
future
by
using
the
attribute
ocaml
warn
on
literal
pattern
see
the
manual
section
on
builtin
attributes
in
ref
ss
builtin
attributes
begin
caml
example
verbatim
warning
52
type
t
Foo
of
string
ocaml
warn
on
literal
pattern
Bar
of
string
let
no
warning
function
Bar
specific
value
0
1
let
warning
function
Foo
specific
value
0
1
end
caml
example
In
particular
all
built
in
exceptions
with
a
string
argument
have
this
attribute
set
Invalid
argument
Failure
Sys
error
will
all
raise
this
warning
if
you
match
for
a
specific
string
argument
Additionally
built
in
exceptions
with
a
structured
argument
that
includes
a
string
also
have
the
attribute
set
Assert
failure
and
Match
failure
will
raise
the
warning
for
a
pattern
that
uses
a
literal
string
to
match
the
first
element
of
their
tuple
argument
If
your
code
raises
this
warning
you
should
em
not
change
the
way
you
test
for
the
specific
string
to
avoid
the
warning
for
example
using
a
string
equality
inside
the
right
hand
side
instead
of
a
literal
pattern
as
your
code
would
remain
fragile
You
should
instead
enlarge
the
scope
of
the
pattern
by
matching
on
all
possible
values
begin
verbatim
let
warning
function
Foo
0
1
end
verbatim
This
may
require
some
care
if
the
scrutinee
may
return
several
different
cases
of
the
same
pattern
or
raise
distinct
instances
of
the
same
exception
you
may
need
to
modify
your
code
to
separate
those
several
cases
For
example
begin
verbatim
try
int
of
string
count
str
bool
of
string
choice
str
with
Failure
int
of
string
0
true
Failure
bool
of
string
1
false
end
verbatim
should
be
rewritten
into
more
atomic
tests
For
example
using
the
exception
patterns
documented
in
Section
ref
sss
exception
match
one
can
write
begin
verbatim
match
int
of
string
count
str
with
exception
Failure
0
true
count
begin
match
bool
of
string
choice
str
with
exception
Failure
1
false
choice
count
choice
end
end
verbatim
The
only
case
where
that
transformation
is
not
possible
is
if
a
given
function
call
may
raise
distinct
exceptions
with
the
same
constructor
but
different
string
values
In
this
case
you
will
have
to
check
for
specific
string
values
This
is
dangerous
API
design
and
it
should
be
discouraged
it
s
better
to
define
more
precise
exception
constructors
than
store
useful
information
in
strings
subsection
ss
warn57
Warning
57
Ambiguous
or
pattern
variables
under
guard
The
semantics
of
or
patterns
in
OCaml
is
specified
with
a
left
to
right
bias
a
value
var
v
matches
the
pattern
var
p
var
q
if
it
matches
var
p
or
var
q
but
if
it
matches
both
the
environment
captured
by
the
match
is
the
environment
captured
by
var
p
never
the
one
captured
by
var
q
While
this
property
is
generally
intuitive
there
is
at
least
one
specific
case
where
a
different
semantics
might
be
expected
Consider
a
pattern
followed
by
a
when
guard
var
p
when
var
g
var
e
for
example
begin
verbatim
Const
x
Const
x
when
is
neutral
x
branch
end
verbatim
The
semantics
is
clear
match
the
scrutinee
against
the
pattern
if
it
matches
test
the
guard
and
if
the
guard
passes
take
the
branch
In
particular
consider
the
input
Const
var
a
Const
var
b
where
var
a
fails
the
test
is
neutral
var
a
while
var
b
passes
the
test
is
neutral
var
b
With
the
left
to
right
semantics
the
clause
above
is
em
not
taken
by
its
input
matching
Const
var
a
Const
var
b
against
the
or
pattern
succeeds
in
the
left
branch
it
returns
the
environment
var
x
var
a
and
then
the
guard
is
neutral
var
a
is
tested
and
fails
the
branch
is
not
taken
However
another
semantics
may
be
considered
more
natural
here
any
pair
that
has
one
side
passing
the
test
will
take
the
branch
With
this
semantics
the
previous
code
fragment
would
be
equivalent
to
begin
verbatim
Const
x
when
is
neutral
x
branch
Const
x
when
is
neutral
x
branch
end
verbatim
This
is
em
not
the
semantics
adopted
by
OCaml
Warning
57
is
dedicated
to
these
confusing
cases
where
the
specified
left
to
right
semantics
is
not
equivalent
to
a
non
deterministic
semantics
any
branch
can
be
taken
relatively
to
a
specific
guard
More
precisely
it
warns
when
guard
uses
ambiguous
variables
that
are
bound
to
different
parts
of
the
scrutinees
by
different
sides
of
a
or
pattern
subsection
ss
warn74
Warning
74
Pattern
matching
degraded
to
partial
The
OCaml
type
checker
performs
a
totality
analysis
to
distinguish
matches
that
are
total
all
possible
input
values
are
handled
by
a
clause
from
matches
that
are
partial
some
values
may
match
none
of
the
clause
and
raise
a
Match
failure
exception
Total
matches
generate
slightly
better
code
There
are
a
few
rare
situations
where
this
totality
analysis
can
be
wrong
the
type
checker
believes
the
pattern
matching
to
be
total
but
certain
values
may
try
clauses
in
order
and
fail
to
match
any
of
them
When
the
pattern
matching
compiler
detects
that
it
may
be
in
this
situation
it
conservatively
compiles
the
pattern
matching
as
partial
and
emits
this
warning
In
some
cases
this
conservative
assumption
is
necessary
the
pattern
matching
was
partial
and
in
some
other
cases
it
is
in
fact
overly
conservative
a
more
fine
grained
analysis
would
see
that
it
is
in
fact
total
This
situation
happens
rarely
the
only
known
case
requires
matching
on
mutable
fields
Moreover
the
vast
majority
of
programs
will
see
no
performance
difference
at
all
if
it
were
to
happen
For
these
reasons
the
warning
is
disabled
by
default
we
believe
that
the
right
approach
when
this
situation
occurs
is
to
do
nothing
at
all
However
some
expert
users
might
still
be
interested
in
finding
out
whether
some
pattern
matchings
in
their
codebase
may
be
affected
by
this
issue
for
two
reasons
begin
enumerate
item
Users
may
want
to
reason
with
certainty
about
which
parts
of
the
code
may
raise
a
Match
failure
exception
item
Performance
conscious
expert
users
might
want
to
inspect
the
dlambda
generated
code
if
the
affected
pattern
matching
is
in
a
performance
critical
section
end
enumerate
In
the
rest
of
this
section
we
explain
the
only
known
situation
where
this
pessimization
occurs
paragraph
Repeated
matches
in
mutable
positions
When
a
pattern
matching
contains
patterns
on
mutable
fields
it
is
possible
in
theory
that
the
value
of
these
fields
may
be
mutated
concurrently
with
the
matching
logic
and
this
mutation
the
remaining
clauses
failing
to
match
even
though
the
pattern
matching
appears
to
be
total
it
does
not
raise
warning
8
Consider
for
example
begin
verbatim
let
f
bool
bool
ref
unit
function
true
contents
true
r
when
r
contents
true
false
assert
false
false
contents
false
let
f
true
ref
false
Exception
Match
failure
end
verbatim
The
OCaml
type
checker
performs
its
totality
analysis
without
considering
the
possibility
of
concurrent
mutations
of
the
scrutinee
and
it
believes
that
the
function
f
is
total
The
function
f
emph
is
partial
due
to
side
effects
on
mutable
fields
Note
that
the
following
version
may
also
be
affected
begin
verbatim
let
g
bool
bool
ref
unit
function
true
contents
true
false
contents
false
end
verbatim
In
this
example
there
is
no
when
guard
mutating
the
scrutinee
but
it
is
possible
that
a
data
race
coming
from
another
domain
would
mutate
the
second
field
of
the
input
at
exactly
the
wrong
time
resulting
in
the
same
Match
failure
behavior
In
other
words
the
function
g
emph
might
be
partial
in
presence
of
side
effects
on
mutable
fields
Most
patterns
with
mutable
fields
are
emph
not
affected
by
this
issue
because
their
mutable
field
is
read
only
once
by
the
control
flow
code
generated
by
the
pattern
matching
compiler
For
example
the
following
simplification
of
our
example
does
emph
not
suffer
from
this
issue
begin
verbatim
let
h
bool
ref
unit
function
contents
true
r
when
r
contents
true
false
assert
false
contents
false
end
verbatim
Whether
a
mutable
field
will
be
read
once
or
several
times
depends
on
the
implementation
of
the
pattern
matching
compiler
it
is
not
a
property
of
the
source
level
pattern
matching
When
the
compiler
detects
that
this
situation
is
possible
that
the
pattern
emph
is
partial
or
that
it
emph
might
be
partial
as
in
the
examples
above
it
will
raise
warning
74
if
enabled
Note
this
warning
was
introduced
in
OCaml
5
3
earlier
versions
of
the
OCaml
compiler
would
not
warn
and
they
would
not
ensure
that
a
Match
failure
case
is
generated
in
such
cases
they
would
generate
slightly
more
efficient
but
incorrect
code
that
could
violate
type
and
memory
safety
in
the
case
of
concurrent
mutation
during
matching
chapter
Runtime
detection
of
data
races
with
ThreadSanitizer
label
c
tsan
cutname
tsan
html
HEVEA
cutname
tsan
html
section
s
tsan
overview
Overview
and
usage
OCaml
since
version
5
0
allows
shared
memory
parallelism
and
thus
mutation
of
data
shared
between
multiple
threads
This
creates
the
possibility
of
data
races
i
e
unordered
accesses
to
the
same
memory
location
with
at
least
one
of
them
being
a
write
In
OCaml
data
races
are
easy
to
introduce
and
the
behaviour
of
programs
with
data
races
can
be
unintuitive

the
observed
behaviours
cannot
be
explained
by
simply
interleaving
operations
from
different
concurrent
threads
More
information
about
data
races
and
their
consequences
can
be
found
in
section
ref
s
par
mm
easy
and
Chapter
ref
c
memorymodel
To
help
detect
data
races
OCaml
supports
ThreadSantizer
TSan
a
dynamic
data
race
detector
that
has
been
successfully
used
in
languages
such
as
C
C
Swift
etc
TSan
support
for
OCaml
is
available
since
OCaml
5
2
To
use
TSan
you
must
configure
the
compiler
with
texttt
enable
tsan
You
can
also
install
an
texttt
opam
switch
with
the
TSan
feature
enabled
as
follows
begin
verbatim
opam
switch
create
YOUR
SWITCH
NAME
HERE
ocaml
option
tsan
end
verbatim
TSan
support
for
OCaml
is
currently
available
for
the
x86
64
architecture
on
FreeBSD
Linux
and
macOS
for
the
arm64
architecture
on
Linux
and
macOS
and
for
the
POWER
riscv
and
s390x
architectures
on
Linux
Building
OCaml
with
TSan
support
requires
GCC
or
Clang
Minimal
supported
versions
are
GCC
11
and
Clang
14
Note
that
TSan
data
race
reports
with
GCC
11
are
known
to
result
in
poor
stack
trace
reporting
no
line
numbers
which
is
fixed
in
GCC
12
A
TSan
enabled
compiler
differs
from
a
regular
compiler
in
the
following
way
all
programs
compiled
by
texttt
ocamlopt
are
instrumented
with
calls
to
the
TSan
runtime
and
TSan
will
detect
data
races
encountered
during
execution
For
instance
consider
the
following
program
begin
caml
example
verbatim
let
a
ref
0
and
b
ref
0
let
d1
a
1
b
let
d2
b
1
a
let
let
h
Domain
spawn
d2
in
let
r1
d1
in
let
r2
Domain
join
h
in
assert
not
r1
0
r2
0
end
caml
example
This
program
has
data
races
The
memory
locations
texttt
a
and
texttt
b
are
read
and
written
concurrently
by
multiple
domains
texttt
d1
and
texttt
d2
texttt
a
and
texttt
b
are
non
atomic
locations
according
to
the
memory
model
see
Chapter
ref
c
memorymodel
and
there
is
no
synchronization
between
accesses
to
them
Hence
there
are
two
data
races
here
corresponding
to
the
two
memory
locations
texttt
a
and
texttt
b
When
you
compile
and
run
this
program
with
texttt
ocamlopt
you
may
observe
data
race
reports
on
the
standard
error
such
as
begin
verbatim
WARNING
ThreadSanitizer
data
race
pid
3808831
Write
of
size
8
at
0x8febe0
by
thread
T1
mutexes
write
M90
0
camlSimple
race
d2
274
simple
race
ml
8
simple
race
exe
0x420a72
1
camlDomain
body
706
stdlib
domain
ml
211
simple
race
exe
0x440f2f
2
caml
start
program
null
simple
race
exe
0x47cf37
3
caml
callback
exn
runtime
callback
c
197
simple
race
exe
0x445f7b
4
domain
thread
func
runtime
domain
c
1167
simple
race
exe
0x44a113
Previous
read
of
size
8
at
0x8febe0
by
main
thread
mutexes
write
M86
0
camlSimple
race
d1
271
simple
race
ml
5
simple
race
exe
0x420a22
1
camlSimple
race
entry
simple
race
ml
13
simple
race
exe
0x420d16
2
caml
program
null
simple
race
exe
0x41ffb9
3
caml
start
program
null
simple
race
exe
0x47cf37
WARNING
ThreadSanitizer
data
race
pid
3808831
Read
of
size
8
at
0x8febf0
by
thread
T1
mutexes
write
M90
0
camlSimple
race
d2
274
simple
race
ml
9
simple
race
exe
0x420a92
1
camlDomain
body
706
stdlib
domain
ml
211
simple
race
exe
0x440f2f
2
caml
start
program
null
simple
race
exe
0x47cf37
3
caml
callback
exn
runtime
callback
c
197
simple
race
exe
0x445f7b
4
domain
thread
func
runtime
domain
c
1167
simple
race
exe
0x44a113
Previous
write
of
size
8
at
0x8febf0
by
main
thread
mutexes
write
M86
0
camlSimple
race
d1
271
simple
race
ml
4
simple
race
exe
0x420a01
1
camlSimple
race
entry
simple
race
ml
13
simple
race
exe
0x420d16
2
caml
program
null
simple
race
exe
0x41ffb9
3
caml
start
program
null
simple
race
exe
0x47cf37
ThreadSanitizer
reported
2
warnings
end
verbatim
For
each
detected
data
race
TSan
reports
the
location
of
the
conflicting
accesses
their
nature
read
write
atomic
read
etc
and
the
associated
stack
trace
If
you
run
the
above
program
several
times
the
output
may
vary
sometimes
TSan
will
report
two
data
races
sometimes
one
and
sometimes
none
This
is
due
to
the
combination
of
two
factors
begin
itemize
item
First
TSan
reports
only
the
data
races
encountered
during
execution
i
e
conflicting
unordered
memory
accesses
that
are
effectively
performed
item
In
addition
in
this
program
depending
on
executions
there
may
be
no
such
memory
accesses
if
texttt
d1
returns
before
texttt
d2
has
finished
spawning
then
all
memory
accesses
originating
from
texttt
d1
may
happen
before
the
ones
originating
from
texttt
d2
since
spawning
a
domain
involves
inter
thread
synchronization
In
that
case
the
accesses
are
considered
to
be
ordered
and
no
data
race
is
reported
end
itemize
This
example
illustrates
the
fact
that
data
races
can
sometimes
be
hidden
by
unrelated
synchronizing
operations
section
s
tsan
performance
Performance
implications
TSan
instrumentation
imposes
a
non
negligible
cost
at
runtime
Empirically
this
cost
has
been
observed
to
cause
a
slowdown
which
can
range
from
2x
to
7x
One
of
the
main
factors
of
high
slowdowns
is
frequent
access
to
mutable
data
In
contrast
the
initialising
writes
to
and
reads
from
immutable
memory
locations
are
not
instrumented
TSan
also
allocates
very
large
amounts
of
virtual
memory
although
it
uses
only
a
fraction
of
it
The
memory
consumption
is
increased
by
a
factor
between
4
and
7
section
s
tsan
false
neg
false
pos
False
negatives
and
false
positives
As
illustrated
by
the
previous
example
TSan
will
only
report
the
data
races
encountered
during
execution
Another
important
caveat
is
that
TSan
remembers
only
a
finite
number
of
memory
accesses
per
memory
location
At
the
time
of
writing
this
number
is
4
Data
races
involving
a
forgotten
access
will
not
be
detected
Lastly
the
href
https
github
com
google
sanitizers
wiki
ThreadSanitizerAlgorithm
documentation
of
TSan
states
that
there
is
a
tiny
probability
to
miss
a
race
if
two
threads
access
the
same
location
at
the
same
time
TSan
may
overlook
data
races
only
in
these
three
specific
cases
For
data
races
between
two
memory
accesses
made
from
OCaml
code
TSan
does
not
produce
false
positives
that
is
TSan
will
not
emit
spurious
reports
When
mixing
OCaml
and
C
code
through
the
use
of
C
primitives
the
very
notion
of
false
positive
becomes
less
clear
as
it
involves
two
memory
models
OCaml
and
C11
However
TSan
should
behave
mostly
as
one
would
expect
non
atomic
reads
and
writes
in
C
will
race
with
non
atomic
reads
and
writes
in
OCaml
and
C
atomics
will
not
race
with
OCaml
atomics
There
is
one
theoretical
possibility
of
false
positive
if
a
texttt
value
is
initialized
from
C
without
using
texttt
caml
initialize
which
is
allowed
under
the
condition
that
the
GC
does
not
run
between
the
allocation
and
the
write
see
Chapter
ref
c
intf
c
and
a
conflicting
access
is
made
later
by
another
thread
This
does
not
constitute
a
data
race
but
TSan
may
report
it
as
such
section
s
tsan
runtime
flags
Runtime
options
TSan
supports
a
number
of
configuration
options
at
runtime
using
the
texttt
TSAN
OPTIONS
environment
variable
texttt
TSAN
OPTIONS
should
contain
one
or
more
options
separated
by
spaces
See
the
href
https
github
com
google
sanitizers
wiki
ThreadSanitizerFlags
documentation
of
TSan
flags
and
the
href
https
github
com
google
sanitizers
wiki
SanitizerCommonFlags
documentation
of
flags
common
to
all
sanitizers
for
more
information
Notably
texttt
TSAN
OPTIONS
allows
suppressing
some
data
races
from
TSan
reports
Suppressing
data
race
reports
is
useful
for
intentional
races
or
libraries
that
cannot
be
fixed
For
example
to
suppress
reports
originating
from
functions
in
the
OCaml
module
texttt
My
module
one
can
run
begin
verbatim
TSAN
OPTIONS
suppressions
suppr
txt
my
instrumented
program
end
verbatim
with
texttt
suppr
txt
a
file
containing
begin
verbatim
race
top
camlMy
module
end
verbatim
Note
that
this
depends
on
the
format
of
OCaml
symbols
in
the
executable
Some
builders
like
Dune
might
result
in
different
formats
You
should
adapt
this
example
to
the
symbols
effectively
present
in
your
stack
traces
The
texttt
TSAN
OPTIONS
variable
also
allows
for
increasing
the
history
size
e
g
begin
verbatim
TSAN
OPTIONS
history
size
7
my
instrumented
program
end
verbatim
TSans
history
records
events
such
as
function
entry
and
exit
and
is
used
to
reconstruct
stack
traces
Increasing
the
history
size
can
sometimes
be
necessary
to
obtain
the
second
stack
trace
but
it
also
increases
memory
consumption
This
setting
does
not
change
the
number
of
memory
accesses
remembered
per
memory
location
Another
useful
runtime
option
is
texttt
exitcode
0
which
still
reports
data
races
but
does
not
change
the
exit
code
This
can
be
useful
if
TSan
complains
about
data
races
in
programs
that
you
don
t
care
about
and
the
non
zero
exit
code
disturbs
your
workflow
section
s
tsan
c
code
Guidelines
for
linking
As
a
general
rule
OCaml
programs
instrumented
with
TSan
should
only
be
linked
with
OCaml
or
C
objects
also
instrumented
with
TSan
Doing
otherwise
may
result
in
crashes
The
only
exception
to
this
rule
are
C
libraries
that
do
not
call
into
the
OCaml
runtime
system
in
any
way
i
e
do
not
allocate
raise
exceptions
call
back
into
OCaml
code
etc
Examples
include
the
libc
or
system
libraries
Data
races
in
non
instrumented
libraries
will
not
be
reported
C
code
interacting
with
OCaml
should
always
be
built
through
the
texttt
ocamlopt
command
which
will
pass
the
required
instrumentation
flags
to
the
C
compiler
The
texttt
CAMLno
tsan
qualifier
can
be
used
to
prevent
functions
from
being
instrumented
begin
verbatim
CAMLno
tsan
void
f
int
arg
This
function
will
not
be
instrumented
end
verbatim
Races
from
non
instrumented
functions
will
not
be
reported
texttt
CAMLno
tsan
should
only
be
used
by
experts
It
can
be
used
to
reduce
the
performance
overhead
in
certain
corner
cases
or
to
suppress
some
known
alarms
For
the
latter
using
a
suppressions
file
with
texttt
TSAN
OPTIONS
should
be
preferred
when
possible
as
it
allows
for
finer
grained
control
and
qualifying
a
function
texttt
f
with
texttt
CAMLno
tsan
results
in
missing
entries
in
TSans
stack
traces
when
a
data
race
happens
in
a
transitive
callee
of
texttt
f
There
is
no
way
to
disable
instrumentation
in
OCaml
code
section
s
tsan
signal
changes
Changes
in
the
delivery
of
signals
TSan
intercepts
all
signals
and
passes
them
down
to
the
instrumented
program
This
overlay
from
TSan
is
not
always
transparent
for
the
program
Synchronous
signals
such
as
texttt
SIGSEV
texttt
SIGILL
texttt
SIGBUS
etc
will
be
passed
down
immediately
whereas
asynchronous
signals
such
as
texttt
SIGINT
will
be
delayed
until
the
next
call
to
the
TSan
runtime
e
g
until
the
next
access
to
mutable
data
This
limitation
of
TSan
can
have
surprising
effects
for
instance
pure
recursive
functions
that
do
not
allocate
cannot
be
interrupted
until
they
terminate
chapter
Fuzzing
with
afl
fuzz
HEVEA
cutname
afl
fuzz
html
section
s
afl
overview
Overview
American
fuzzy
lop
afl
fuzz
is
a
em
fuzzer
a
tool
for
testing
software
by
providing
randomly
generated
inputs
searching
for
those
inputs
which
cause
the
program
to
crash
Unlike
most
fuzzers
afl
fuzz
observes
the
internal
behaviour
of
the
program
being
tested
and
adjusts
the
test
cases
it
generates
to
trigger
unexplored
execution
paths
As
a
result
test
cases
generated
by
afl
fuzz
cover
more
of
the
possible
behaviours
of
the
tested
program
than
other
fuzzers
This
requires
that
programs
to
be
tested
are
instrumented
to
communicate
with
afl
fuzz
The
native
code
compiler
ocamlopt
can
generate
such
instrumentation
allowing
afl
fuzz
to
be
used
against
programs
written
in
OCaml
For
more
information
on
afl
fuzz
see
the
website
at
ifouthtml
ahref
http
lcamtuf
coredump
cx
afl
http
lcamtuf
coredump
cx
afl
else
tt
http
lcamtuf
coredump
cx
afl
fi
section
s
afl
generate
Generating
instrumentation
The
instrumentation
that
afl
fuzz
requires
is
not
generated
by
default
and
must
be
explicitly
enabled
by
passing
the
tt
afl
instrument
option
to
tt
ocamlopt
To
fuzz
a
large
system
without
modifying
build
tools
OCaml
s
tt
configure
script
also
accepts
the
tt
afl
instrument
option
If
OCaml
is
configured
with
tt
afl
instrument
then
all
programs
compiled
by
tt
ocamlopt
will
be
instrumented
subsection
ss
afl
advanced
Advanced
options
In
rare
cases
it
is
useful
to
control
the
amount
of
instrumentation
generated
By
passing
the
tt
afl
inst
ratio
N
argument
to
tt
ocamlopt
with
tt
N
less
than
100
instrumentation
can
be
generated
for
only
N
of
branches
See
the
afl
fuzz
documentation
on
the
parameter
tt
AFL
INST
RATIO
for
the
precise
effect
of
this
section
s
afl
example
Example
As
an
example
we
fuzz
test
the
following
program
tt
readline
ml
begin
verbatim
let
let
s
read
line
in
match
Array
to
list
Array
init
String
length
s
String
get
s
with
s
e
c
r
e
t
c
o
d
e
failwith
uh
oh
end
verbatim
There
is
a
single
input
the
string
secret
code
which
causes
this
program
to
crash
but
finding
it
by
blind
random
search
is
infeasible
Instead
we
compile
with
afl
fuzz
instrumentation
enabled
begin
verbatim
ocamlopt
afl
instrument
readline
ml
o
readline
end
verbatim
Next
we
run
the
program
under
afl
fuzz
begin
verbatim
mkdir
input
echo
asdf
input
testcase
mkdir
output
afl
fuzz
m
none
i
input
o
output
readline
end
verbatim
By
inspecting
instrumentation
output
the
fuzzer
finds
the
crashing
input
quickly
Note
To
fuzz
test
an
OCaml
program
with
afl
fuzz
passing
the
option
tt
m
none
is
required
to
disable
afl
fuzz
s
default
50MB
virtual
memory
limit
chapter
The
runtime
system
ocamlrun
label
c
runtime
HEVEA
cutname
runtime
html
The
ocamlrun
command
executes
bytecode
files
produced
by
the
linking
phase
of
the
ocamlc
command
section
s
ocamlrun
overview
Overview
The
ocamlrun
command
comprises
three
main
parts
the
bytecode
interpreter
that
actually
executes
bytecode
files
the
memory
allocator
and
garbage
collector
and
a
set
of
C
functions
that
implement
primitive
operations
such
as
input
output
The
usage
for
ocamlrun
is
begin
alltt
ocamlrun
var
options
var
bytecode
executable
nth
arg
1
nth
arg
n
end
alltt
The
first
non
option
argument
is
taken
to
be
the
name
of
the
file
containing
the
executable
bytecode
That
file
is
searched
in
the
executable
path
as
well
as
in
the
current
directory
The
remaining
arguments
are
passed
to
the
OCaml
program
in
the
string
array
Sys
argv
Element
0
of
this
array
is
the
name
of
the
bytecode
executable
file
elements
1
to
var
n
are
the
remaining
arguments
nth
arg
1
to
nth
arg
n
As
mentioned
in
chapter
ref
c
camlc
the
bytecode
executable
files
produced
by
the
ocamlc
command
are
self
executable
and
manage
to
launch
the
ocamlrun
command
on
themselves
automatically
That
is
assuming
a
out
is
a
bytecode
executable
file
begin
alltt
a
out
nth
arg
1
nth
arg
n
end
alltt
works
exactly
as
begin
alltt
ocamlrun
a
out
nth
arg
1
nth
arg
n
end
alltt
Notice
that
it
is
not
possible
to
pass
options
to
ocamlrun
when
invoking
a
out
directly
begin
windows
Under
several
versions
of
Windows
bytecode
executable
files
are
self
executable
only
if
their
name
ends
in
exe
It
is
recommended
to
always
give
exe
names
to
bytecode
executables
e
g
compile
with
ocamlc
o
myprog
exe
rather
than
ocamlc
o
myprog
end
windows
section
s
ocamlrun
options
Options
The
following
command
line
options
are
recognized
by
ocamlrun
begin
options
item
b
When
the
program
aborts
due
to
an
uncaught
exception
print
a
detailed
back
trace
of
the
execution
showing
where
the
exception
was
raised
and
which
function
calls
were
outstanding
at
this
point
The
back
trace
is
printed
only
if
the
bytecode
executable
contains
debugging
information
i
e
was
compiled
and
linked
with
the
g
option
to
ocamlc
set
This
is
equivalent
to
setting
the
b
flag
in
the
OCAMLRUNPARAM
environment
variable
see
below
item
config
Print
the
version
number
of
ocamlrun
and
a
detailed
summary
of
its
configuration
then
exit
item
I
var
dir
Search
the
directory
var
dir
for
dynamically
loaded
libraries
in
addition
to
the
standard
search
path
see
section
ref
s
ocamlrun
dllpath
item
m
Print
the
magic
number
of
the
bytecode
executable
given
as
argument
and
exit
item
M
Print
the
magic
number
expected
for
bytecode
executables
by
this
version
of
the
runtime
and
exit
item
p
Print
the
names
of
the
primitives
known
to
this
version
of
ocamlrun
and
exit
item
t
Increments
the
trace
level
for
the
debug
runtime
ignored
otherwise
item
v
Direct
the
memory
manager
to
print
some
progress
messages
on
standard
error
This
is
equivalent
to
setting
v
61
in
the
OCAMLRUNPARAM
environment
variable
see
below
item
version
Print
version
string
and
exit
item
vnum
Print
short
version
number
and
exit
end
options
noindent
The
following
environment
variables
are
also
consulted
begin
options
item
CAML
LD
LIBRARY
PATH
Additional
directories
to
search
for
dynamically
loaded
libraries
see
section
ref
s
ocamlrun
dllpath
item
OCAMLLIB
The
directory
containing
the
OCaml
standard
library
If
OCAMLLIB
is
not
set
CAMLLIB
will
be
used
instead
Used
to
locate
the
ld
conf
configuration
file
for
dynamic
loading
see
section
ref
s
ocamlrun
dllpath
If
not
set
default
to
the
library
directory
specified
when
compiling
OCaml
item
OCAMLRUNPARAM
Set
the
runtime
system
options
and
garbage
collection
parameters
If
OCAMLRUNPARAM
is
not
set
CAMLRUNPARAM
will
be
used
instead
This
variable
must
be
a
sequence
of
parameter
specifications
separated
by
commas
For
convenience
commas
at
the
beginning
of
the
variable
are
ignored
and
multiple
runs
of
commas
are
interpreted
as
a
single
one
A
parameter
specification
is
an
option
letter
followed
by
an
sign
a
decimal
number
or
an
hexadecimal
number
prefixed
by
0x
and
an
optional
multiplier
The
options
are
documented
below
the
options
l
m
M
n
o
s
v
correspond
to
fields
of
the
control
record
documented
in
ifouthtml
ahref
libref
Gc
html
Module
texttt
Gc
else
section
ref
Gc
fi
begin
options
item
b
backtrace
Trigger
the
printing
of
a
stack
backtrace
when
an
uncaught
exception
aborts
the
program
An
optional
argument
can
be
provided
b
0
turns
backtrace
printing
off
b
1
is
equivalent
to
b
and
turns
backtrace
printing
on
b
2
turns
backtrace
printing
on
and
forces
the
runtime
system
to
load
debugging
information
at
program
startup
time
instead
of
at
backtrace
printing
time
b
2
can
be
used
if
the
runtime
is
unable
to
load
debugging
information
at
backtrace
printing
time
for
example
if
there
are
no
file
descriptors
available
item
c
cleanup
on
exit
Shut
the
runtime
down
gracefully
on
exit
see
caml
shutdown
in
section
ref
ss
c
embedded
code
The
option
also
enables
pooling
as
in
caml
startup
pooled
This
mode
can
be
used
to
detect
leaks
with
a
third
party
memory
debugger
item
d
max
domains
Maximum
number
of
domains
that
can
be
active
concurrently
Defaults
to
128
on
64
bit
platforms
and
16
on
32
bit
platforms
item
e
runtime
events
log
wsize
Size
of
the
per
domain
runtime
events
ring
buffers
in
log
powers
of
two
words
Defaults
to
16
giving
64k
word
or
512kb
buffers
on
64
bit
systems
item
l
stack
limit
The
limit
in
words
of
the
stack
size
This
is
relevant
to
both
the
byte
code
runtime
and
the
native
code
runtime
OCaml
always
uses
its
own
stack
and
not
the
operating
system
s
stack
item
m
custom
minor
ratio
Bound
on
floating
garbage
for
out
of
heap
memory
held
by
custom
values
in
the
minor
heap
A
minor
GC
is
triggered
when
this
much
memory
is
held
by
custom
values
located
in
the
minor
heap
Expressed
as
a
percentage
of
minor
heap
size
Default
100
Note
this
only
applies
to
values
allocated
with
caml
alloc
custom
mem
item
M
custom
major
ratio
Target
ratio
of
floating
garbage
to
major
heap
size
for
out
of
heap
memory
held
by
custom
values
e
g
bigarrays
located
in
the
major
heap
The
GC
speed
is
adjusted
to
try
to
use
this
much
memory
for
dead
values
that
are
not
yet
collected
Expressed
as
a
percentage
of
major
heap
size
Default
44
Note
this
only
applies
to
values
allocated
with
caml
alloc
custom
mem
item
n
custom
minor
max
size
Maximum
amount
of
out
of
heap
memory
for
each
custom
value
allocated
in
the
minor
heap
When
a
custom
value
is
allocated
on
the
minor
heap
and
holds
more
than
this
many
bytes
only
this
value
is
counted
against
custom
minor
ratio
and
the
rest
is
directly
counted
against
custom
major
ratio
Default
8192
bytes
Note
this
only
applies
to
values
allocated
with
caml
alloc
custom
mem
end
options
The
multiplier
is
k
M
or
G
for
multiplication
by
2
10
2
20
and
2
30
respectively
item
o
space
overhead
The
major
GC
speed
setting
See
the
Gc
module
documentation
for
details
item
p
parser
trace
Turn
on
debugging
support
for
ocamlyacc
generated
parsers
When
this
option
is
on
the
pushdown
automaton
that
executes
the
parsers
prints
a
trace
of
its
actions
This
option
takes
no
argument
item
R
randomize
Turn
on
randomization
of
all
hash
tables
by
default
see
ifouthtml
ahref
libref
Hashtbl
html
Module
texttt
Hashtbl
else
section
ref
Hashtbl
fi
This
option
takes
no
argument
item
s
minor
heap
size
Size
of
the
minor
heap
in
words
item
t
Set
the
trace
level
for
the
debug
runtime
ignored
by
the
standard
runtime
item
v
verbose
What
GC
messages
to
print
to
stderr
This
is
a
sum
of
values
selected
from
the
following
begin
options
item
1
0x001
Start
and
end
of
major
GC
cycle
item
2
0x002
Minor
collection
and
major
GC
slice
item
4
0x004
Growing
and
shrinking
of
the
heap
item
8
0x008
Resizing
of
stacks
and
memory
manager
tables
item
16
0x010
Heap
compaction
item
32
0x020
Change
of
GC
parameters
item
64
0x040
Computation
of
major
GC
slice
size
item
128
0x080
Calling
of
finalization
functions
item
256
0x100
Startup
messages
loading
the
bytecode
executable
file
resolving
shared
libraries
item
512
0x200
Computation
of
compaction
triggering
condition
item
1024
0x400
Output
GC
statistics
at
program
exit
item
2048
0x800
GC
debugging
messages
item
4096
0x1000
Address
space
reservation
changes
end
options
item
V
verify
heap
runs
an
integrity
check
on
the
heap
just
after
the
completion
of
a
major
GC
cycle
item
W
Print
runtime
warnings
to
stderr
such
as
Channel
opened
on
file
dies
without
being
closed
unflushed
data
etc
If
the
option
letter
is
not
recognized
the
whole
parameter
is
ignored
if
the
equal
sign
or
the
number
is
missing
the
value
is
taken
as
1
if
the
multiplier
is
not
recognized
it
is
ignored
For
example
on
a
32
bit
machine
under
bash
the
command
begin
verbatim
export
OCAMLRUNPARAM
b
s
256k
v
0x015
end
verbatim
tells
a
subsequent
ocamlrun
to
print
backtraces
for
uncaught
exceptions
set
its
initial
minor
heap
size
to
1
megabyte
and
print
a
message
at
the
start
of
each
major
GC
cycle
when
the
heap
size
changes
and
when
compaction
is
triggered
item
CAMLRUNPARAM
If
OCAMLRUNPARAM
is
not
found
in
the
environment
then
CAMLRUNPARAM
will
be
used
instead
If
CAMLRUNPARAM
is
also
not
found
then
the
default
values
will
be
used
item
PATH
List
of
directories
searched
to
find
the
bytecode
executable
file
end
options
section
s
ocamlrun
dllpath
Dynamic
loading
of
shared
libraries
On
platforms
that
support
dynamic
loading
ocamlrun
can
link
dynamically
with
C
shared
libraries
DLLs
providing
additional
C
primitives
beyond
those
provided
by
the
standard
runtime
system
The
names
for
these
libraries
are
provided
at
link
time
as
described
in
section
ref
ss
dynlink
c
code
and
recorded
in
the
bytecode
executable
file
ocamlrun
then
locates
these
libraries
and
resolves
references
to
their
primitives
when
the
bytecode
executable
program
starts
The
ocamlrun
command
searches
shared
libraries
in
the
following
directories
in
the
order
indicated
begin
enumerate
item
Directories
specified
on
the
ocamlrun
command
line
with
the
I
option
item
Directories
specified
in
the
CAML
LD
LIBRARY
PATH
environment
variable
item
Directories
specified
at
link
time
via
the
dllpath
option
to
ocamlc
These
directories
are
recorded
in
the
bytecode
executable
file
item
Directories
specified
in
the
file
ld
conf
This
file
resides
in
the
OCaml
standard
library
directory
and
lists
directory
names
one
per
line
to
be
searched
Typically
it
contains
only
one
line
naming
the
stublibs
subdirectory
of
the
OCaml
standard
library
directory
Users
can
add
there
the
names
of
other
directories
containing
frequently
used
shared
libraries
however
for
consistency
of
installation
we
recommend
that
shared
libraries
are
installed
directly
in
the
system
stublibs
directory
rather
than
adding
lines
to
the
ld
conf
file
item
Default
directories
searched
by
the
system
dynamic
loader
Under
Unix
these
generally
include
lib
and
usr
lib
plus
the
directories
listed
in
the
file
etc
ld
so
conf
and
the
environment
variable
LD
LIBRARY
PATH
Under
Windows
these
include
the
Windows
system
directories
plus
the
directories
listed
in
the
PATH
environment
variable
end
enumerate
section
s
ocamlrun
common
errors
Common
errors
This
section
describes
and
explains
the
most
frequently
encountered
error
messages
begin
options
item
it
filename
no
such
file
or
directory
If
it
filename
is
the
name
of
a
self
executable
bytecode
file
this
means
that
either
that
file
does
not
exist
or
that
it
failed
to
run
the
ocamlrun
bytecode
interpreter
on
itself
The
second
possibility
indicates
that
OCaml
has
not
been
properly
installed
on
your
system
item
Cannot
exec
ocamlrun
When
launching
a
self
executable
bytecode
file
The
ocamlrun
could
not
be
found
in
the
executable
path
Check
that
OCaml
has
been
properly
installed
on
your
system
item
Cannot
find
the
bytecode
file
The
file
that
ocamlrun
is
trying
to
execute
e
g
the
file
given
as
first
non
option
argument
to
ocamlrun
either
does
not
exist
or
is
not
a
valid
executable
bytecode
file
item
Truncated
bytecode
file
The
file
that
ocamlrun
is
trying
to
execute
is
not
a
valid
executable
bytecode
file
Probably
it
has
been
truncated
or
mangled
since
created
Erase
and
rebuild
it
item
Uncaught
exception
The
program
being
executed
contains
a
stray
exception
That
is
it
raises
an
exception
at
some
point
and
this
exception
is
never
caught
This
causes
immediate
termination
of
the
program
The
name
of
the
exception
is
printed
along
with
its
string
byte
sequence
and
integer
arguments
arguments
of
more
complex
types
are
not
correctly
printed
To
locate
the
context
of
the
uncaught
exception
compile
the
program
with
the
g
option
and
either
run
it
again
under
the
ocamldebug
debugger
see
chapter
ref
c
debugger
or
run
it
with
ocamlrun
b
or
with
the
OCAMLRUNPARAM
environment
variable
set
to
b
1
item
Out
of
memory
The
program
being
executed
requires
more
memory
than
available
Either
the
program
builds
excessively
large
data
structures
or
the
program
contains
too
many
nested
function
calls
and
the
stack
overflows
In
some
cases
your
program
is
perfectly
correct
it
just
requires
more
memory
than
your
machine
provides
In
other
cases
the
out
of
memory
message
reveals
an
error
in
your
program
non
terminating
recursive
function
allocation
of
an
excessively
large
array
string
or
byte
sequence
attempts
to
build
an
infinite
list
or
other
data
structure
ldots
To
help
you
diagnose
this
error
run
your
program
with
the
v
option
to
ocamlrun
or
with
the
OCAMLRUNPARAM
environment
variable
set
to
v
63
If
it
displays
lots
of
Growing
stack
ldots
messages
this
is
probably
a
looping
recursive
function
If
it
displays
lots
of
Growing
heap
ldots
messages
with
the
heap
size
growing
slowly
this
is
probably
an
attempt
to
construct
a
data
structure
with
too
many
infinitely
many
cells
If
it
displays
few
Growing
heap
ldots
messages
but
with
a
huge
increment
in
the
heap
size
this
is
probably
an
attempt
to
build
an
excessively
large
array
string
or
byte
sequence
end
options
chapter
Interfacing
label
c
intf
c
C
with
OCaml
HEVEA
cutname
intfc
html
This
chapter
describes
how
user
defined
primitives
written
in
C
can
be
linked
with
OCaml
code
and
called
from
OCaml
functions
and
how
these
C
functions
can
call
back
to
OCaml
code
section
s
c
overview
Overview
and
compilation
information
subsection
ss
c
prim
decl
Declaring
primitives
begin
syntax
definition
external
value
name
typexpr
external
declaration
external
declaration
string
literal
string
literal
string
literal
end
syntax
User
primitives
are
declared
in
an
implementation
file
or
struct
ldots
end
module
expression
using
the
external
keyword
begin
alltt
external
var
name
var
type
var
C
function
name
end
alltt
This
defines
the
value
name
var
name
as
a
function
with
type
var
type
that
executes
by
calling
the
given
C
function
For
instance
here
is
how
the
seek
in
primitive
is
declared
in
the
standard
library
module
Stdlib
begin
verbatim
external
seek
in
in
channel
int
unit
caml
ml
seek
in
end
verbatim
Primitives
with
several
arguments
are
always
curried
The
C
function
does
not
necessarily
have
the
same
name
as
the
ML
function
External
functions
thus
defined
can
be
specified
in
interface
files
or
sig
ldots
end
signatures
either
as
regular
values
begin
alltt
val
var
name
var
type
end
alltt
thus
hiding
their
implementation
as
C
functions
or
explicitly
as
manifest
external
functions
begin
alltt
external
var
name
var
type
var
C
function
name
end
alltt
The
latter
is
slightly
more
efficient
as
it
allows
clients
of
the
module
to
call
directly
the
C
function
instead
of
going
through
the
corresponding
OCaml
function
On
the
other
hand
it
should
not
be
used
in
library
modules
if
they
have
side
effects
at
toplevel
as
this
direct
call
interferes
with
the
linker
s
algorithm
for
removing
unused
modules
from
libraries
at
link
time
The
arity
number
of
arguments
of
a
primitive
is
automatically
determined
from
its
OCaml
type
in
the
external
declaration
by
counting
the
number
of
function
arrows
in
the
type
For
instance
seek
in
above
has
arity
2
and
the
caml
ml
seek
in
C
function
is
called
with
two
arguments
Similarly
begin
verbatim
external
seek
in
pair
in
channel
int
unit
caml
ml
seek
in
pair
end
verbatim
has
arity
1
and
the
caml
ml
seek
in
pair
C
function
receives
one
argument
which
is
a
pair
of
OCaml
values
Type
abbreviations
are
not
expanded
when
determining
the
arity
of
a
primitive
For
instance
begin
verbatim
type
int
endo
int
int
external
f
int
endo
int
endo
f
external
g
int
int
int
int
f
end
verbatim
f
has
arity
1
but
g
has
arity
2
This
allows
a
primitive
to
return
a
functional
value
as
in
the
f
example
above
just
remember
to
name
the
functional
return
type
in
a
type
abbreviation
The
language
accepts
external
declarations
with
one
or
two
flag
strings
in
addition
to
the
C
function
s
name
These
flags
are
reserved
for
the
implementation
of
the
standard
library
subsection
ss
c
prim
impl
Implementing
primitives
User
primitives
with
arity
n
leq
5
are
implemented
by
C
functions
that
take
n
arguments
of
type
value
and
return
a
result
of
type
value
The
type
value
is
the
type
of
the
representations
for
OCaml
values
It
encodes
objects
of
several
base
types
integers
floating
point
numbers
strings
ldots
as
well
as
OCaml
data
structures
The
type
value
and
the
associated
conversion
functions
and
macros
are
described
in
detail
below
For
instance
here
is
the
declaration
for
the
C
function
implementing
the
In
channel
input
primitive
which
takes
4
arguments
begin
verbatim
CAMLprim
value
input
value
channel
value
buffer
value
offset
value
length
end
verbatim
When
the
primitive
function
is
applied
in
an
OCaml
program
the
C
function
is
called
with
the
values
of
the
expressions
to
which
the
primitive
is
applied
as
arguments
The
value
returned
by
the
function
is
passed
back
to
the
OCaml
program
as
the
result
of
the
function
application
User
primitives
with
arity
greater
than
5
should
be
implemented
by
two
C
functions
The
first
function
to
be
used
in
conjunction
with
the
bytecode
compiler
ocamlc
receives
two
arguments
a
pointer
to
an
array
of
OCaml
values
the
values
for
the
arguments
and
an
integer
which
is
the
number
of
arguments
provided
The
other
function
to
be
used
in
conjunction
with
the
native
code
compiler
ocamlopt
takes
its
arguments
directly
For
instance
here
are
the
two
C
functions
for
the
7
argument
primitive
Nat
add
nat
begin
verbatim
CAMLprim
value
add
nat
native
value
nat1
value
ofs1
value
len1
value
nat2
value
ofs2
value
len2
value
carry
in
CAMLprim
value
add
nat
bytecode
value
argv
int
argn
return
add
nat
native
argv
0
argv
1
argv
2
argv
3
argv
4
argv
5
argv
6
end
verbatim
The
names
of
the
two
C
functions
must
be
given
in
the
primitive
declaration
as
follows
begin
alltt
external
var
name
var
type
var
bytecode
C
function
name
var
native
code
C
function
name
end
alltt
For
instance
in
the
case
of
add
nat
the
declaration
is
begin
verbatim
external
add
nat
nat
int
int
nat
int
int
int
int
add
nat
bytecode
add
nat
native
end
verbatim
Implementing
a
user
primitive
is
actually
two
separate
tasks
on
the
one
hand
decoding
the
arguments
to
extract
C
values
from
the
given
OCaml
values
and
encoding
the
return
value
as
an
OCaml
value
on
the
other
hand
actually
computing
the
result
from
the
arguments
Except
for
very
simple
primitives
it
is
often
preferable
to
have
two
distinct
C
functions
to
implement
these
two
tasks
The
first
function
actually
implements
the
primitive
taking
native
C
values
as
arguments
and
returning
a
native
C
value
The
second
function
often
called
the
stub
code
is
a
simple
wrapper
around
the
first
function
that
converts
its
arguments
from
OCaml
values
to
C
values
calls
the
first
function
and
converts
the
returned
C
value
to
an
OCaml
value
For
instance
here
is
the
stub
code
for
the
Int64
float
of
bits
primitive
begin
verbatim
CAMLprim
value
caml
int64
float
of
bits
value
vi
return
caml
copy
double
caml
int64
float
of
bits
unboxed
Int64
val
vi
end
verbatim
Here
caml
copy
double
and
Int64
val
are
conversion
functions
and
macros
for
the
type
value
that
will
be
described
later
The
CAMLprim
macro
expands
to
the
required
compiler
directives
to
ensure
that
the
function
is
exported
and
accessible
from
OCaml
The
hard
work
is
performed
by
the
function
caml
int64
float
of
bits
unboxed
which
is
declared
as
begin
verbatim
double
caml
int64
float
of
bits
unboxed
int64
t
i
end
verbatim
To
write
C
code
that
operates
on
OCaml
values
the
following
include
files
are
provided
begin
tableau
l
p
12cm
Include
file
Provides
entree
caml
mlvalues
h
definition
of
the
value
type
and
conversion
macros
entree
caml
alloc
h
allocation
functions
to
create
structured
OCaml
objects
entree
caml
memory
h
miscellaneous
memory
related
functions
and
macros
for
GC
interface
in
place
modification
of
structures
etc
entree
caml
fail
h
functions
for
raising
exceptions
see
section
ref
ss
c
exceptions
entree
caml
callback
h
callback
from
C
to
OCaml
see
section
ref
s
c
callback
entree
caml
custom
h
operations
on
custom
blocks
see
section
ref
s
c
custom
entree
caml
intext
h
operations
for
writing
user
defined
serialization
and
deserialization
functions
for
custom
blocks
see
section
ref
s
c
custom
entree
caml
threads
h
operations
for
interfacing
in
the
presence
of
multiple
threads
see
section
ref
s
C
multithreading
end
tableau
These
files
reside
in
the
caml
subdirectory
of
the
OCaml
standard
library
directory
which
is
returned
by
the
command
ocamlc
where
usually
usr
local
lib
ocaml
or
usr
lib
ocaml
subsection
ss
staticlink
c
code
Statically
linking
C
code
with
OCaml
code
The
OCaml
runtime
system
comprises
three
main
parts
the
bytecode
interpreter
the
memory
manager
and
a
set
of
C
functions
that
implement
the
primitive
operations
Some
bytecode
instructions
are
provided
to
call
these
C
functions
designated
by
their
offset
in
a
table
of
functions
the
table
of
primitives
In
the
default
mode
the
OCaml
linker
produces
bytecode
for
the
standard
runtime
system
with
a
standard
set
of
primitives
References
to
primitives
that
are
not
in
this
standard
set
result
in
the
unavailable
C
primitive
error
Unless
dynamic
loading
of
C
libraries
is
supported
see
section
ref
ss
dynlink
c
code
below
In
the
custom
runtime
mode
the
OCaml
linker
scans
the
object
files
and
determines
the
set
of
required
primitives
Then
it
builds
a
suitable
runtime
system
by
calling
the
native
code
linker
with
begin
itemize
item
the
table
of
the
required
primitives
item
a
library
that
provides
the
bytecode
interpreter
the
memory
manager
and
the
standard
primitives
item
libraries
and
object
code
files
o
files
mentioned
on
the
command
line
for
the
OCaml
linker
that
provide
implementations
for
the
user
s
primitives
end
itemize
This
builds
a
runtime
system
with
the
required
primitives
The
OCaml
linker
generates
bytecode
for
this
custom
runtime
system
The
bytecode
is
appended
to
the
end
of
the
custom
runtime
system
so
that
it
will
be
automatically
executed
when
the
output
file
custom
runtime
bytecode
is
launched
To
link
in
custom
runtime
mode
execute
the
ocamlc
command
with
begin
itemize
item
the
custom
option
item
the
names
of
the
desired
OCaml
object
files
cmo
and
cma
files
item
the
names
of
the
C
object
files
and
libraries
o
and
a
files
that
implement
the
required
primitives
Under
Unix
and
Windows
a
library
named
lib
var
name
a
respectively
lib
residing
in
one
of
the
standard
library
directories
can
also
be
specified
as
cclib
l
var
name
end
itemize
If
you
are
using
the
native
code
compiler
ocamlopt
the
custom
flag
is
not
needed
as
the
final
linking
phase
of
ocamlopt
always
builds
a
standalone
executable
To
build
a
mixed
OCaml
C
executable
execute
the
ocamlopt
command
with
begin
itemize
item
the
names
of
the
desired
OCaml
native
object
files
cmx
and
cmxa
files
item
the
names
of
the
C
object
files
and
libraries
o
a
so
or
dll
files
that
implement
the
required
primitives
end
itemize
Starting
with
Objective
Caml
3
00
it
is
possible
to
record
the
custom
option
as
well
as
the
names
of
C
libraries
in
an
OCaml
library
file
cma
or
cmxa
For
instance
consider
an
OCaml
library
mylib
cma
built
from
the
OCaml
object
files
a
cmo
and
b
cmo
which
reference
C
code
in
libmylib
a
If
the
library
is
built
as
follows
begin
alltt
ocamlc
a
o
mylib
cma
custom
a
cmo
b
cmo
cclib
lmylib
end
alltt
users
of
the
library
can
simply
link
with
mylib
cma
begin
alltt
ocamlc
o
myprog
mylib
cma
end
alltt
and
the
system
will
automatically
add
the
custom
and
cclib
lmylib
options
achieving
the
same
effect
as
begin
alltt
ocamlc
o
myprog
custom
a
cmo
b
cmo
cclib
lmylib
end
alltt
The
alternative
is
of
course
to
build
the
library
without
extra
options
begin
alltt
ocamlc
a
o
mylib
cma
a
cmo
b
cmo
end
alltt
and
then
ask
users
to
provide
the
custom
and
cclib
lmylib
options
themselves
at
link
time
begin
alltt
ocamlc
o
myprog
custom
mylib
cma
cclib
lmylib
end
alltt
The
former
alternative
is
more
convenient
for
the
final
users
of
the
library
however
subsection
ss
dynlink
c
code
Dynamically
linking
C
code
with
OCaml
code
Starting
with
Objective
Caml
3
03
an
alternative
to
static
linking
of
C
code
using
the
custom
code
is
provided
In
this
mode
the
OCaml
linker
generates
a
pure
bytecode
executable
no
embedded
custom
runtime
system
that
simply
records
the
names
of
dynamically
loaded
libraries
containing
the
C
code
The
standard
OCaml
runtime
system
ocamlrun
then
loads
dynamically
these
libraries
and
resolves
references
to
the
required
primitives
before
executing
the
bytecode
This
facility
is
currently
available
on
all
platforms
supported
by
OCaml
except
Cygwin
64
bits
To
dynamically
link
C
code
with
OCaml
code
the
C
code
must
first
be
compiled
into
a
shared
library
under
Unix
or
DLL
under
Windows
This
involves
1
compiling
the
C
files
with
appropriate
C
compiler
flags
for
producing
position
independent
code
when
required
by
the
operating
system
and
2
building
a
shared
library
from
the
resulting
object
files
The
resulting
shared
library
or
DLL
file
must
be
installed
in
a
place
where
ocamlrun
can
find
it
later
at
program
start
up
time
see
section
ref
s
ocamlrun
dllpath
Finally
step
3
execute
the
ocamlc
command
with
begin
itemize
item
the
names
of
the
desired
OCaml
object
files
cmo
and
cma
files
item
the
names
of
the
C
shared
libraries
so
or
dll
files
that
implement
the
required
primitives
Under
Unix
and
Windows
a
library
named
dll
var
name
so
respectively
dll
residing
in
one
of
the
standard
library
directories
can
also
be
specified
as
dllib
l
var
name
end
itemize
Do
em
not
set
the
custom
flag
otherwise
you
re
back
to
static
linking
as
described
in
section
ref
ss
staticlink
c
code
The
ocamlmklib
tool
see
section
ref
s
ocamlmklib
automates
steps
2
and
3
As
in
the
case
of
static
linking
it
is
possible
and
recommended
to
record
the
names
of
C
libraries
in
an
OCaml
cma
library
archive
Consider
again
an
OCaml
library
mylib
cma
built
from
the
OCaml
object
files
a
cmo
and
b
cmo
which
reference
C
code
in
dllmylib
so
If
the
library
is
built
as
follows
begin
alltt
ocamlc
a
o
mylib
cma
a
cmo
b
cmo
dllib
lmylib
end
alltt
users
of
the
library
can
simply
link
with
mylib
cma
begin
alltt
ocamlc
o
myprog
mylib
cma
end
alltt
and
the
system
will
automatically
add
the
dllib
lmylib
option
achieving
the
same
effect
as
begin
alltt
ocamlc
o
myprog
a
cmo
b
cmo
dllib
lmylib
end
alltt
Using
this
mechanism
users
of
the
library
mylib
cma
do
not
need
to
know
that
it
references
C
code
nor
whether
this
C
code
must
be
statically
linked
using
custom
or
dynamically
linked
subsection
ss
c
static
vs
dynamic
Choosing
between
static
linking
and
dynamic
linking
After
having
described
two
different
ways
of
linking
C
code
with
OCaml
code
we
now
review
the
pros
and
cons
of
each
to
help
developers
of
mixed
OCaml
C
libraries
decide
The
main
advantage
of
dynamic
linking
is
that
it
preserves
the
platform
independence
of
bytecode
executables
That
is
the
bytecode
executable
contains
no
machine
code
and
can
therefore
be
compiled
on
platform
A
and
executed
on
other
platforms
B
C
ldots
as
long
as
the
required
shared
libraries
are
available
on
all
these
platforms
In
contrast
executables
generated
by
ocamlc
custom
run
only
on
the
platform
on
which
they
were
created
because
they
embark
a
custom
tailored
runtime
system
specific
to
that
platform
In
addition
dynamic
linking
results
in
smaller
executables
Another
advantage
of
dynamic
linking
is
that
the
final
users
of
the
library
do
not
need
to
have
a
C
compiler
C
linker
and
C
runtime
libraries
installed
on
their
machines
This
is
no
big
deal
under
Unix
and
Cygwin
but
many
Windows
users
are
reluctant
to
install
Microsoft
Visual
C
just
to
be
able
to
do
ocamlc
custom
There
are
two
drawbacks
to
dynamic
linking
The
first
is
that
the
resulting
executable
is
not
stand
alone
it
requires
the
shared
libraries
as
well
as
ocamlrun
to
be
installed
on
the
machine
executing
the
code
If
you
wish
to
distribute
a
stand
alone
executable
it
is
better
to
link
it
statically
using
ocamlc
custom
ccopt
static
or
ocamlopt
ccopt
static
Dynamic
linking
also
raises
the
DLL
hell
problem
some
care
must
be
taken
to
ensure
that
the
right
versions
of
the
shared
libraries
are
found
at
start
up
time
The
second
drawback
of
dynamic
linking
is
that
it
complicates
the
construction
of
the
library
The
C
compiler
and
linker
flags
to
compile
to
position
independent
code
and
build
a
shared
library
vary
wildly
between
different
Unix
systems
Also
dynamic
linking
is
not
supported
on
all
Unix
systems
requiring
a
fall
back
case
to
static
linking
in
the
Makefile
for
the
library
The
ocamlmklib
command
see
section
ref
s
ocamlmklib
tries
to
hide
some
of
these
system
dependencies
In
conclusion
dynamic
linking
is
highly
recommended
under
the
native
Windows
port
because
there
are
no
portability
problems
and
it
is
much
more
convenient
for
the
end
users
Under
Unix
dynamic
linking
should
be
considered
for
mature
frequently
used
libraries
because
it
enhances
platform
independence
of
bytecode
executables
For
new
or
rarely
used
libraries
static
linking
is
much
simpler
to
set
up
in
a
portable
way
subsection
ss
custom
runtime
Building
standalone
custom
runtime
systems
It
is
sometimes
inconvenient
to
build
a
custom
runtime
system
each
time
OCaml
code
is
linked
with
C
libraries
like
ocamlc
custom
does
For
one
thing
the
building
of
the
runtime
system
is
slow
on
some
systems
that
have
bad
linkers
or
slow
remote
file
systems
for
another
thing
the
platform
independence
of
bytecode
files
is
lost
forcing
to
perform
one
ocamlc
custom
link
per
platform
of
interest
An
alternative
to
ocamlc
custom
is
to
build
separately
a
custom
runtime
system
integrating
the
desired
C
libraries
then
generate
pure
bytecode
executables
not
containing
their
own
runtime
system
that
can
run
on
this
custom
runtime
This
is
achieved
by
the
make
runtime
and
use
runtime
flags
to
ocamlc
For
example
to
build
a
custom
runtime
system
integrating
the
C
parts
of
the
Unix
and
Threads
libraries
do
begin
verbatim
ocamlc
make
runtime
o
home
me
ocamlunixrun
unix
cma
threads
cma
end
verbatim
To
generate
a
bytecode
executable
that
runs
on
this
runtime
system
do
begin
alltt
ocamlc
use
runtime
home
me
ocamlunixrun
o
myprog
char92
unix
cma
threads
cma
it
your
cmo
and
cma
files
end
alltt
The
bytecode
executable
myprog
can
then
be
launched
as
usual
myprog
var
args
or
home
me
ocamlunixrun
myprog
var
args
Notice
that
the
bytecode
libraries
unix
cma
and
threads
cma
must
be
given
twice
when
building
the
runtime
system
so
that
ocamlc
knows
which
C
primitives
are
required
and
also
when
building
the
bytecode
executable
so
that
the
bytecode
from
unix
cma
and
threads
cma
is
actually
linked
in
section
s
c
value
The
texttt
value
type
All
OCaml
objects
are
represented
by
the
C
type
value
defined
in
the
include
file
caml
mlvalues
h
along
with
macros
to
manipulate
values
of
that
type
An
object
of
type
value
is
either
begin
itemize
item
an
unboxed
integer
item
or
a
pointer
to
a
block
inside
the
heap
allocated
through
one
of
the
verb
caml
alloc
functions
described
in
section
ref
ss
c
block
allocation
end
itemize
subsection
ss
c
int
Integer
values
Integer
values
encode
63
bit
signed
integers
31
bit
on
32
bit
architectures
They
are
unboxed
unallocated
subsection
ss
c
blocks
Blocks
Blocks
in
the
heap
are
garbage
collected
and
therefore
have
strict
structure
constraints
Each
block
includes
a
header
containing
the
size
of
the
block
in
words
and
the
tag
of
the
block
The
tag
governs
how
the
contents
of
the
blocks
are
structured
A
tag
lower
than
No
scan
tag
indicates
a
structured
block
containing
well
formed
values
which
is
recursively
traversed
by
the
garbage
collector
A
tag
greater
than
or
equal
to
No
scan
tag
indicates
a
raw
block
whose
contents
are
not
scanned
by
the
garbage
collector
For
the
benefit
of
ad
hoc
polymorphic
primitives
such
as
equality
and
structured
input
output
structured
and
raw
blocks
are
further
classified
according
to
their
tags
as
follows
begin
tableau
l
p
10cm
Tag
Contents
of
the
block
entree
0
to
hbox
No
scan
tag
1
A
structured
block
an
array
of
OCaml
objects
Each
field
is
a
value
entree
Closure
tag
A
closure
representing
a
functional
value
The
first
word
is
a
pointer
to
a
piece
of
code
the
remaining
words
are
value
containing
the
environment
entree
String
tag
A
character
string
or
a
byte
sequence
entree
Double
tag
A
double
precision
floating
point
number
entree
Double
array
tag
An
array
or
record
of
double
precision
floating
point
numbers
entree
Abstract
tag
A
block
representing
an
abstract
datatype
entree
Custom
tag
A
block
representing
an
abstract
datatype
with
user
defined
finalization
comparison
hashing
serialization
and
deserialization
functions
attached
end
tableau
subsection
ss
c
outside
head
Pointers
outside
the
heap
In
earlier
versions
of
OCaml
it
was
possible
to
use
word
aligned
pointers
to
addresses
outside
the
heap
as
OCaml
values
just
by
casting
the
pointer
to
type
value
This
usage
is
no
longer
supported
since
OCaml
5
0
A
correct
way
to
manipulate
pointers
to
out
of
heap
blocks
from
OCaml
is
to
store
those
pointers
in
OCaml
blocks
with
tag
Abstract
tag
or
Custom
tag
then
use
the
blocks
as
the
OCaml
values
Here
is
an
example
of
encapsulation
of
out
of
heap
pointers
of
C
type
ty
inside
Abstract
tag
blocks
Section
ref
s
c
intf
example
gives
a
more
complete
example
using
Custom
tag
blocks
begin
verbatim
Create
an
OCaml
value
encapsulating
the
pointer
p
static
value
val
of
typtr
ty
p
value
v
caml
alloc
1
Abstract
tag
ty
Data
abstract
val
v
p
return
v
Extract
the
pointer
encapsulated
in
the
given
OCaml
value
static
ty
typtr
of
val
value
v
return
ty
Data
abstract
val
v
end
verbatim
Alternatively
out
of
heap
pointers
can
be
treated
as
native
integers
that
is
boxed
32
bit
integers
on
a
32
bit
platform
and
boxed
64
bit
integers
on
a
64
bit
platform
begin
verbatim
Create
an
OCaml
value
encapsulating
the
pointer
p
static
value
val
of
typtr
ty
p
return
caml
copy
nativeint
intnat
p
Extract
the
pointer
encapsulated
in
the
given
OCaml
value
static
ty
typtr
of
val
value
v
return
ty
Nativeint
val
v
end
verbatim
For
pointers
that
are
at
least
2
aligned
the
low
bit
is
guaranteed
to
be
zero
we
have
yet
another
valid
representation
as
an
OCaml
tagged
integer
begin
verbatim
Create
an
OCaml
value
encapsulating
the
pointer
p
static
value
val
of
typtr
ty
p
assert
uintptr
t
p
1
0
check
correct
alignment
return
value
p
1
Extract
the
pointer
encapsulated
in
the
given
OCaml
value
static
ty
typtr
of
val
value
v
return
ty
v
1
end
verbatim
section
s
c
ocaml
datatype
repr
Representation
of
OCaml
data
types
This
section
describes
how
OCaml
data
types
are
encoded
in
the
value
type
subsection
ss
c
atomic
Atomic
types
begin
tableau
l
l
OCaml
type
Encoding
entree
int
Unboxed
integer
values
entree
char
Unboxed
integer
values
ASCII
code
entree
float
Blocks
with
tag
Double
tag
entree
bytes
Blocks
with
tag
String
tag
entree
string
Blocks
with
tag
String
tag
entree
int32
Blocks
with
tag
Custom
tag
entree
int64
Blocks
with
tag
Custom
tag
entree
nativeint
Blocks
with
tag
Custom
tag
end
tableau
subsection
ss
c
tuples
and
records
Tuples
and
records
Tuples
are
represented
by
pointers
to
blocks
with
tag
0
Records
are
also
represented
by
zero
tagged
blocks
The
ordering
of
labels
in
the
record
type
declaration
determines
the
layout
of
the
record
fields
the
value
associated
to
the
label
declared
first
is
stored
in
field
0
of
the
block
the
value
associated
to
the
second
label
goes
in
field
1
and
so
on
As
an
optimization
records
whose
fields
all
have
static
type
float
are
represented
as
arrays
of
floating
point
numbers
with
tag
Double
array
tag
See
the
section
below
on
arrays
As
another
optimization
unboxable
record
types
are
represented
specially
unboxable
record
types
are
the
immutable
record
types
that
have
only
one
field
An
unboxable
type
will
be
represented
in
one
of
two
ways
boxed
or
unboxed
Boxed
record
types
are
represented
as
described
above
by
a
block
with
tag
0
or
Double
array
tag
An
unboxed
record
type
is
represented
directly
by
the
value
of
its
field
i
e
there
is
no
block
to
represent
the
record
itself
The
representation
is
chosen
according
to
the
following
in
decreasing
order
of
priority
begin
itemize
item
An
attribute
boxed
or
unboxed
on
the
type
declaration
item
A
compiler
option
unboxed
types
or
no
unboxed
types
item
The
default
representation
In
the
present
version
of
OCaml
the
default
is
the
boxed
representation
end
itemize
subsection
ss
c
arrays
Arrays
Arrays
of
integers
and
pointers
are
represented
like
tuples
and
records
that
is
as
pointers
to
blocks
tagged
0
They
are
accessed
with
the
Field
macro
for
reading
and
the
caml
modify
function
for
writing
Values
of
type
floatarray
as
manipulated
by
the
Float
Array
module
as
well
as
records
whose
declaration
contains
only
float
fields
use
an
efficient
unboxed
representation
blocks
with
tag
Double
array
tag
whose
content
consist
of
raw
double
values
which
are
not
themselves
valid
OCaml
values
They
should
be
accessed
using
the
Double
flat
field
and
Store
double
flat
field
macros
Finally
arrays
of
type
float
array
may
use
either
the
boxed
or
the
unboxed
representation
depending
on
the
how
the
compiler
is
configured
They
currently
use
the
unboxed
representation
by
default
but
can
be
made
to
use
the
boxed
representation
by
passing
the
disable
flat
float
array
flag
to
the
configure
script
They
should
be
accessed
using
the
Double
array
field
and
Store
double
array
field
macros
which
will
work
correctly
under
both
modes
subsection
ss
c
concrete
datatypes
Concrete
data
types
Constructed
terms
are
represented
either
by
unboxed
integers
for
constant
constructors
or
by
blocks
whose
tag
encode
the
constructor
for
non
constant
constructors
The
constant
constructors
and
the
non
constant
constructors
for
a
given
concrete
type
are
numbered
separately
starting
from
0
in
the
order
in
which
they
appear
in
the
concrete
type
declaration
A
constant
constructor
is
represented
by
the
unboxed
integer
equal
to
its
constructor
number
A
non
constant
constructor
declared
with
n
arguments
is
represented
by
a
block
of
size
n
tagged
with
the
constructor
number
the
n
fields
contain
its
arguments
Example
begin
tableau
l
p
8cm
Constructed
term
Representation
entree
Val
int
0
entree
false
Val
int
0
entree
true
Val
int
1
entree
Val
int
0
entree
h
t
Block
with
size
2
and
tag
0
first
field
contains
h
second
field
t
end
tableau
As
a
convenience
caml
mlvalues
h
defines
the
macros
Val
unit
Val
false
Val
true
and
Val
emptylist
to
refer
to
false
true
and
The
following
example
illustrates
the
assignment
of
integers
and
block
tags
to
constructors
begin
verbatim
type
t
A
First
constant
constructor
integer
Val
int
0
B
of
string
First
non
constant
constructor
block
with
tag
0
C
Second
constant
constructor
integer
Val
int
1
D
of
bool
Second
non
constant
constructor
block
with
tag
1
E
of
t
t
Third
non
constant
constructor
block
with
tag
2
end
verbatim
As
an
optimization
unboxable
concrete
data
types
are
represented
specially
a
concrete
data
type
is
unboxable
if
it
has
exactly
one
constructor
and
this
constructor
has
exactly
one
argument
Unboxable
concrete
data
types
are
represented
in
the
same
ways
as
unboxable
record
types
see
the
description
in
section
ref
ss
c
tuples
and
records
subsection
ss
c
objects
Objects
Objects
are
represented
as
blocks
with
tag
Object
tag
The
first
field
of
the
block
refers
to
the
object
s
class
and
associated
method
suite
in
a
format
that
cannot
easily
be
exploited
from
C
The
second
field
contains
a
unique
object
ID
used
for
comparisons
The
remaining
fields
of
the
object
contain
the
values
of
the
instance
variables
of
the
object
It
is
unsafe
to
access
directly
instance
variables
as
the
type
system
provides
no
guarantee
about
the
instance
variables
contained
by
an
object
Instance
variables
are
stored
in
the
order
in
which
they
appear
in
the
class
definition
taking
inherited
classes
into
account
One
may
extract
a
public
method
from
an
object
using
the
C
function
caml
get
public
method
declared
in
caml
mlvalues
h
Since
public
method
tags
are
hashed
in
the
same
way
as
variant
tags
and
methods
are
functions
taking
self
as
first
argument
if
you
want
to
do
the
method
call
foo
bar
from
the
C
side
you
should
call
begin
verbatim
callback
caml
get
public
method
foo
caml
hash
variant
bar
foo
end
verbatim
subsection
ss
c
polyvar
Polymorphic
variants
Like
constructed
terms
polymorphic
variant
values
are
represented
either
as
integers
for
polymorphic
variants
without
argument
or
as
blocks
for
polymorphic
variants
with
an
argument
Unlike
constructed
terms
variant
constructors
are
not
numbered
starting
from
0
but
identified
by
a
hash
value
an
OCaml
integer
as
computed
by
the
C
function
caml
hash
variant
declared
in
caml
mlvalues
h
the
hash
value
for
a
variant
constructor
named
say
VConstr
is
caml
hash
variant
VConstr
The
variant
value
VConstr
is
represented
by
caml
hash
variant
VConstr
The
variant
value
VConstr
var
v
is
represented
by
a
block
of
size
2
and
tag
0
with
field
number
0
containing
caml
hash
variant
VConstr
and
field
number
1
containing
var
v
Unlike
constructed
values
polymorphic
variant
values
taking
several
arguments
are
not
flattened
That
is
VConstr
var
v
var
w
is
represented
by
a
block
of
size
2
whose
field
number
1
contains
the
representation
of
the
pair
var
v
var
w
rather
than
a
block
of
size
3
containing
var
v
and
var
w
in
fields
1
and
2
section
s
c
ops
on
values
Operations
on
values
subsection
ss
c
kind
tests
Kind
tests
begin
itemize
item
Is
long
var
v
is
true
if
value
var
v
is
an
immediate
integer
false
otherwise
item
Is
block
var
v
is
true
if
value
var
v
is
a
pointer
to
a
block
and
false
if
it
is
an
immediate
integer
item
Is
none
var
v
is
true
if
value
var
v
is
None
item
Is
some
var
v
is
true
if
value
var
v
assumed
to
be
of
option
type
corresponds
to
the
Some
constructor
end
itemize
subsection
ss
c
int
ops
Operations
on
integers
The
header
caml
config
h
defines
a
C
integer
type
intnat
of
signed
64
bit
integers
32
bit
integers
on
32
bit
architectures
This
type
is
used
to
represent
the
integer
encoded
by
a
value
corresponding
to
an
unboxed
integer
without
truncation
begin
itemize
item
Val
long
var
n
returns
the
value
encoding
the
intnat
var
n
item
Long
val
var
v
returns
the
intnat
encoded
in
value
var
v
item
Val
int
var
i
returns
the
value
encoding
the
int
var
i
item
Int
val
var
v
returns
the
int
encoded
in
value
var
v
Note
that
this
operation
may
result
in
a
truncated
value
since
int
is
32
bit
wide
on
64
bit
architectures
item
Val
bool
var
x
returns
the
OCaml
boolean
representing
the
truth
value
of
the
C
integer
var
x
item
Bool
val
var
v
returns
0
if
var
v
is
the
OCaml
boolean
false
1
if
var
v
is
true
item
Val
true
Val
false
represent
the
OCaml
booleans
true
and
false
item
Val
emptylist
represents
the
empty
list
item
Val
none
represents
the
OCaml
value
None
end
itemize
subsection
ss
c
block
access
Accessing
blocks
begin
itemize
item
Wosize
val
var
v
returns
the
size
of
the
block
var
v
in
words
excluding
the
header
item
Tag
val
var
v
returns
the
tag
of
the
block
var
v
item
Field
var
v
var
n
returns
the
value
contained
in
the
n
th
field
of
the
structured
block
var
v
Fields
are
numbered
from
0
to
hbox
Wosize
val
v
1
item
Store
field
var
b
var
n
var
v
stores
the
value
var
v
in
the
field
number
var
n
of
value
var
b
which
must
be
a
structured
block
item
Code
val
var
v
returns
the
code
part
of
the
closure
var
v
item
caml
string
length
var
v
returns
the
length
number
of
bytes
of
the
string
or
byte
sequence
var
v
item
Byte
var
v
var
n
returns
the
n
th
byte
of
the
string
or
byte
sequence
var
v
with
type
char
Bytes
are
numbered
from
0
to
hbox
string
length
v
1
item
Byte
u
var
v
var
n
returns
the
n
th
byte
of
the
string
or
byte
sequence
var
v
with
type
unsigned
char
Bytes
are
numbered
from
0
to
hbox
string
length
v
1
item
String
val
var
v
returns
a
pointer
to
the
first
byte
of
the
string
var
v
with
type
const
char
This
pointer
is
a
valid
C
string
there
is
a
null
byte
after
the
last
byte
in
the
string
However
OCaml
strings
can
contain
embedded
null
bytes
which
will
confuse
the
usual
C
functions
over
strings
The
function
caml
string
is
c
safe
var
v
returns
true
if
the
OCaml
string
var
v
does
not
contain
any
embedded
null
bytes
item
Bytes
val
var
v
returns
a
pointer
to
the
first
byte
of
the
byte
sequence
var
v
with
type
unsigned
char
item
Double
val
var
v
returns
the
floating
point
number
contained
in
value
var
v
with
type
double
item
Double
array
field
var
v
var
n
returns
the
n
th
element
of
a
float
array
var
v
item
Store
double
array
field
var
v
var
n
var
d
stores
the
double
precision
floating
point
number
var
d
in
the
n
th
element
of
a
float
array
var
v
item
Double
flat
field
var
v
var
n
returns
the
n
th
element
of
a
floatarray
or
a
record
of
floats
var
v
an
unboxed
block
tagged
Double
array
tag
item
Store
double
flat
field
var
v
var
n
var
d
stores
the
double
precision
floating
point
number
var
d
in
the
n
th
element
of
a
floatarray
or
a
record
of
floats
var
v
item
Data
custom
val
var
v
returns
a
pointer
to
the
data
part
of
the
custom
block
var
v
This
pointer
has
type
void
and
must
be
cast
to
the
type
of
the
data
contained
in
the
custom
block
item
Int32
val
var
v
returns
the
32
bit
integer
contained
in
the
int32
var
v
item
Int64
val
var
v
returns
the
64
bit
integer
contained
in
the
int64
var
v
item
Nativeint
val
var
v
returns
the
long
integer
contained
in
the
nativeint
var
v
item
caml
field
unboxed
var
v
returns
the
value
of
the
field
of
a
value
var
v
of
any
unboxed
type
record
or
concrete
data
type
item
caml
field
boxed
var
v
returns
the
value
of
the
field
of
a
value
var
v
of
any
boxed
type
record
or
concrete
data
type
item
caml
field
unboxable
var
v
calls
either
caml
field
unboxed
or
caml
field
boxed
according
to
the
default
representation
of
unboxable
types
in
the
current
version
of
OCaml
item
Some
val
var
v
returns
the
argument
var
x
of
a
value
var
v
of
the
form
Some
var
x
end
itemize
The
expressions
Field
var
v
var
n
Byte
var
v
var
n
and
Byte
u
var
v
var
n
are
valid
l
values
Hence
they
can
be
assigned
to
resulting
in
an
in
place
modification
of
value
var
v
Assigning
directly
to
Field
var
v
var
n
must
be
done
with
care
to
avoid
confusing
the
garbage
collector
see
below
subsection
ss
c
block
allocation
Allocating
blocks
subsubsection
sss
c
simple
allocation
Simple
interface
begin
itemize
item
Atom
var
t
returns
an
atom
zero
sized
block
with
tag
var
t
Zero
sized
blocks
are
preallocated
outside
of
the
heap
It
is
incorrect
to
try
and
allocate
a
zero
sized
block
using
the
functions
below
For
instance
Atom
0
represents
the
empty
array
item
caml
alloc
var
n
var
t
returns
a
fresh
block
of
size
var
n
with
tag
var
t
If
var
t
is
less
than
No
scan
tag
then
the
fields
of
the
block
are
initialized
with
a
valid
value
in
order
to
satisfy
the
GC
constraints
item
caml
alloc
tuple
var
n
returns
a
fresh
block
of
size
var
n
words
with
tag
0
item
caml
alloc
string
var
n
returns
a
byte
sequence
or
string
value
of
length
var
n
bytes
The
sequence
initially
contains
uninitialized
bytes
item
caml
alloc
initialized
string
var
n
var
p
returns
a
byte
sequence
or
string
value
of
length
var
n
bytes
The
value
is
initialized
from
the
var
n
bytes
starting
at
address
var
p
item
caml
copy
string
var
s
returns
a
string
or
byte
sequence
value
containing
a
copy
of
the
null
terminated
C
string
var
s
a
char
item
caml
copy
double
var
d
returns
a
floating
point
value
initialized
with
the
double
var
d
item
caml
copy
int32
var
i
caml
copy
int64
var
i
and
caml
copy
nativeint
var
i
return
a
value
of
OCaml
type
int32
int64
and
nativeint
respectively
initialized
with
the
integer
var
i
item
caml
alloc
array
var
f
var
a
allocates
an
array
of
values
calling
function
var
f
over
each
element
of
the
input
array
var
a
to
transform
it
into
a
value
The
array
var
a
is
an
array
of
pointers
terminated
by
the
null
pointer
The
function
var
f
receives
each
pointer
as
argument
and
returns
a
value
The
zero
tagged
block
returned
by
alloc
array
var
f
var
a
is
filled
with
the
values
returned
by
the
successive
calls
to
var
f
This
function
must
not
be
used
to
build
an
array
of
floating
point
numbers
item
caml
copy
string
array
var
p
allocates
an
array
of
strings
or
byte
sequences
copied
from
the
pointer
to
a
string
array
var
p
a
char
var
p
must
be
NULL
terminated
item
caml
alloc
float
array
var
n
allocates
an
array
of
floating
point
numbers
of
size
var
n
The
array
initially
contains
uninitialized
values
item
caml
alloc
unboxed
var
v
returns
the
value
of
any
unboxed
type
whose
field
is
the
value
var
v
item
caml
alloc
boxed
var
v
allocates
and
returns
a
value
of
any
boxed
type
whose
field
is
the
value
var
v
item
caml
alloc
unboxable
var
v
calls
either
caml
alloc
unboxed
or
caml
alloc
boxed
according
to
the
default
representation
of
unboxable
types
in
the
current
version
of
OCaml
item
caml
alloc
some
var
v
allocates
a
block
representing
Some
var
v
end
itemize
subsubsection
sss
c
low
level
alloc
Low
level
interface
The
following
functions
are
slightly
more
efficient
than
caml
alloc
but
also
much
more
difficult
to
use
From
the
standpoint
of
the
allocation
functions
blocks
are
divided
according
to
their
size
as
zero
sized
blocks
small
blocks
with
size
less
than
or
equal
to
verb
Max
young
wosize
and
large
blocks
with
size
greater
than
verb
Max
young
wosize
The
constant
verb
Max
young
wosize
is
declared
in
the
include
file
mlvalues
h
It
is
guaranteed
to
be
at
least
64
words
so
that
any
block
with
constant
size
less
than
or
equal
to
64
can
be
assumed
to
be
small
For
blocks
whose
size
is
computed
at
run
time
the
size
must
be
compared
against
verb
Max
young
wosize
to
determine
the
correct
allocation
procedure
begin
itemize
item
caml
alloc
small
var
n
var
t
returns
a
fresh
small
block
of
size
n
leq
hbox
Max
young
wosize
words
with
tag
var
t
If
this
block
is
a
structured
block
i
e
if
t
hbox
No
scan
tag
then
the
fields
of
the
block
initially
containing
garbage
must
be
initialized
with
legal
values
using
direct
assignment
to
the
fields
of
the
block
before
the
next
allocation
item
caml
alloc
shr
var
n
var
t
returns
a
fresh
block
of
size
var
n
with
tag
var
t
The
size
of
the
block
can
be
greater
than
verb
Max
young
wosize
It
can
also
be
smaller
but
in
this
case
it
is
more
efficient
to
call
caml
alloc
small
instead
of
caml
alloc
shr
If
this
block
is
a
structured
block
i
e
if
t
hbox
No
scan
tag
then
the
fields
of
the
block
initially
containing
garbage
must
be
initialized
with
legal
values
using
the
caml
initialize
function
described
below
before
the
next
allocation
end
itemize
subsection
ss
c
exceptions
Raising
exceptions
Two
functions
are
provided
to
raise
two
standard
exceptions
begin
itemize
item
caml
failwith
var
s
where
var
s
is
a
null
terminated
C
string
with
type
verb
char
raises
exception
Failure
with
argument
var
s
item
caml
invalid
argument
var
s
where
var
s
is
a
null
terminated
C
string
with
type
verb
char
raises
exception
Invalid
argument
with
argument
var
s
end
itemize
Raising
arbitrary
exceptions
from
C
is
more
delicate
the
exception
constructor
is
dynamically
allocated
by
the
OCaml
program
and
therefore
must
be
communicated
to
the
C
function
using
the
registration
facility
described
below
in
section
ref
ss
c
register
exn
Once
the
exception
constructor
is
recovered
in
C
the
following
functions
actually
raise
the
exception
begin
itemize
item
caml
raise
constant
var
id
raises
the
exception
var
id
with
no
argument
item
caml
raise
with
arg
var
id
var
v
raises
the
exception
var
id
with
the
OCaml
value
var
v
as
argument
item
caml
raise
with
args
var
id
var
n
var
v
raises
the
exception
var
id
with
the
OCaml
values
var
v
0
ldots
var
v
var
n
1
as
arguments
item
caml
raise
with
string
var
id
var
s
where
var
s
is
a
null
terminated
C
string
raises
the
exception
var
id
with
a
copy
of
the
C
string
var
s
as
argument
end
itemize
Sometimes
it
is
necessary
to
clean
up
state
and
release
resources
before
actually
raising
the
exception
back
into
OCaml
To
this
end
alternative
functions
that
return
the
exception
instead
of
raising
it
directly
caml
exception
failure
caml
exception
invalid
argument
etc
are
provided
The
type
caml
result
represents
either
an
OCaml
value
or
an
exception
see
section
ref
ss
c
result
section
s
c
gc
harmony
Living
in
harmony
with
the
garbage
collector
Unused
blocks
in
the
heap
are
automatically
reclaimed
by
the
garbage
collector
This
requires
some
cooperation
from
C
code
that
manipulates
heap
allocated
blocks
subsection
ss
c
simple
gc
harmony
Simple
interface
All
the
macros
described
in
this
section
are
declared
in
the
memory
h
header
file
begin
gcrule
A
function
that
has
parameters
or
local
variables
of
type
value
must
begin
with
a
call
to
one
of
the
CAMLparam
macros
and
return
with
CAMLreturn
CAMLreturn0
or
CAMLreturnT
end
gcrule
There
are
six
CAMLparam
macros
CAMLparam0
to
CAMLparam5
which
take
zero
to
five
arguments
respectively
If
your
function
has
no
more
than
5
parameters
of
type
value
use
the
corresponding
macros
with
these
parameters
as
arguments
If
your
function
has
more
than
5
parameters
of
type
value
use
CAMLparam5
with
five
of
these
parameters
and
use
one
or
more
calls
to
the
CAMLxparam
macros
for
the
remaining
parameters
CAMLxparam1
to
CAMLxparam5
If
the
function
has
an
argument
x
which
is
an
array
of
value
s
of
length
n
use
CAMLparamN
x
n
to
declare
it
or
CAMLxparamN
x
n
if
you
already
have
a
call
to
CAMLparam
for
some
other
arguments
The
macros
CAMLreturn
CAMLreturn0
and
CAMLreturnT
are
used
to
replace
the
C
keyword
return
any
function
using
a
CAMLparam
macro
on
entry
should
use
CAMLreturn
on
all
exit
points
C
functions
exported
as
OCaml
externals
must
return
a
value
and
they
should
use
CAMLreturn
x
instead
of
return
x
Some
helper
functions
may
manipulate
OCaml
values
yet
return
void
or
another
datatype
void
returning
procedures
should
explicitly
use
CAMLreturn0
and
not
have
any
implicit
return
Helper
functions
returning
C
data
of
some
type
t
should
use
CAMLreturnT
t
x
instead
of
return
x
paragraph
Note
Some
C
compilers
give
bogus
warnings
about
unused
variables
caml
dummy
xxx
at
each
use
of
CAMLparam
and
CAMLlocal
You
should
ignore
them
goodbreak
Examples
begin
verbatim
CAMLprim
value
my
external
value
v1
value
v2
value
v3
CAMLparam3
v1
v2
v3
CAMLreturn
Val
unit
static
void
helper
procedure
value
v1
value
v2
CAMLparam2
v1
v2
CAMLreturn0
static
int
helper
function
value
v1
value
v2
CAMLparam2
v1
v2
CAMLreturnT
int
0
end
verbatim
paragraph
Note
If
your
function
is
a
primitive
with
more
than
5
arguments
for
use
with
the
byte
code
runtime
its
arguments
are
not
value
s
and
must
not
be
declared
they
have
types
value
and
int
paragraph
Warning
CAMLreturn0
should
only
be
used
for
internal
procedures
that
return
void
CAMLreturn
Val
unit
should
be
used
for
functions
that
return
an
OCaml
unit
value
Primitives
C
functions
that
can
be
called
from
OCaml
should
never
return
void
begin
gcrule
Local
variables
of
type
value
must
be
declared
with
one
of
the
CAMLlocal
macros
Arrays
of
value
s
are
declared
with
CAMLlocalN
These
macros
must
be
used
at
the
beginning
of
the
function
not
in
a
nested
block
Temporaries
are
equivalent
to
local
variables
but
they
cannot
be
registered
with
the
garbage
collector
so
a
temporary
of
type
value
must
not
be
live
when
a
garbage
collection
may
occur
end
gcrule
The
macros
CAMLlocal1
to
CAMLlocal5
declare
and
initialize
one
to
five
local
variables
of
type
value
The
variable
names
are
given
as
arguments
to
the
macros
CAMLlocalN
var
x
var
n
declares
and
initializes
a
local
variable
of
type
value
var
n
You
can
use
several
calls
to
these
macros
if
you
have
more
than
5
local
variables
Example
begin
verbatim
CAMLprim
value
bar
value
v1
value
v2
value
v3
CAMLparam3
v1
v2
v3
CAMLlocal1
result
result
caml
alloc
3
0
CAMLreturn
result
end
verbatim
paragraph
Warning
CAMLlocal
and
CAMLxparam
can
only
be
called
emph
after
CAMLparam
If
a
function
declares
local
values
but
takes
no
value
argument
it
should
start
with
CAMLparam0
begin
verbatim
static
value
foo
int
n
CAMLparam0
CAMLlocal
result
CAMLreturn
result
end
verbatim
begin
gcrule
Assignments
to
the
fields
of
structured
blocks
must
be
done
with
the
Store
field
macro
for
normal
blocks
Store
double
array
field
macro
for
float
array
values
or
Store
double
flat
field
for
floatarray
values
and
records
of
floating
point
numbers
Other
assignments
must
not
use
Store
field
Store
double
array
field
nor
Store
double
flat
field
end
gcrule
Store
field
var
b
var
n
var
v
stores
the
value
var
v
in
the
field
number
var
n
of
value
var
b
which
must
be
a
block
i
e
Is
block
var
b
must
be
true
Example
begin
verbatim
CAMLprim
value
bar
value
v1
value
v2
value
v3
CAMLparam3
v1
v2
v3
CAMLlocal1
result
result
caml
alloc
3
0
Store
field
result
0
v1
Store
field
result
1
v2
Store
field
result
2
v3
CAMLreturn
result
end
verbatim
paragraph
Warning
The
first
argument
of
Store
field
and
Store
double
field
must
be
a
variable
declared
by
CAMLparam
or
a
parameter
declared
by
CAMLlocal
to
ensure
that
a
garbage
collection
triggered
by
the
evaluation
of
the
other
arguments
will
not
invalidate
the
first
argument
after
it
is
computed
paragraph
Use
with
CAMLlocalN
Arrays
of
values
declared
using
CAMLlocalN
must
not
be
written
to
using
Store
field
Use
the
normal
C
array
syntax
instead
begin
gcrule
Global
variables
containing
values
must
be
registered
with
the
garbage
collector
using
the
caml
register
global
root
function
save
that
global
variables
and
locations
that
will
only
ever
contain
OCaml
integers
and
never
pointers
do
not
have
to
be
registered
The
same
is
true
for
any
memory
location
outside
the
OCaml
heap
that
contains
a
value
and
is
not
guaranteed
to
be
reachable
for
as
long
as
it
contains
such
value
from
either
another
registered
global
variable
or
location
local
variable
declared
with
CAMLlocal
or
function
parameter
declared
with
CAMLparam
end
gcrule
Registration
of
a
global
variable
v
is
achieved
by
calling
caml
register
global
root
v
just
before
or
just
after
a
valid
value
is
stored
in
v
for
the
first
time
likewise
registration
of
an
arbitrary
location
p
is
achieved
by
calling
caml
register
global
root
p
You
must
not
call
any
of
the
OCaml
runtime
functions
or
macros
between
registering
and
storing
the
value
Neither
must
you
store
anything
in
the
variable
v
likewise
the
location
p
that
is
not
a
valid
value
The
registration
causes
the
contents
of
the
variable
or
memory
location
to
be
updated
by
the
garbage
collector
whenever
the
value
in
such
variable
or
location
is
moved
within
the
OCaml
heap
In
the
presence
of
threads
care
must
be
taken
to
ensure
appropriate
synchronisation
with
the
OCaml
runtime
to
avoid
a
race
condition
against
the
garbage
collector
when
reading
or
writing
the
value
See
section
ref
ss
parallel
execution
long
running
c
code
A
registered
global
variable
v
can
be
un
registered
by
calling
caml
remove
global
root
v
If
the
contents
of
the
global
variable
v
are
seldom
modified
after
registration
better
performance
can
be
achieved
by
calling
caml
register
generational
global
root
v
to
register
v
after
its
initialization
with
a
valid
value
but
before
any
allocation
or
call
to
the
GC
functions
and
caml
remove
generational
global
root
v
to
un
register
it
In
this
case
you
must
not
modify
the
value
of
v
directly
but
you
must
use
caml
modify
generational
global
root
v
x
to
set
it
to
x
The
garbage
collector
takes
advantage
of
the
guarantee
that
v
is
not
modified
between
calls
to
caml
modify
generational
global
root
to
scan
it
less
often
This
improves
performance
if
the
modifications
of
v
happen
less
often
than
minor
collections
paragraph
Note
The
CAML
macros
use
identifiers
local
variables
type
identifiers
structure
tags
that
start
with
caml
Do
not
use
any
identifier
starting
with
caml
in
your
programs
subsection
ss
c
low
level
gc
harmony
Low
level
interface
Il
faudrait
simplifier
violemment
ce
qui
suit
En
gros
dire
quand
on
n
a
pas
besoin
de
declarer
les
variables
et
dans
quels
cas
on
peut
se
passer
de
Store
field
We
now
give
the
GC
rules
corresponding
to
the
low
level
allocation
functions
caml
alloc
small
and
caml
alloc
shr
You
can
ignore
those
rules
if
you
stick
to
the
simplified
allocation
function
caml
alloc
begin
gcrule
After
a
structured
block
a
block
with
tag
less
than
No
scan
tag
is
allocated
with
the
low
level
functions
all
fields
of
this
block
must
be
filled
with
well
formed
values
before
the
next
allocation
operation
If
the
block
has
been
allocated
with
caml
alloc
small
filling
is
performed
by
direct
assignment
to
the
fields
of
the
block
begin
alltt
Field
var
v
var
n
nth
v
n
end
alltt
If
the
block
has
been
allocated
with
caml
alloc
shr
filling
is
performed
through
the
caml
initialize
function
begin
alltt
caml
initialize
Field
var
v
var
n
nth
v
n
end
alltt
end
gcrule
The
next
allocation
can
trigger
a
garbage
collection
The
garbage
collector
assumes
that
all
structured
blocks
contain
well
formed
values
Newly
created
blocks
contain
random
data
which
generally
do
not
represent
well
formed
values
If
you
really
need
to
allocate
before
the
fields
can
receive
their
final
value
first
initialize
with
a
constant
value
e
g
Val
unit
then
allocate
then
modify
the
fields
with
the
correct
value
see
rule
6
begin
gcrule
Local
variables
and
function
parameters
containing
values
must
be
registered
with
the
garbage
collector
using
the
Begin
roots
and
End
roots
macros
if
they
are
to
survive
a
call
to
an
allocation
function
end
gcrule
Registration
is
performed
with
the
Begin
roots
set
of
macros
Begin
roots1
var
v
registers
variable
var
v
with
the
garbage
collector
Generally
var
v
will
be
a
local
variable
or
a
parameter
of
your
function
It
must
be
initialized
to
a
valid
value
e
g
Val
unit
before
the
first
allocation
Likewise
Begin
roots2
ldots
Begin
roots5
let
you
register
up
to
5
variables
at
the
same
time
Begin
root
is
the
same
as
Begin
roots1
Begin
roots
block
var
ptr
var
size
allows
you
to
register
an
array
of
roots
var
ptr
is
a
pointer
to
the
first
element
and
var
size
is
the
number
of
elements
in
the
array
Once
registered
each
of
your
variables
or
array
element
has
the
following
properties
if
it
points
to
a
heap
allocated
block
this
block
and
its
contents
will
not
be
reclaimed
moreover
if
this
block
is
relocated
by
the
garbage
collector
the
variable
is
updated
to
point
to
the
new
location
for
the
block
Each
of
the
Begin
roots
macros
open
a
C
block
that
must
be
closed
with
a
matching
End
roots
at
the
same
nesting
level
The
block
must
be
exited
normally
i
e
not
with
return
or
goto
However
the
roots
are
automatically
un
registered
if
an
OCaml
exception
is
raised
so
you
can
exit
the
block
with
failwith
invalid
argument
or
one
of
the
raise
functions
bf
Note
The
Begin
roots
macros
use
a
local
variable
and
a
structure
tag
named
caml
roots
block
Do
not
use
this
identifier
in
your
programs
begin
gcrule
Direct
assignment
to
a
field
of
a
block
as
in
begin
alltt
Field
var
v
var
n
var
w
end
alltt
is
safe
only
if
var
v
is
a
block
newly
allocated
by
caml
alloc
small
that
is
if
no
allocation
took
place
between
the
allocation
of
var
v
and
the
assignment
to
the
field
In
all
other
cases
never
assign
directly
If
the
block
has
just
been
allocated
by
caml
alloc
shr
use
caml
initialize
to
assign
a
value
to
a
field
for
the
first
time
begin
alltt
caml
initialize
Field
var
v
var
n
var
w
end
alltt
Otherwise
you
are
updating
a
field
that
previously
contained
a
well
formed
value
then
call
the
caml
modify
function
begin
alltt
caml
modify
Field
var
v
var
n
var
w
end
alltt
end
gcrule
To
illustrate
the
rules
above
here
is
a
C
function
that
builds
and
returns
a
list
containing
the
two
integers
given
as
parameters
First
we
write
it
using
the
simplified
allocation
functions
begin
verbatim
value
alloc
list
int
int
i1
int
i2
CAMLparam0
CAMLlocal2
result
r
r
caml
alloc
2
0
Allocate
a
cons
cell
Store
field
r
0
Val
int
i2
car
the
integer
i2
Store
field
r
1
Val
emptylist
cdr
the
empty
list
result
caml
alloc
2
0
Allocate
the
other
cons
cell
Store
field
result
0
Val
int
i1
car
the
integer
i1
Store
field
result
1
r
cdr
the
first
cons
cell
CAMLreturn
result
end
verbatim
Here
the
registering
of
result
is
not
strictly
needed
because
no
allocation
takes
place
after
it
gets
its
value
but
it
s
easier
and
safer
to
simply
register
all
the
local
variables
that
have
type
value
Here
is
the
same
function
written
using
the
low
level
allocation
functions
We
notice
that
the
cons
cells
are
small
blocks
and
can
be
allocated
with
caml
alloc
small
and
filled
by
direct
assignments
on
their
fields
begin
verbatim
value
alloc
list
int
int
i1
int
i2
CAMLparam0
CAMLlocal2
result
r
r
caml
alloc
small
2
0
Allocate
a
cons
cell
Field
r
0
Val
int
i2
car
the
integer
i2
Field
r
1
Val
emptylist
cdr
the
empty
list
result
caml
alloc
small
2
0
Allocate
the
other
cons
cell
Field
result
0
Val
int
i1
car
the
integer
i1
Field
result
1
r
cdr
the
first
cons
cell
CAMLreturn
result
end
verbatim
In
the
two
examples
above
the
list
is
built
bottom
up
Here
is
an
alternate
way
that
proceeds
top
down
It
is
less
efficient
but
illustrates
the
use
of
caml
modify
begin
verbatim
value
alloc
list
int
int
i1
int
i2
CAMLparam0
CAMLlocal2
tail
r
r
caml
alloc
small
2
0
Allocate
a
cons
cell
Field
r
0
Val
int
i1
car
the
integer
i1
Field
r
1
Val
int
0
A
dummy
value
tail
caml
alloc
small
2
0
Allocate
the
other
cons
cell
Field
tail
0
Val
int
i2
car
the
integer
i2
Field
tail
1
Val
emptylist
cdr
the
empty
list
caml
modify
Field
r
1
tail
cdr
of
the
result
tail
CAMLreturn
r
end
verbatim
It
would
be
incorrect
to
perform
Field
r
1
tail
directly
because
the
allocation
of
tail
has
taken
place
since
r
was
allocated
subsection
ss
c
process
pending
actions
Pending
actions
and
asynchronous
exceptions
Since
4
10
allocation
functions
are
guaranteed
not
to
run
any
OCaml
code
including
finalisers
signal
handlers
and
other
threads
running
on
the
same
domain
Instead
their
execution
is
delayed
to
a
later
safe
point
The
function
verb
caml
process
pending
actions
from
caml
signals
h
executes
any
pending
signal
handlers
and
finalisers
Memprof
callbacks
preemptive
systhread
switching
and
requested
minor
and
major
garbage
collections
In
particular
it
can
raise
asynchronous
exceptions
and
cause
mutations
on
the
OCaml
heap
from
the
same
domain
It
is
recommended
to
call
it
regularly
at
safe
points
inside
long
running
non
blocking
C
code
The
function
verb
caml
process
pending
actions
res
returns
the
exception
instead
of
raising
it
directly
into
OCaml
code
This
is
represented
by
a
different
C
type
caml
result
rather
than
value
The
result
can
be
tested
using
caml
result
is
exception
followed
by
some
cleanup
logic
and
finally
caml
get
value
or
raise
which
returns
the
value
here
just
a
unit
value
ignored
or
raises
the
exception
begin
verbatim
CAMLlocalresult
res
res
caml
process
pending
actions
res
if
caml
result
is
exception
res
cleanup
void
caml
get
value
or
raise
res
end
verbatim
For
more
details
on
caml
result
see
section
ref
ss
c
result
section
s
c
intf
example
A
complete
example
This
section
outlines
how
the
functions
from
the
Unix
curses
library
can
be
made
available
to
OCaml
programs
First
of
all
here
is
the
interface
curses
ml
that
declares
the
curses
primitives
and
data
types
begin
verbatim
File
curses
ml
declaration
of
primitives
and
data
types
type
window
The
type
window
remains
abstract
external
initscr
unit
window
caml
curses
initscr
external
endwin
unit
unit
caml
curses
endwin
external
refresh
unit
unit
caml
curses
refresh
external
wrefresh
window
unit
caml
curses
wrefresh
external
newwin
int
int
int
int
window
caml
curses
newwin
external
addch
char
unit
caml
curses
addch
external
mvwaddch
window
int
int
char
unit
caml
curses
mvwaddch
external
addstr
string
unit
caml
curses
addstr
external
mvwaddstr
window
int
int
string
unit
caml
curses
mvwaddstr
lots
more
omitted
end
verbatim
To
compile
this
interface
begin
verbatim
ocamlc
c
curses
ml
end
verbatim
To
implement
these
functions
we
just
have
to
provide
the
stub
code
the
core
functions
are
already
implemented
in
the
curses
library
The
stub
code
file
curses
stubs
c
looks
like
this
begin
verbatim
File
curses
stubs
c
stub
code
for
curses
include
curses
h
include
caml
mlvalues
h
include
caml
memory
h
include
caml
alloc
h
include
caml
custom
h
Encapsulation
of
opaque
window
handles
of
type
WINDOW
as
OCaml
custom
blocks
static
struct
custom
operations
curses
window
ops
fr
inria
caml
curses
windows
custom
finalize
default
custom
compare
default
custom
hash
default
custom
serialize
default
custom
deserialize
default
custom
compare
ext
default
custom
fixed
length
default
Accessing
the
WINDOW
part
of
an
OCaml
custom
block
define
Window
val
v
WINDOW
Data
custom
val
v
Allocating
an
OCaml
custom
block
to
hold
the
given
WINDOW
static
value
alloc
window
WINDOW
w
value
v
caml
alloc
custom
curses
window
ops
sizeof
WINDOW
0
1
Window
val
v
w
return
v
CAMLprim
value
caml
curses
initscr
value
unit
CAMLparam1
unit
CAMLreturn
alloc
window
initscr
CAMLprim
value
caml
curses
endwin
value
unit
CAMLparam1
unit
endwin
CAMLreturn
Val
unit
CAMLprim
value
caml
curses
refresh
value
unit
CAMLparam1
unit
refresh
CAMLreturn
Val
unit
CAMLprim
value
caml
curses
wrefresh
value
win
CAMLparam1
win
wrefresh
Window
val
win
CAMLreturn
Val
unit
CAMLprim
value
caml
curses
newwin
value
nlines
value
ncols
value
x0
value
y0
CAMLparam4
nlines
ncols
x0
y0
CAMLreturn
alloc
window
newwin
Int
val
nlines
Int
val
ncols
Int
val
x0
Int
val
y0
CAMLprim
value
caml
curses
addch
value
c
CAMLparam1
c
addch
Int
val
c
Characters
are
encoded
like
integers
CAMLreturn
Val
unit
CAMLprim
value
caml
curses
mvwaddch
value
win
value
x
value
y
value
c
CAMLparam4
win
x
y
c
mvwaddch
Window
val
win
Int
val
x
Int
val
y
Int
val
c
CAMLreturn
Val
unit
CAMLprim
value
caml
curses
addstr
value
s
CAMLparam1
s
addstr
String
val
s
CAMLreturn
Val
unit
CAMLprim
value
caml
curses
mvwaddstr
value
win
value
x
value
y
value
s
CAMLparam4
win
x
y
s
mvwaddstr
Window
val
win
Int
val
x
Int
val
y
String
val
s
CAMLreturn
Val
unit
This
goes
on
for
pages
end
verbatim
The
file
curses
stubs
c
can
be
compiled
with
begin
verbatim
cc
c
I
ocamlc
where
curses
stubs
c
end
verbatim
or
even
simpler
begin
verbatim
ocamlc
c
curses
stubs
c
end
verbatim
When
passed
a
c
file
the
ocamlc
command
simply
calls
the
C
compiler
on
that
file
with
the
right
I
option
Now
here
is
a
sample
OCaml
program
prog
ml
that
uses
the
curses
module
begin
verbatim
File
prog
ml
main
program
using
curses
open
Curses
let
main
window
initscr
in
let
small
window
newwin
10
5
20
10
in
mvwaddstr
main
window
10
2
Hello
mvwaddstr
small
window
4
3
world
refresh
Unix
sleep
5
endwin
end
verbatim
To
compile
and
link
this
program
run
begin
verbatim
ocamlc
custom
o
prog
unix
cma
curses
cmo
prog
ml
curses
stubs
o
cclib
lcurses
end
verbatim
On
some
machines
you
may
need
to
put
cclib
lcurses
cclib
ltermcap
or
cclib
ltermcap
instead
of
cclib
lcurses
Note
by
Damien
when
I
launch
the
program
it
only
displays
Hello
and
not
world
Why
section
s
c
callback
Advanced
topic
callbacks
from
C
to
OCaml
So
far
we
have
described
how
to
call
C
functions
from
OCaml
In
this
section
we
show
how
C
functions
can
call
OCaml
functions
either
as
callbacks
OCaml
calls
C
which
calls
OCaml
or
with
the
main
program
written
in
C
subsection
ss
c
callbacks
Applying
OCaml
closures
from
C
C
functions
can
apply
OCaml
function
values
closures
to
OCaml
values
The
following
functions
are
provided
to
perform
the
applications
begin
itemize
item
caml
callback
var
f
a
applies
the
functional
value
var
f
to
the
value
var
a
and
returns
the
value
returned
by
var
f
item
caml
callback2
var
f
a
b
applies
the
functional
value
var
f
which
is
assumed
to
be
a
curried
OCaml
function
with
two
arguments
to
var
a
and
var
b
item
caml
callback3
var
f
a
b
c
applies
the
functional
value
var
f
a
curried
OCaml
function
with
three
arguments
to
var
a
var
b
and
var
c
item
caml
callbackN
var
f
n
args
applies
the
functional
value
var
f
to
the
var
n
arguments
contained
in
the
C
array
of
values
var
args
end
itemize
If
the
function
var
f
does
not
return
but
raises
an
exception
that
escapes
the
scope
of
the
application
then
this
exception
is
propagated
to
the
next
enclosing
OCaml
code
skipping
over
the
C
code
That
is
if
an
OCaml
function
var
f
calls
a
C
function
var
g
that
calls
back
an
OCaml
function
var
h
that
raises
a
stray
exception
then
the
execution
of
var
g
is
interrupted
and
the
exception
is
propagated
back
into
var
f
subsection
ss
c
result
caml
result
resource
cleanup
on
OCaml
exceptions
If
the
OCaml
function
called
with
caml
callback
or
caml
process
pending
actions
as
mentioned
in
Section
ref
ss
c
process
pending
actions
raises
an
exception
the
C
caller
will
be
interrupted
immediately
to
return
to
the
closest
OCaml
exception
handler
This
is
often
the
wrong
behavior
if
the
C
caller
needs
to
run
some
resource
cleanup
logic
to
terminate
safely
The
OCaml
FFI
provides
an
alternative
API
to
call
OCaml
code
from
C
that
returns
a
value
of
type
caml
result
instead
of
value
A
C
value
of
type
caml
result
is
either
an
OCaml
value
returned
correctly
by
the
OCaml
function
or
an
OCaml
exception
raised
by
the
OCaml
function
The
C
caller
can
run
any
cleanup
logic
before
re
raising
the
exception
if
any
or
continuing
the
computation
caml
result
values
can
be
manipulated
using
the
following
functions
and
macros
begin
itemize
item
value
caml
get
value
or
raise
caml
result
var
res
in
fail
h
returns
the
value
contained
in
var
res
or
reraises
the
exception
it
contains
In
particular
void
caml
get
value
or
raise
res
can
be
used
to
ignore
an
OCaml
result
of
type
unit
yet
propagate
exceptions
to
the
caller
item
Result
value
value
var
v
in
mlvalues
h
is
the
result
that
represents
returning
the
value
var
v
item
Result
exception
value
var
exn
in
mlvalues
h
is
the
result
that
represents
raising
the
exception
var
exn
item
int
caml
result
is
exception
caml
result
var
res
in
mlvalues
h
is
true
if
var
res
represents
an
exception
item
The
macro
CAMLlocalresult
foo
in
memory
h
is
the
caml
result
counterpart
of
CAMLlocal1
it
declares
a
local
variable
of
type
caml
result
whose
content
is
tracked
by
the
OCaml
GC
Just
like
CAMLlocal1
it
can
only
be
used
between
a
CAMLparam
macro
and
CAMLreturn
or
CAMLreturnT
macros
There
is
no
equivalent
of
CAMLlocal2
CAMLlocal3
etc
but
the
macro
can
be
used
several
times
end
itemize
For
convenience
Result
unit
is
defined
as
Result
value
Val
unit
By
convention
result
returning
C
functions
have
their
name
suffixed
with
res
for
example
caml
callback2
res
and
caml
process
pending
actions
res
Some
examples
begin
verbatim
include
caml
mlvalues
h
for
the
caml
result
type
caml
result
is
exception
include
caml
memory
h
CAMLlocalresult
include
caml
callback
h
caml
callback
res
include
caml
fail
h
caml
get
value
or
raise
include
caml
alloc
h
caml
alloc
2
This
function
calls
an
OCaml
callback
and
returns
the
value
or
reraises
the
exception
value
logging
callback
value
f
value
arg
CAMLparam2
f
arg
CAMLlocalresult
res
printf
Start
callback
n
res
caml
callback
res
f
arg
printf
End
callback
n
CAMLreturn
caml
get
value
or
raise
res
This
function
assumes
that
the
callback
returns
a
unit
value
and
ignores
it
or
reraises
its
exception
It
must
be
called
by
C
as
it
does
not
return
a
value
but
the
caller
cannot
handle
exceptions
as
they
are
raised
directly
void
logging
unit
callback
value
f
value
arg
CAMLparam2
f
arg
CAMLlocalresult
res
printf
Start
unit
callback
n
res
caml
callback
res
f
arg
printf
End
callback
n
void
caml
get
value
or
raise
res
CAMLreturn0
This
function
calls
a
callback
on
two
arguments
in
turn
and
returns
the
pair
of
values
it
does
not
reraise
exceptions
but
returns
a
caml
result
instead
letting
its
own
C
caller
perform
its
own
cleanup
caml
result
two
callbacks
res
value
f
value
arg1
value
arg2
CAMLparam3
f
arg1
arg2
CAMLlocalresult
res
CAMLlocal3
v1
v2
pair
res
caml
callback
res
f
arg1
early
exit
on
exception
if
caml
result
is
exception
res
CAMLreturnT
caml
result
res
v1
caml
get
value
or
raise
res
res
caml
callback
res
f
arg2
if
caml
result
is
exception
res
CAMLreturnT
caml
result
res
v2
caml
get
value
or
raise
res
build
the
pair
of
values
and
wrap
it
in
a
caml
result
pair
caml
alloc
2
0
v1
v2
res
Result
value
pair
CAMLreturnT
caml
result
res
end
verbatim
paragraph
Compatibility
The
caml
result
type
is
available
since
OCaml
5
3
Older
versions
of
OCaml
use
an
unsafe
concept
of
encoded
exceptions
suffix
exn
operations
Is
exception
result
and
Extract
exception
which
are
of
type
value
but
are
not
valid
OCaml
values
and
can
crash
the
GC
if
they
are
not
extracted
immediately
by
the
caller
We
strongly
recommend
using
caml
result
instead
to
have
a
clear
separation
between
valid
values
and
reified
exceptions
at
distinct
C
types
but
the
older
approach
remains
available
for
backwards
compatibility
subsection
ss
c
closures
Obtaining
or
registering
OCaml
closures
for
use
in
C
functions
There
are
two
ways
to
obtain
OCaml
function
values
closures
to
be
passed
to
the
callback
functions
described
above
One
way
is
to
pass
the
OCaml
function
as
an
argument
to
a
primitive
function
For
example
if
the
OCaml
code
contains
the
declaration
begin
verbatim
external
apply
a
b
a
b
caml
apply
end
verbatim
the
corresponding
C
stub
can
be
written
as
follows
begin
verbatim
CAMLprim
value
caml
apply
value
vf
value
vx
CAMLparam2
vf
vx
CAMLlocal1
vy
vy
caml
callback
vf
vx
CAMLreturn
vy
end
verbatim
Another
possibility
is
to
use
the
registration
mechanism
provided
by
OCaml
This
registration
mechanism
enables
OCaml
code
to
register
OCaml
functions
under
some
global
name
and
C
code
to
retrieve
the
corresponding
closure
by
this
global
name
On
the
OCaml
side
registration
is
performed
by
evaluating
Callback
register
var
n
var
v
Here
var
n
is
the
global
name
an
arbitrary
string
and
var
v
the
OCaml
value
For
instance
begin
verbatim
let
f
x
print
string
f
is
applied
to
print
int
x
print
newline
let
Callback
register
test
function
f
end
verbatim
On
the
C
side
a
pointer
to
the
value
registered
under
name
var
n
is
obtained
by
calling
caml
named
value
var
n
The
returned
pointer
must
then
be
dereferenced
to
recover
the
actual
OCaml
value
If
no
value
is
registered
under
the
name
var
n
the
null
pointer
is
returned
For
example
here
is
a
C
wrapper
that
calls
the
OCaml
function
f
above
begin
verbatim
void
call
caml
f
int
arg
caml
callback
caml
named
value
test
function
Val
int
arg
end
verbatim
The
pointer
returned
by
caml
named
value
is
constant
and
can
safely
be
cached
in
a
C
variable
to
avoid
repeated
name
lookups
The
value
pointed
to
cannot
be
changed
from
C
However
it
might
change
during
garbage
collection
so
must
always
be
recomputed
at
the
point
of
use
Here
is
a
more
efficient
variant
of
call
caml
f
above
that
calls
caml
named
value
only
once
begin
verbatim
void
call
caml
f
int
arg
static
const
value
closure
f
NULL
if
closure
f
NULL
First
time
around
look
up
by
name
closure
f
caml
named
value
test
function
caml
callback
closure
f
Val
int
arg
end
verbatim
subsection
ss
c
register
exn
Registering
OCaml
exceptions
for
use
in
C
functions
The
registration
mechanism
described
above
can
also
be
used
to
communicate
exception
constructors
from
OCaml
to
C
The
OCaml
code
registers
the
exception
constructor
by
evaluating
Callback
register
exception
var
n
var
exn
where
var
n
is
an
arbitrary
name
and
var
exn
is
an
exception
value
with
the
exception
constructor
to
register
For
example
begin
verbatim
exception
Error
of
string
let
Callback
register
exception
test
exception
Error
any
string
end
verbatim
The
C
code
can
then
recover
the
exception
constructor
using
caml
named
value
and
pass
it
as
first
argument
to
the
functions
raise
constant
raise
with
arg
and
raise
with
string
described
in
section
ref
ss
c
exceptions
to
actually
raise
the
exception
For
example
here
is
a
C
function
that
raises
the
Error
exception
with
the
given
argument
begin
verbatim
void
raise
error
char
msg
caml
raise
with
string
caml
named
value
test
exception
msg
end
verbatim
subsection
ss
main
c
Main
program
in
C
In
normal
operation
a
mixed
OCaml
C
program
starts
by
executing
the
OCaml
initialization
code
which
then
may
proceed
to
call
C
functions
We
say
that
the
main
program
is
the
OCaml
code
In
some
applications
it
is
desirable
that
the
C
code
plays
the
role
of
the
main
program
calling
OCaml
functions
when
needed
This
can
be
achieved
as
follows
begin
itemize
item
The
C
part
of
the
program
must
provide
a
main
function
which
will
override
the
default
main
function
provided
by
the
OCaml
runtime
system
Execution
will
start
in
the
user
defined
main
function
just
like
for
a
regular
C
program
item
At
some
point
the
C
code
must
call
caml
main
argv
to
initialize
the
OCaml
code
The
argv
argument
is
a
C
array
of
strings
type
char
terminated
with
a
NULL
pointer
which
represents
the
command
line
arguments
as
passed
as
second
argument
to
main
The
OCaml
array
Sys
argv
will
be
initialized
from
this
parameter
For
the
bytecode
compiler
argv
0
and
argv
1
are
also
consulted
to
find
the
file
containing
the
bytecode
item
The
call
to
caml
main
initializes
the
OCaml
runtime
system
loads
the
bytecode
in
the
case
of
the
bytecode
compiler
and
executes
the
initialization
code
of
the
OCaml
program
Typically
this
initialization
code
registers
callback
functions
using
Callback
register
Once
the
OCaml
initialization
code
is
complete
control
returns
to
the
C
code
that
called
caml
main
item
The
C
code
can
then
invoke
OCaml
functions
using
the
callback
mechanism
see
section
ref
ss
c
callbacks
end
itemize
subsection
ss
c
embedded
code
Embedding
the
OCaml
code
in
the
C
code
The
bytecode
compiler
in
custom
runtime
mode
ocamlc
custom
normally
appends
the
bytecode
to
the
executable
file
containing
the
custom
runtime
This
has
two
consequences
First
the
final
linking
step
must
be
performed
by
ocamlc
Second
the
OCaml
runtime
library
must
be
able
to
find
the
name
of
the
executable
file
from
the
command
line
arguments
When
using
caml
main
argv
as
in
section
ref
ss
main
c
this
means
that
argv
0
or
argv
1
must
contain
the
executable
file
name
An
alternative
is
to
embed
the
bytecode
in
the
C
code
The
output
obj
and
output
complete
obj
options
to
ocamlc
are
provided
for
this
purpose
They
cause
the
ocamlc
compiler
to
output
a
C
object
file
o
file
obj
under
Windows
containing
the
bytecode
for
the
OCaml
part
of
the
program
as
well
as
a
caml
startup
function
The
C
object
file
produced
by
ocamlc
output
complete
obj
also
contains
the
runtime
and
autolink
libraries
The
C
object
file
produced
by
ocamlc
output
obj
or
ocamlc
output
complete
obj
can
then
be
linked
with
C
code
using
the
standard
C
compiler
or
stored
in
a
C
library
The
caml
startup
function
must
be
called
from
the
main
C
program
in
order
to
initialize
the
OCaml
runtime
and
execute
the
OCaml
initialization
code
Just
like
caml
main
it
takes
one
argv
parameter
containing
the
command
line
parameters
Unlike
caml
main
this
argv
parameter
is
used
only
to
initialize
Sys
argv
but
not
for
finding
the
name
of
the
executable
file
The
caml
startup
function
calls
the
uncaught
exception
handler
or
enters
the
debugger
if
running
under
ocamldebug
if
an
exception
escapes
from
a
top
level
module
initialiser
Such
exceptions
may
be
caught
in
the
C
code
by
instead
using
the
caml
startup
exn
function
and
testing
the
result
using
tt
Is
exception
result
followed
by
tt
Extract
exception
if
appropriate
The
output
obj
and
output
complete
obj
options
can
also
be
used
to
obtain
the
C
source
file
More
interestingly
these
options
can
also
produce
directly
a
shared
library
so
file
dll
under
Windows
that
contains
the
OCaml
code
the
OCaml
runtime
system
and
any
other
static
C
code
given
to
ocamlc
o
a
respectively
obj
lib
This
use
of
output
obj
and
output
complete
obj
is
very
similar
to
a
normal
linking
step
but
instead
of
producing
a
main
program
that
automatically
runs
the
OCaml
code
it
produces
a
shared
library
that
can
run
the
OCaml
code
on
demand
The
three
possible
behaviors
of
output
obj
and
output
complete
obj
to
produce
a
C
source
code
c
a
C
object
file
o
a
shared
library
so
are
selected
according
to
the
extension
of
the
resulting
file
given
with
o
The
native
code
compiler
ocamlopt
also
supports
the
output
obj
and
output
complete
obj
options
causing
it
to
output
a
C
object
file
or
a
shared
library
containing
the
native
code
for
all
OCaml
modules
on
the
command
line
as
well
as
the
OCaml
startup
code
Initialization
is
performed
by
calling
caml
startup
or
caml
startup
exn
as
in
the
case
of
the
bytecode
compiler
The
file
produced
by
ocamlopt
output
complete
obj
also
contains
the
runtime
and
autolink
libraries
For
the
final
linking
phase
in
addition
to
the
object
file
produced
by
output
obj
you
will
have
to
provide
the
OCaml
runtime
library
libcamlrun
a
for
bytecode
libasmrun
a
for
native
code
as
well
as
all
C
libraries
that
are
required
by
the
OCaml
libraries
used
For
instance
assume
the
OCaml
part
of
your
program
uses
the
Unix
library
With
ocamlc
you
should
do
begin
alltt
ocamlc
output
obj
o
camlcode
o
unix
cma
it
other
cmo
it
and
cma
it
files
cc
o
myprog
it
C
objects
and
libraries
char92
camlcode
o
L
ocamlc
where
lunix
lcamlrun
end
alltt
With
ocamlopt
you
should
do
begin
alltt
ocamlopt
output
obj
o
camlcode
o
unix
cmxa
it
other
cmx
it
and
cmxa
it
files
cc
o
myprog
it
C
objects
and
libraries
char92
camlcode
o
L
ocamlc
where
lunix
lasmrun
end
alltt
This
seems
completely
wrong
Damien
The
shared
libraries
produced
by
ocamlc
output
obj
or
by
ocamlopt
output
obj
already
contains
the
OCaml
runtime
library
as
well
as
all
the
needed
C
libraries
For
the
final
linking
phase
in
addition
to
the
object
file
produced
by
output
complete
obj
you
will
have
only
to
provide
the
C
libraries
required
by
the
OCaml
runtime
For
instance
assume
the
OCaml
part
of
your
program
uses
the
Unix
library
With
ocamlc
you
should
do
begin
alltt
ocamlc
output
complete
obj
o
camlcode
o
unix
cma
it
other
cmo
it
and
cma
it
files
cc
o
myprog
it
C
objects
and
libraries
char92
camlcode
o
it
C
libraries
required
by
the
runtime
eg
lm
ldl
lcurses
lpthread
end
alltt
With
ocamlopt
you
should
do
begin
alltt
ocamlopt
output
complete
obj
o
camlcode
o
unix
cmxa
it
other
cmx
it
and
cmxa
it
files
cc
o
myprog
it
C
objects
and
libraries
char92
camlcode
o
it
C
libraries
required
by
the
runtime
eg
lm
ldl
end
alltt
paragraph
Warning
On
some
ports
special
options
are
required
on
the
final
linking
phase
that
links
together
the
object
file
produced
by
the
output
obj
and
output
complete
obj
options
and
the
remainder
of
the
program
Those
options
are
shown
in
the
configuration
file
Makefile
config
generated
during
compilation
of
OCaml
as
the
variable
OC
LDFLAGS
begin
itemize
item
Windows
with
the
MSVC
compiler
the
object
file
produced
by
OCaml
have
been
compiled
with
the
MD
flag
and
therefore
all
other
object
files
linked
with
it
should
also
be
compiled
with
MD
item
other
systems
you
may
have
to
add
one
or
both
of
lm
and
ldl
depending
on
your
OS
and
C
compiler
end
itemize
paragraph
Stack
backtraces
When
OCaml
bytecode
produced
by
ocamlc
g
is
embedded
in
a
C
program
no
debugging
information
is
included
and
therefore
it
is
impossible
to
print
stack
backtraces
on
uncaught
exceptions
This
is
not
the
case
when
native
code
produced
by
ocamlopt
g
is
embedded
in
a
C
program
stack
backtrace
information
is
available
but
the
backtrace
mechanism
needs
to
be
turned
on
programmatically
This
can
be
achieved
from
the
OCaml
side
by
calling
Printexc
record
backtrace
true
in
the
initialization
of
one
of
the
OCaml
modules
This
can
also
be
achieved
from
the
C
side
by
calling
caml
record
backtraces
1
in
the
OCaml
C
glue
code
caml
record
backtraces
is
declared
in
backtrace
h
paragraph
Unloading
the
runtime
In
case
the
shared
library
produced
with
output
obj
is
to
be
loaded
and
unloaded
repeatedly
by
a
single
process
care
must
be
taken
to
unload
the
OCaml
runtime
explicitly
in
order
to
avoid
various
system
resource
leaks
Since
4
05
caml
shutdown
function
can
be
used
to
shut
the
runtime
down
gracefully
which
equals
the
following
begin
itemize
item
Running
the
functions
that
were
registered
with
Stdlib
at
exit
item
Triggering
finalization
of
allocated
custom
blocks
see
section
ref
s
c
custom
For
example
Stdlib
in
channel
and
Stdlib
out
channel
are
represented
by
custom
blocks
that
enclose
file
descriptors
which
are
to
be
released
item
Unloading
the
dependent
shared
libraries
that
were
loaded
by
the
runtime
including
dynlink
plugins
item
Freeing
the
memory
blocks
that
were
allocated
by
the
runtime
with
malloc
Inside
C
primitives
it
is
advised
to
use
caml
stat
functions
from
memory
h
for
managing
static
that
is
non
moving
blocks
of
heap
memory
as
all
the
blocks
allocated
with
these
functions
are
automatically
freed
by
caml
shutdown
For
ensuring
compatibility
with
legacy
C
stubs
that
have
used
caml
stat
incorrectly
this
behaviour
is
only
enabled
if
the
runtime
is
started
with
a
specialized
caml
startup
pooled
function
end
itemize
As
a
shared
library
may
have
several
clients
simultaneously
it
is
made
for
convenience
that
caml
startup
and
caml
startup
pooled
may
be
called
multiple
times
given
that
each
such
call
is
paired
with
a
corresponding
call
to
caml
shutdown
in
a
nested
fashion
The
runtime
will
be
unloaded
once
there
are
no
outstanding
calls
to
caml
startup
Once
a
runtime
is
unloaded
it
cannot
be
started
up
again
without
reloading
the
shared
library
and
reinitializing
its
static
data
Therefore
at
the
moment
the
facility
is
only
useful
for
building
reloadable
shared
libraries
paragraph
Unix
signal
handling
Depending
on
the
target
platform
and
operating
system
the
native
code
runtime
system
may
install
signal
handlers
for
one
or
several
of
the
SIGSEGV
SIGTRAP
and
SIGFPE
signals
when
caml
startup
is
called
and
reset
these
signals
to
their
default
behaviors
when
caml
shutdown
is
called
The
main
program
written
in
C
should
not
try
to
handle
these
signals
itself
section
s
c
advexample
Advanced
example
with
callbacks
This
section
illustrates
the
callback
facilities
described
in
section
ref
s
c
callback
We
are
going
to
package
some
OCaml
functions
in
such
a
way
that
they
can
be
linked
with
C
code
and
called
from
C
just
like
any
C
functions
The
OCaml
functions
are
defined
in
the
following
mod
ml
OCaml
source
begin
verbatim
File
mod
ml
some
useful
OCaml
functions
let
rec
fib
n
if
n
2
then
n
else
fib
n
1
fib
n
2
let
format
result
n
Printf
sprintf
Result
is
d
n
n
Export
those
two
functions
to
C
let
Callback
register
fib
fib
let
Callback
register
format
result
format
result
end
verbatim
Here
is
the
C
stub
code
for
calling
these
functions
from
C
begin
verbatim
File
modwrap
c
wrappers
around
the
OCaml
functions
include
stdio
h
include
string
h
include
caml
mlvalues
h
include
caml
callback
h
int
fib
int
n
static
const
value
fib
closure
NULL
if
fib
closure
NULL
fib
closure
caml
named
value
fib
return
Int
val
caml
callback
fib
closure
Val
int
n
char
format
result
int
n
static
const
value
format
result
closure
NULL
if
format
result
closure
NULL
format
result
closure
caml
named
value
format
result
return
strdup
String
val
caml
callback
format
result
closure
Val
int
n
We
copy
the
C
string
returned
by
String
val
to
the
C
heap
so
that
it
remains
valid
after
garbage
collection
end
verbatim
We
now
compile
the
OCaml
code
to
a
C
object
file
and
put
it
in
a
C
library
along
with
the
stub
code
in
modwrap
c
and
the
OCaml
runtime
system
begin
verbatim
ocamlc
custom
output
obj
o
modcaml
o
mod
ml
ocamlc
c
modwrap
c
cp
ocamlc
where
libcamlrun
a
mod
a
chmod
w
mod
a
ar
r
mod
a
modcaml
o
modwrap
o
end
verbatim
One
can
also
use
ocamlopt
output
obj
instead
of
ocamlc
custom
output
obj
In
this
case
replace
libcamlrun
a
the
bytecode
runtime
library
by
libasmrun
a
the
native
code
runtime
library
Now
we
can
use
the
two
functions
fib
and
format
result
in
any
C
program
just
like
regular
C
functions
Just
remember
to
call
caml
startup
or
caml
startup
exn
once
before
begin
verbatim
File
main
c
a
sample
client
for
the
OCaml
functions
include
stdio
h
include
caml
callback
h
extern
int
fib
int
n
extern
char
format
result
int
n
int
main
int
argc
char
argv
int
result
Initialize
OCaml
code
caml
startup
argv
Do
some
computation
result
fib
10
printf
fib
10
s
n
format
result
result
return
0
end
verbatim
To
build
the
whole
program
just
invoke
the
C
compiler
as
follows
begin
verbatim
cc
o
prog
I
ocamlc
where
main
c
mod
a
lcurses
end
verbatim
On
some
machines
you
may
need
to
put
ltermcap
or
lcurses
ltermcap
instead
of
lcurses
section
s
c
custom
Advanced
topic
custom
blocks
Blocks
with
tag
Custom
tag
start
with
a
pointer
to
a
C
struct
with
type
struct
custom
operations
that
associates
user
provided
finalization
comparison
hashing
serialization
and
deserialization
functions
for
this
block
After
this
pointer
to
custom
operations
there
can
be
arbitrary
data
of
zero
one
or
more
words
whose
semantics
is
defined
by
the
user
for
example
this
can
be
just
a
pointer
to
a
C
struct
or
a
C
struct
itself
Use
Data
custom
val
on
the
block
value
to
get
a
pointer
on
the
start
of
this
arbitrary
data
subsection
ss
c
custom
ops
The
struct
custom
operations
The
struct
custom
operations
is
defined
in
caml
custom
h
and
contains
the
following
fields
begin
itemize
item
char
identifier
A
zero
terminated
character
string
serving
as
an
identifier
for
serialization
and
deserialization
operations
item
void
finalize
value
v
The
finalize
field
contains
a
pointer
to
a
C
function
that
is
called
when
the
block
becomes
unreachable
and
is
about
to
be
reclaimed
The
block
is
passed
as
first
argument
to
the
function
The
finalize
field
can
also
be
custom
finalize
default
to
indicate
that
no
finalization
function
is
associated
with
the
block
Note
the
caution
below
there
are
many
restrictions
on
the
behaviour
of
these
custom
block
finalizers
For
more
powerful
and
flexible
finalization
use
Gc
finalise
see
stdmoduleref
Gc
item
int
compare
value
v1
value
v2
The
compare
field
contains
a
pointer
to
a
C
function
that
is
called
whenever
two
custom
blocks
are
compared
using
OCaml
s
generic
comparison
operators
and
compare
The
C
function
should
return
0
if
the
data
contained
in
the
two
blocks
are
structurally
equal
a
negative
integer
if
the
data
from
the
first
block
is
less
than
the
data
from
the
second
block
and
a
positive
integer
if
the
data
from
the
first
block
is
greater
than
the
data
from
the
second
block
The
compare
field
can
be
set
to
custom
compare
default
this
default
comparison
function
simply
raises
Failure
item
int
compare
ext
value
v1
value
v2
Since
3
12
1
The
compare
ext
field
contains
a
pointer
to
a
C
function
that
is
called
whenever
one
custom
block
and
one
unboxed
integer
are
compared
using
OCaml
s
generic
comparison
operators
and
compare
As
in
the
case
of
the
compare
field
the
C
function
should
return
0
if
the
two
arguments
are
structurally
equal
a
negative
integer
if
the
first
argument
compares
less
than
the
second
argument
and
a
positive
integer
if
the
first
argument
compares
greater
than
the
second
argument
The
compare
ext
field
can
be
set
to
custom
compare
ext
default
this
default
comparison
function
simply
raises
Failure
item
intnat
hash
value
v
The
hash
field
contains
a
pointer
to
a
C
function
that
is
called
whenever
OCaml
s
generic
hash
operator
see
module
stdmoduleref
Hashtbl
is
applied
to
a
custom
block
The
C
function
can
return
an
arbitrary
integer
representing
the
hash
value
of
the
data
contained
in
the
given
custom
block
The
hash
value
must
be
compatible
with
the
compare
function
in
the
sense
that
two
structurally
equal
data
that
is
two
custom
blocks
for
which
compare
returns
0
must
have
the
same
hash
value
The
hash
field
can
be
set
to
custom
hash
default
in
which
case
the
custom
block
is
ignored
during
hash
computation
item
void
serialize
value
v
uintnat
bsize
32
uintnat
bsize
64
The
serialize
field
contains
a
pointer
to
a
C
function
that
is
called
whenever
the
custom
block
needs
to
be
serialized
marshaled
using
the
OCaml
functions
output
value
or
Marshal
to
For
a
custom
block
those
functions
first
write
the
identifier
of
the
block
as
given
by
the
identifier
field
to
the
output
stream
then
call
the
user
provided
serialize
function
That
function
is
responsible
for
writing
the
data
contained
in
the
custom
block
using
the
serialize
functions
defined
in
caml
intext
h
and
listed
in
section
ref
ss
c
custom
serialization
The
user
provided
serialize
function
must
then
store
in
its
bsize
32
and
bsize
64
parameters
the
sizes
in
bytes
of
the
data
part
of
the
custom
block
on
a
32
bit
architecture
and
on
a
64
bit
architecture
respectively
The
serialize
field
can
be
set
to
custom
serialize
default
in
which
case
the
Failure
exception
is
raised
when
attempting
to
serialize
the
custom
block
item
uintnat
deserialize
void
dst
The
deserialize
field
contains
a
pointer
to
a
C
function
that
is
called
whenever
a
custom
block
with
identifier
identifier
needs
to
be
deserialized
un
marshaled
using
the
OCaml
functions
input
value
or
Marshal
from
This
user
provided
function
is
responsible
for
reading
back
the
data
written
by
the
serialize
operation
using
the
deserialize
functions
defined
in
caml
intext
h
and
listed
in
section
ref
ss
c
custom
serialization
It
must
then
rebuild
the
data
part
of
the
custom
block
and
store
it
at
the
pointer
given
as
the
dst
argument
Finally
it
returns
the
size
in
bytes
of
the
data
part
of
the
custom
block
This
size
must
be
identical
to
the
bsize
32
result
of
the
serialize
operation
if
the
architecture
is
32
bits
or
bsize
64
if
the
architecture
is
64
bits
The
deserialize
field
can
be
set
to
custom
deserialize
default
to
indicate
that
deserialization
is
not
supported
In
this
case
do
not
register
the
struct
custom
operations
with
the
deserializer
using
register
custom
operations
see
below
item
const
struct
custom
fixed
length
fixed
length
Since
4
08
0
Normally
space
in
the
serialized
output
is
reserved
to
write
the
bsize
32
and
bsize
64
fields
returned
by
serialize
However
for
very
short
custom
blocks
this
space
can
be
larger
than
the
data
itself
As
a
space
optimisation
if
serialize
always
returns
the
same
values
for
bsize
32
and
bsize
64
then
these
values
may
be
specified
in
the
fixed
length
structure
and
do
not
consume
space
in
the
serialized
output
end
itemize
emph
Caution
the
finalize
compare
hash
serialize
and
deserialize
functions
attached
to
custom
block
descriptors
are
allowed
only
limited
interactions
with
the
OCaml
runtime
Within
these
functions
do
not
call
any
of
the
OCaml
allocation
functions
and
do
not
perform
any
callback
into
OCaml
code
or
allow
it
to
be
called
for
example
do
not
call
caml
release
runtime
system
Do
not
use
CAMLparam
to
register
the
parameters
to
these
functions
do
not
use
CAMLlocal
to
register
their
local
variables
and
do
not
use
CAMLreturn
to
return
the
result
Do
not
raise
exceptions
To
signal
an
error
during
deserialization
use
caml
deserialize
error
and
serialize
and
deserialize
functions
may
freely
use
the
functions
from
section
ref
ss
c
custom
serialization
There
are
especially
stringent
restrictions
on
the
behavior
of
custom
block
finalizers
In
addition
to
the
restrictions
above
finalizers
must
not
access
the
OCaml
heap
or
mutate
the
OCaml
heap
or
any
memory
reachable
from
OCaml
GC
roots
However
note
that
finalize
functions
may
freely
use
caml
remove
global
root
and
caml
remove
generational
global
root
In
short
if
a
custom
block
finalizer
does
anything
with
the
value
it
receives
other
than
call
Data
custom
val
on
it
then
it
is
probably
unsafe
When
in
doubt
err
on
the
side
of
caution
subsection
ss
c
custom
alloc
Allocating
custom
blocks
Custom
blocks
must
be
allocated
via
caml
alloc
custom
or
caml
alloc
custom
mem
begin
center
caml
alloc
custom
var
ops
var
size
var
used
var
max
end
center
returns
a
fresh
custom
block
with
room
for
var
size
bytes
of
user
data
and
whose
associated
operations
are
given
by
var
ops
a
pointer
to
a
struct
custom
operations
usually
statically
allocated
as
a
C
global
variable
The
two
parameters
var
used
and
var
max
are
used
to
control
the
speed
of
garbage
collection
when
the
finalized
object
contains
pointers
to
out
of
heap
resources
Generally
speaking
the
OCaml
incremental
major
collector
adjusts
its
speed
relative
to
the
allocation
rate
of
the
program
The
faster
the
program
allocates
the
harder
the
GC
works
in
order
to
reclaim
quickly
unreachable
blocks
and
avoid
having
large
amount
of
floating
garbage
unreferenced
objects
that
the
GC
has
not
yet
collected
Normally
the
allocation
rate
is
measured
by
counting
the
in
heap
size
of
allocated
blocks
However
it
often
happens
that
finalized
objects
contain
pointers
to
out
of
heap
memory
blocks
and
other
resources
such
as
file
descriptors
X
Windows
bitmaps
etc
For
those
blocks
the
in
heap
size
of
blocks
is
not
a
good
measure
of
the
quantity
of
resources
allocated
by
the
program
The
two
arguments
var
used
and
var
max
give
the
GC
an
idea
of
how
much
out
of
heap
resources
are
consumed
by
the
finalized
block
being
allocated
you
give
the
amount
of
resources
allocated
to
this
object
as
parameter
var
used
and
the
maximum
amount
that
you
want
to
see
in
floating
garbage
as
parameter
var
max
The
units
are
arbitrary
the
GC
cares
only
about
the
ratio
var
used
var
max
For
instance
if
you
are
allocating
a
finalized
block
holding
an
X
Windows
bitmap
of
var
w
by
var
h
pixels
and
you
d
rather
not
have
more
than
1
mega
pixels
of
unreclaimed
bitmaps
specify
var
used
var
w
var
h
and
var
max
1000000
Another
way
to
describe
the
effect
of
the
var
used
and
var
max
parameters
is
in
terms
of
full
GC
cycles
If
you
allocate
many
custom
blocks
with
var
used
var
max
1
var
N
the
GC
will
then
do
one
full
cycle
examining
every
object
in
the
heap
and
calling
finalization
functions
on
those
that
are
unreachable
every
var
N
allocations
For
instance
if
var
used
1
and
var
max
1000
the
GC
will
do
one
full
cycle
at
least
every
1000
allocations
of
custom
blocks
If
your
finalized
blocks
contain
no
pointers
to
out
of
heap
resources
or
if
the
previous
discussion
made
little
sense
to
you
just
take
var
used
0
and
var
max
1
But
if
you
later
find
that
the
finalization
functions
are
not
called
often
enough
consider
increasing
the
var
used
var
max
ratio
begin
center
caml
alloc
custom
mem
var
ops
var
size
var
used
end
center
Use
this
function
when
your
custom
block
holds
only
out
of
heap
memory
memory
allocated
with
malloc
or
caml
stat
alloc
and
no
other
resources
used
should
be
the
number
of
bytes
of
out
of
heap
memory
that
are
held
by
your
custom
block
This
function
works
like
caml
alloc
custom
except
that
the
max
parameter
is
under
the
control
of
the
user
via
the
custom
major
ratio
custom
minor
ratio
and
custom
minor
max
size
parameters
and
proportional
to
the
heap
sizes
It
has
been
available
since
OCaml
4
08
0
subsection
ss
c
custom
access
Accessing
custom
blocks
The
data
part
of
a
custom
block
var
v
can
be
accessed
via
the
pointer
Data
custom
val
var
v
This
pointer
has
type
void
and
should
be
cast
to
the
actual
type
of
the
data
stored
in
the
custom
block
The
contents
of
custom
blocks
are
not
scanned
by
the
garbage
collector
and
must
therefore
not
contain
any
pointer
inside
the
OCaml
heap
In
other
terms
never
store
an
OCaml
value
in
a
custom
block
and
do
not
use
Field
Store
field
nor
caml
modify
to
access
the
data
part
of
a
custom
block
Conversely
any
C
data
structure
not
containing
heap
pointers
can
be
stored
in
a
custom
block
subsection
ss
c
custom
serialization
Writing
custom
serialization
and
deserialization
functions
The
following
functions
defined
in
caml
intext
h
are
provided
to
write
and
read
back
the
contents
of
custom
blocks
in
a
portable
way
Those
functions
handle
endianness
conversions
when
e
g
data
is
written
on
a
little
endian
machine
and
read
back
on
a
big
endian
machine
begin
tableau
l
p
10cm
Function
Action
entree
caml
serialize
int
1
Write
a
1
byte
integer
entree
caml
serialize
int
2
Write
a
2
byte
integer
entree
caml
serialize
int
4
Write
a
4
byte
integer
entree
caml
serialize
int
8
Write
a
8
byte
integer
entree
caml
serialize
float
4
Write
a
4
byte
float
entree
caml
serialize
float
8
Write
a
8
byte
float
entree
caml
serialize
block
1
Write
an
array
of
1
byte
quantities
entree
caml
serialize
block
2
Write
an
array
of
2
byte
quantities
entree
caml
serialize
block
4
Write
an
array
of
4
byte
quantities
entree
caml
serialize
block
8
Write
an
array
of
8
byte
quantities
entree
caml
deserialize
uint
1
Read
an
unsigned
1
byte
integer
entree
caml
deserialize
sint
1
Read
a
signed
1
byte
integer
entree
caml
deserialize
uint
2
Read
an
unsigned
2
byte
integer
entree
caml
deserialize
sint
2
Read
a
signed
2
byte
integer
entree
caml
deserialize
uint
4
Read
an
unsigned
4
byte
integer
entree
caml
deserialize
sint
4
Read
a
signed
4
byte
integer
entree
caml
deserialize
uint
8
Read
an
unsigned
8
byte
integer
entree
caml
deserialize
sint
8
Read
a
signed
8
byte
integer
entree
caml
deserialize
float
4
Read
a
4
byte
float
entree
caml
deserialize
float
8
Read
an
8
byte
float
entree
caml
deserialize
block
1
Read
an
array
of
1
byte
quantities
entree
caml
deserialize
block
2
Read
an
array
of
2
byte
quantities
entree
caml
deserialize
block
4
Read
an
array
of
4
byte
quantities
entree
caml
deserialize
block
8
Read
an
array
of
8
byte
quantities
entree
caml
deserialize
error
Signal
an
error
during
deserialization
input
value
or
Marshal
from
raise
a
Failure
exception
after
cleaning
up
their
internal
data
structures
end
tableau
Serialization
functions
are
attached
to
the
custom
blocks
to
which
they
apply
Obviously
deserialization
functions
cannot
be
attached
this
way
since
the
custom
block
does
not
exist
yet
when
deserialization
begins
Thus
the
struct
custom
operations
that
contain
deserialization
functions
must
be
registered
with
the
deserializer
in
advance
using
the
register
custom
operations
function
declared
in
caml
custom
h
Deserialization
proceeds
by
reading
the
identifier
off
the
input
stream
allocating
a
custom
block
of
the
size
specified
in
the
input
stream
searching
the
registered
struct
custom
operation
blocks
for
one
with
the
same
identifier
and
calling
its
deserialize
function
to
fill
the
data
part
of
the
custom
block
subsection
ss
c
custom
idents
Choosing
identifiers
Identifiers
in
struct
custom
operations
must
be
chosen
carefully
since
they
must
identify
uniquely
the
data
structure
for
serialization
and
deserialization
operations
In
particular
consider
including
a
version
number
in
the
identifier
this
way
the
format
of
the
data
can
be
changed
later
yet
backward
compatible
deserialisation
functions
can
be
provided
Identifiers
starting
with
an
underscore
character
are
reserved
for
the
OCaml
runtime
system
do
not
use
them
for
your
custom
data
We
recommend
to
use
a
URL
http
mymachine
mydomain
com
mylibrary
version
number
or
a
Java
style
package
name
com
mydomain
mymachine
mylibrary
version
number
as
identifiers
to
minimize
the
risk
of
identifier
collision
subsection
ss
c
finalized
Finalized
blocks
Custom
blocks
generalize
the
finalized
blocks
that
were
present
in
OCaml
prior
to
version
3
00
For
backwards
compatibility
the
format
of
custom
blocks
is
compatible
with
that
of
finalized
blocks
and
the
caml
alloc
final
function
is
still
available
to
allocate
a
custom
block
with
a
given
finalization
function
but
default
comparison
hashing
and
serialization
functions
In
particular
the
finalization
function
must
not
access
the
OCaml
runtime
caml
alloc
final
var
n
var
f
var
used
var
max
returns
a
fresh
custom
block
of
size
var
n
1
words
with
finalization
function
var
f
The
first
word
is
reserved
for
storing
the
custom
operations
the
other
var
n
words
are
available
for
your
data
The
two
parameters
var
used
and
var
max
are
used
to
control
the
speed
of
garbage
collection
as
described
for
caml
alloc
custom
section
s
C
Bigarrays
Advanced
topic
Bigarrays
and
the
OCaml
C
interface
This
section
explains
how
C
stub
code
that
interfaces
C
or
Fortran
code
with
OCaml
code
can
use
Bigarrays
subsection
ss
C
Bigarrays
include
Include
file
The
include
file
caml
bigarray
h
must
be
included
in
the
C
stub
file
It
declares
the
functions
constants
and
macros
discussed
below
subsection
ss
C
Bigarrays
access
Accessing
an
OCaml
bigarray
from
C
or
Fortran
If
var
v
is
a
OCaml
value
representing
a
Bigarray
the
expression
Caml
ba
data
val
var
v
returns
a
pointer
to
the
data
part
of
the
array
This
pointer
is
of
type
void
and
can
be
cast
to
the
appropriate
C
type
for
the
array
e
g
double
char
10
etc
Various
characteristics
of
the
OCaml
Bigarray
can
be
consulted
from
C
as
follows
begin
tableau
l
l
C
expression
Returns
entree
Caml
ba
array
val
var
v
num
dims
number
of
dimensions
entree
Caml
ba
array
val
var
v
dim
var
i
var
i
th
dimension
entree
Caml
ba
array
val
var
v
flags
CAML
BA
KIND
MASK
kind
of
array
elements
end
tableau
The
kind
of
array
elements
is
one
of
the
following
constants
begin
tableau
l
l
Constant
Element
kind
entree
CAML
BA
FLOAT16
16
bit
half
precision
floats
entree
CAML
BA
FLOAT32
32
bit
single
precision
floats
entree
CAML
BA
FLOAT64
64
bit
double
precision
floats
entree
CAML
BA
SINT8
8
bit
signed
integers
entree
CAML
BA
UINT8
8
bit
unsigned
integers
entree
CAML
BA
SINT16
16
bit
signed
integers
entree
CAML
BA
UINT16
16
bit
unsigned
integers
entree
CAML
BA
INT32
32
bit
signed
integers
entree
CAML
BA
INT64
64
bit
signed
integers
entree
CAML
BA
CAML
INT
31
or
63
bit
signed
integers
entree
CAML
BA
NATIVE
INT
32
or
64
bit
platform
native
integers
entree
CAML
BA
COMPLEX32
32
bit
single
precision
complex
numbers
entree
CAML
BA
COMPLEX64
64
bit
double
precision
complex
numbers
entree
CAML
BA
CHAR
8
bit
characters
end
tableau
paragraph
Warning
Caml
ba
array
val
var
v
must
always
be
dereferenced
immediately
and
not
stored
anywhere
including
local
variables
It
resolves
to
a
derived
pointer
it
is
not
a
valid
OCaml
value
but
points
to
a
memory
region
managed
by
the
GC
For
this
reason
this
value
must
not
be
stored
in
any
memory
location
that
could
be
live
cross
a
GC
The
following
example
shows
the
passing
of
a
two
dimensional
Bigarray
to
a
C
function
and
a
Fortran
function
begin
verbatim
extern
void
my
c
function
double
data
int
dimx
int
dimy
extern
void
my
fortran
function
double
data
int
dimx
int
dimy
CAMLprim
value
caml
stub
value
bigarray
int
dimx
Caml
ba
array
val
bigarray
dim
0
int
dimy
Caml
ba
array
val
bigarray
dim
1
C
passes
scalar
parameters
by
value
my
c
function
Caml
ba
data
val
bigarray
dimx
dimy
Fortran
passes
all
parameters
by
reference
my
fortran
function
Caml
ba
data
val
bigarray
dimx
dimy
return
Val
unit
end
verbatim
subsection
ss
C
Bigarrays
wrap
Wrapping
a
C
or
Fortran
array
as
an
OCaml
Bigarray
A
pointer
var
p
to
an
already
allocated
C
or
Fortran
array
can
be
wrapped
and
returned
to
OCaml
as
a
Bigarray
using
the
caml
ba
alloc
or
caml
ba
alloc
dims
functions
begin
itemize
item
caml
ba
alloc
var
kind
var
layout
var
numdims
var
p
var
dims
Return
an
OCaml
Bigarray
wrapping
the
data
pointed
to
by
var
p
var
kind
is
the
kind
of
array
elements
one
of
the
CAML
BA
kind
constants
above
var
layout
is
CAML
BA
C
LAYOUT
for
an
array
with
C
layout
and
CAML
BA
FORTRAN
LAYOUT
for
an
array
with
Fortran
layout
var
numdims
is
the
number
of
dimensions
in
the
array
var
dims
is
an
array
of
var
numdims
long
integers
giving
the
sizes
of
the
array
in
each
dimension
item
caml
ba
alloc
dims
var
kind
var
layout
var
numdims
var
p
long
nth
dim
1
long
nth
dim
2
ldots
long
nth
dim
numdims
Same
as
caml
ba
alloc
but
the
sizes
of
the
array
in
each
dimension
are
listed
as
extra
arguments
in
the
function
call
rather
than
being
passed
as
an
array
end
itemize
The
following
example
illustrates
how
statically
allocated
C
and
Fortran
arrays
can
be
made
available
to
OCaml
begin
verbatim
extern
long
my
c
array
100
200
extern
float
my
fortran
array
300
400
CAMLprim
value
caml
get
c
array
value
unit
long
dims
2
dims
0
100
dims
1
200
return
caml
ba
alloc
CAML
BA
NATIVE
INT
CAML
BA
C
LAYOUT
2
my
c
array
dims
CAMLprim
value
caml
get
fortran
array
value
unit
return
caml
ba
alloc
dims
CAML
BA
FLOAT32
CAML
BA
FORTRAN
LAYOUT
2
my
fortran
array
300L
400L
end
verbatim
section
s
C
cheaper
call
Advanced
topic
cheaper
C
call
This
section
describe
how
to
make
calling
C
functions
cheaper
bf
Note
This
only
applies
to
the
native
compiler
So
whenever
you
use
any
of
these
methods
you
have
to
provide
an
alternative
byte
code
stub
that
ignores
all
the
special
annotations
subsection
ss
c
unboxed
Passing
unboxed
values
We
said
earlier
that
all
OCaml
objects
are
represented
by
the
C
type
value
and
one
has
to
use
macros
such
as
Int
val
to
decode
data
from
the
value
type
It
is
however
possible
to
tell
the
OCaml
native
code
compiler
to
do
this
for
us
and
pass
arguments
unboxed
to
the
C
function
Similarly
it
is
possible
to
tell
OCaml
to
expect
the
result
unboxed
and
box
it
for
us
The
motivation
is
that
by
letting
ocamlopt
deal
with
boxing
it
can
often
decide
to
suppress
it
entirely
For
instance
let
s
consider
this
example
begin
verbatim
external
foo
float
float
float
foo
let
f
a
b
let
len
Array
length
a
in
assert
Array
length
b
len
let
res
Array
make
len
0
in
for
i
0
to
len
1
do
res
i
foo
a
i
b
i
done
end
verbatim
Float
arrays
are
unboxed
in
OCaml
however
the
C
function
foo
expect
its
arguments
as
boxed
floats
and
returns
a
boxed
float
Hence
the
OCaml
compiler
has
no
choice
but
to
box
a
i
and
b
i
and
unbox
the
result
of
foo
This
results
in
the
allocation
of
3
len
temporary
float
values
Now
if
we
annotate
the
arguments
and
result
with
unboxed
the
native
code
compiler
will
be
able
to
avoid
all
these
allocations
begin
verbatim
external
foo
float
unboxed
float
unboxed
float
unboxed
foo
byte
foo
end
verbatim
In
this
case
the
C
functions
must
look
like
begin
verbatim
CAMLprim
double
foo
double
a
double
b
CAMLprim
value
foo
byte
value
a
value
b
return
caml
copy
double
foo
Double
val
a
Double
val
b
end
verbatim
For
convenience
when
all
arguments
and
the
result
are
annotated
with
unboxed
it
is
possible
to
put
the
attribute
only
once
on
the
declaration
itself
So
we
can
also
write
instead
begin
verbatim
external
foo
float
float
float
foo
byte
foo
unboxed
end
verbatim
The
following
table
summarize
what
OCaml
types
can
be
unboxed
and
what
C
types
should
be
used
in
correspondence
begin
tableau
l
l
OCaml
type
C
type
entree
float
double
entree
int32
int32
t
entree
int64
int64
t
entree
nativeint
intnat
end
tableau
Similarly
it
is
possible
to
pass
untagged
OCaml
integers
between
OCaml
and
C
This
is
done
by
annotating
the
arguments
and
or
result
with
untagged
begin
verbatim
external
f
string
int
untagged
f
byte
f
end
verbatim
The
corresponding
C
type
must
be
intnat
bf
Note
Do
not
use
the
C
int
type
in
correspondence
with
int
untagged
This
is
because
they
often
differ
in
size
It
is
possible
to
annotate
with
untagged
any
immediate
type
i
e
types
that
are
represented
like
int
This
includes
bool
char
any
variant
type
with
only
constant
constructors
Note
this
does
not
include
Unix
file
descr
which
is
not
represented
as
an
integer
on
all
platforms
subsection
ss
c
direct
call
Direct
C
call
In
order
to
be
able
to
run
the
garbage
collector
in
the
middle
of
a
C
function
the
OCaml
native
code
compiler
generates
some
bookkeeping
code
around
C
calls
Technically
it
wraps
every
C
call
with
the
C
function
caml
c
call
which
is
part
of
the
OCaml
runtime
For
small
functions
that
are
called
repeatedly
this
indirection
can
have
a
big
impact
on
performances
However
this
is
not
needed
if
we
know
that
the
C
function
doesn
t
allocate
doesn
t
raise
exceptions
and
doesn
t
release
the
domain
lock
see
section
ref
ss
parallel
execution
long
running
c
code
We
can
instruct
the
OCaml
native
code
compiler
of
this
fact
by
annotating
the
external
declaration
with
the
attribute
noalloc
begin
verbatim
external
bar
int
int
int
foo
noalloc
end
verbatim
In
this
case
calling
bar
from
OCaml
is
as
cheap
as
calling
any
other
OCaml
function
except
for
the
fact
that
the
OCaml
compiler
can
t
inline
C
functions
subsection
ss
c
direct
call
example
Example
calling
C
library
functions
without
indirection
Using
these
attributes
it
is
possible
to
call
C
library
functions
with
no
indirection
For
instance
many
math
functions
are
defined
this
way
in
the
OCaml
standard
library
begin
verbatim
external
sqrt
float
float
caml
sqrt
float
sqrt
unboxed
noalloc
Square
root
external
exp
float
float
caml
exp
float
exp
unboxed
noalloc
Exponential
external
log
float
float
caml
log
float
log
unboxed
noalloc
Natural
logarithm
end
verbatim
section
s
C
multithreading
Advanced
topic
multithreading
Using
multiple
threads
shared
memory
concurrency
in
a
mixed
OCaml
C
application
requires
special
precautions
which
are
described
in
this
section
subsection
ss
c
thread
register
Registering
threads
created
from
C
Callbacks
from
C
to
OCaml
are
possible
only
if
the
calling
thread
is
known
to
the
OCaml
run
time
system
Threads
created
from
OCaml
through
the
Thread
create
function
of
the
system
threads
library
are
automatically
known
to
the
run
time
system
If
the
application
creates
additional
threads
from
C
and
wishes
to
callback
into
OCaml
code
from
these
threads
it
must
first
register
them
with
the
run
time
system
The
following
functions
are
declared
in
the
include
file
caml
threads
h
begin
itemize
item
caml
c
thread
register
registers
the
calling
thread
with
the
OCaml
run
time
system
Returns
1
on
success
0
on
error
Registering
an
already
registered
thread
does
nothing
and
returns
0
item
caml
c
thread
unregister
must
be
called
before
the
thread
terminates
to
unregister
it
from
the
OCaml
run
time
system
Returns
1
on
success
0
on
error
If
the
calling
thread
was
not
previously
registered
does
nothing
and
returns
0
end
itemize
subsection
ss
parallel
execution
long
running
c
code
Parallel
execution
of
long
running
C
code
with
systhreads
Domains
are
the
unit
of
parallelism
for
OCaml
programs
When
using
the
systhreads
library
multiple
threads
might
be
attached
to
the
same
domain
However
at
any
time
at
most
one
of
those
thread
can
be
executing
OCaml
code
or
C
code
that
uses
the
OCaml
run
time
system
by
domain
Technically
this
is
enforced
by
a
domain
lock
that
any
thread
must
hold
while
executing
such
code
within
a
domain
When
OCaml
calls
the
C
code
implementing
a
primitive
the
domain
lock
is
held
therefore
the
C
code
has
full
access
to
the
facilities
of
the
run
time
system
However
no
other
thread
in
the
same
domain
can
execute
OCaml
code
concurrently
with
the
C
code
of
the
primitive
See
also
chapter
ref
s
par
c
bindings
for
the
behaviour
with
multiple
domains
If
a
C
primitive
runs
for
a
long
time
or
performs
potentially
blocking
input
output
operations
it
can
explicitly
release
the
domain
lock
enabling
other
OCaml
threads
in
the
same
domain
to
run
concurrently
with
its
operations
The
C
code
must
re
acquire
the
domain
lock
before
returning
to
OCaml
This
is
achieved
with
the
following
functions
declared
in
the
include
file
caml
threads
h
begin
itemize
item
caml
release
runtime
system
The
calling
thread
releases
the
domain
lock
and
other
OCaml
resources
enabling
other
threads
to
run
OCaml
code
in
parallel
with
the
execution
of
the
calling
thread
item
caml
acquire
runtime
system
The
calling
thread
re
acquires
the
domain
lock
and
other
OCaml
resources
It
may
block
until
no
other
thread
in
the
same
domain
uses
the
OCaml
run
time
system
end
itemize
These
functions
poll
for
pending
signals
by
calling
asynchronous
callbacks
section
ref
ss
c
process
pending
actions
before
releasing
and
after
acquiring
the
lock
They
can
therefore
execute
arbitrary
OCaml
code
including
raising
an
asynchronous
exception
After
caml
release
runtime
system
was
called
and
until
caml
acquire
runtime
system
is
called
the
C
code
must
not
access
any
OCaml
data
nor
call
any
function
of
the
run
time
system
nor
call
back
into
OCaml
code
Consequently
arguments
provided
by
OCaml
to
the
C
primitive
must
be
copied
into
C
data
structures
before
calling
caml
release
runtime
system
and
results
to
be
returned
to
OCaml
must
be
encoded
as
OCaml
values
after
caml
acquire
runtime
system
returns
Example
the
following
C
primitive
invokes
rmdir
to
delete
a
directory
The
rmdir
function
can
block
for
some
time
so
we
choose
to
release
the
OCaml
run
time
system
while
it
is
running
begin
verbatim
include
caml
memory
h
include
caml
threads
h
include
caml
unixsupport
h
CAMLprim
value
stub
rmdir
value
vpath
CAMLparam1
vpath
Raise
Unix
Unix
error
Unix
ENOENT
if
the
OCaml
string
contains
embedded
null
bytes
caml
unix
check
path
vpath
rmdir
Copy
the
string
argument
to
a
C
string
allocated
outside
the
OCaml
heap
char
os
path
caml
stat
strdup
to
os
String
val
vpath
Release
the
OCaml
run
time
system
caml
release
runtime
system
Delete
the
directory
ifdef
WIN32
int
ret
wrmdir
path
else
int
ret
rmdir
path
endif
Free
the
copy
of
the
string
which
we
might
as
well
do
before
acquiring
the
runtime
system
to
benefit
from
parallelism
caml
stat
free
path
Re
acquire
the
OCaml
run
time
system
caml
acquire
runtime
system
Raise
Unix
Unix
error
if
rmdir
failed
if
ret
1
caml
uerror
rmdir
vpath
Return
to
OCaml
CAMLreturn
Val
unit
end
verbatim
The
macro
Caml
state
evaluates
to
the
domain
state
variable
and
checks
in
debug
mode
that
the
domain
lock
is
held
Such
a
check
is
also
placed
in
normal
mode
at
key
entry
points
of
the
C
API
this
is
why
calling
some
of
the
runtime
functions
and
macros
without
correctly
owning
the
domain
lock
can
result
in
a
fatal
error
no
domain
lock
held
The
variant
Caml
state
opt
does
not
perform
any
check
but
evaluates
to
NULL
when
the
domain
lock
is
not
held
This
lets
you
determine
whether
a
thread
belonging
to
a
domain
currently
holds
its
domain
lock
for
various
purposes
Callbacks
from
C
to
OCaml
must
be
performed
while
holding
the
domain
lock
to
the
OCaml
run
time
system
This
is
naturally
the
case
if
the
callback
is
performed
by
a
C
primitive
that
did
not
release
the
run
time
system
If
the
C
primitive
released
the
run
time
system
previously
or
the
callback
is
performed
from
other
C
code
that
was
not
invoked
from
OCaml
e
g
an
event
loop
in
a
GUI
application
the
run
time
system
must
be
acquired
before
the
callback
and
released
after
begin
verbatim
caml
acquire
runtime
system
Resolve
OCaml
function
vfun
to
be
invoked
Build
OCaml
argument
varg
to
the
callback
vres
callback
vfun
varg
Copy
relevant
parts
of
result
vres
to
C
data
structures
caml
release
runtime
system
end
verbatim
Note
the
acquire
and
release
functions
described
above
were
introduced
in
OCaml
3
12
Older
code
uses
the
following
historical
names
declared
in
caml
signals
h
begin
itemize
item
caml
enter
blocking
section
as
an
alias
for
caml
release
runtime
system
item
caml
leave
blocking
section
as
an
alias
for
caml
acquire
runtime
system
end
itemize
Intuition
a
blocking
section
is
a
piece
of
C
code
that
does
not
use
the
OCaml
run
time
system
typically
a
blocking
input
output
operation
section
s
interfacing
windows
unicode
apis
Advanced
topic
interfacing
with
Windows
Unicode
APIs
This
section
contains
some
general
guidelines
for
writing
C
stubs
that
use
Windows
Unicode
APIs
The
OCaml
system
under
Windows
can
be
configured
at
build
time
in
one
of
two
modes
begin
itemize
item
bf
legacy
mode
All
path
names
environment
variables
command
line
arguments
etc
on
the
OCaml
side
are
assumed
to
be
encoded
using
the
current
8
bit
code
page
of
the
system
item
bf
Unicode
mode
All
path
names
environment
variables
command
line
arguments
etc
on
the
OCaml
side
are
assumed
to
be
encoded
using
UTF
8
end
itemize
In
what
follows
we
say
that
a
string
has
the
emph
OCaml
encoding
if
it
is
encoded
in
UTF
8
when
in
Unicode
mode
in
the
current
code
page
in
legacy
mode
or
is
an
arbitrary
string
under
Unix
A
string
has
the
emph
platform
encoding
if
it
is
encoded
in
UTF
16
under
Windows
or
is
an
arbitrary
string
under
Unix
From
the
point
of
view
of
the
writer
of
C
stubs
the
challenges
of
interacting
with
Windows
Unicode
APIs
are
twofold
begin
itemize
item
The
Windows
API
uses
the
UTF
16
encoding
to
support
Unicode
The
runtime
system
performs
the
necessary
conversions
so
that
the
OCaml
programmer
only
needs
to
deal
with
the
OCaml
encoding
C
stubs
that
call
Windows
Unicode
APIs
need
to
use
specific
runtime
functions
to
perform
the
necessary
conversions
in
a
compatible
way
item
When
writing
stubs
that
need
to
be
compiled
under
both
Windows
and
Unix
the
stubs
need
to
be
written
in
a
way
that
allow
the
necessary
conversions
under
Windows
but
that
also
work
under
Unix
where
typically
nothing
particular
needs
to
be
done
to
support
Unicode
end
itemize
The
native
C
character
type
under
Windows
is
WCHAR
two
bytes
wide
while
under
Unix
it
is
char
one
byte
wide
A
type
char
os
is
defined
in
caml
misc
h
that
stands
for
the
concrete
C
character
type
of
each
platform
Strings
in
the
platform
encoding
are
of
type
char
os
The
following
functions
are
exposed
to
help
write
compatible
C
stubs
To
use
them
you
need
to
include
both
caml
misc
h
and
caml
osdeps
h
begin
itemize
item
char
os
caml
stat
strdup
to
os
const
char
copies
the
argument
while
translating
from
OCaml
encoding
to
the
platform
encoding
This
function
is
typically
used
to
convert
the
char
underlying
an
OCaml
string
before
passing
it
to
an
operating
system
API
that
takes
a
Unicode
argument
Under
Unix
it
is
equivalent
to
caml
stat
strdup
bf
Note
For
maximum
backwards
compatibility
in
Unicode
mode
if
the
argument
is
not
a
valid
UTF
8
string
this
function
will
fall
back
to
assuming
that
it
is
encoded
in
the
current
code
page
item
char
caml
stat
strdup
of
os
const
char
os
copies
the
argument
while
translating
from
the
platform
encoding
to
the
OCaml
encoding
It
is
the
inverse
of
caml
stat
strdup
to
os
This
function
is
typically
used
to
convert
a
string
obtained
from
the
operating
system
before
passing
it
on
to
OCaml
code
Under
Unix
it
is
equivalent
to
caml
stat
strdup
item
value
caml
copy
string
of
os
char
os
allocates
an
OCaml
string
with
contents
equal
to
the
argument
string
converted
to
the
OCaml
encoding
This
function
is
essentially
equivalent
to
caml
stat
strdup
of
os
followed
by
caml
copy
string
except
that
it
avoids
the
allocation
of
the
intermediate
string
returned
by
caml
stat
strdup
of
os
Under
Unix
it
is
equivalent
to
caml
copy
string
end
itemize
bf
Note
The
strings
returned
by
caml
stat
strdup
to
os
and
caml
stat
strdup
of
os
are
allocated
using
caml
stat
alloc
so
they
need
to
be
deallocated
using
caml
stat
free
when
they
are
no
longer
needed
paragraph
Example
We
want
to
bind
the
function
getenv
in
a
way
that
works
both
under
Unix
and
Windows
Under
Unix
this
function
has
the
prototype
begin
verbatim
char
getenv
const
char
end
verbatim
While
the
Unicode
version
under
Windows
has
the
prototype
begin
verbatim
WCHAR
wgetenv
const
WCHAR
end
verbatim
In
terms
of
char
os
both
functions
take
an
argument
of
type
char
os
and
return
a
result
of
the
same
type
We
begin
by
choosing
the
right
implementation
of
the
function
to
bind
begin
verbatim
ifdef
WIN32
define
getenv
os
wgetenv
else
define
getenv
os
getenv
endif
end
verbatim
The
rest
of
the
binding
is
the
same
for
both
platforms
begin
verbatim
include
caml
mlvalues
h
include
caml
misc
h
include
caml
alloc
h
include
caml
fail
h
include
caml
osdeps
h
include
stdlib
h
CAMLprim
value
stub
getenv
value
var
name
CAMLparam1
var
name
CAMLlocal1
var
value
char
os
var
name
os
var
value
os
var
name
os
caml
stat
strdup
to
os
String
val
var
name
var
value
os
getenv
os
var
name
os
caml
stat
free
var
name
os
if
var
value
os
NULL
caml
raise
not
found
var
value
caml
copy
string
of
os
var
value
os
CAMLreturn
var
value
end
verbatim
section
s
ocamlmklib
Building
mixed
C
OCaml
libraries
texttt
ocamlmklib
The
ocamlmklib
command
facilitates
the
construction
of
libraries
containing
both
OCaml
code
and
C
code
and
usable
both
in
static
linking
and
dynamic
linking
modes
This
command
is
available
under
Windows
since
Objective
Caml
3
11
and
under
other
operating
systems
since
Objective
Caml
3
03
The
ocamlmklib
command
takes
three
kinds
of
arguments
begin
itemize
item
OCaml
source
files
and
object
files
cmo
cmx
ml
comprising
the
OCaml
part
of
the
library
item
C
object
files
o
a
respectively
obj
lib
comprising
the
C
part
of
the
library
item
Support
libraries
for
the
C
part
l
var
lib
end
itemize
It
generates
the
following
outputs
begin
itemize
item
An
OCaml
bytecode
library
cma
incorporating
the
cmo
and
ml
OCaml
files
given
as
arguments
and
automatically
referencing
the
C
library
generated
with
the
C
object
files
item
An
OCaml
native
code
library
cmxa
incorporating
the
cmx
and
ml
OCaml
files
given
as
arguments
and
automatically
referencing
the
C
library
generated
with
the
C
object
files
item
If
dynamic
linking
is
supported
on
the
target
platform
a
so
respectively
dll
shared
library
built
from
the
C
object
files
given
as
arguments
and
automatically
referencing
the
support
libraries
item
A
C
static
library
a
respectively
lib
built
from
the
C
object
files
end
itemize
In
addition
the
following
options
are
recognized
begin
options
item
cclib
ccopt
I
linkall
These
options
are
passed
as
is
to
ocamlc
or
ocamlopt
See
the
documentation
of
these
commands
item
rpath
R
Wl
rpath
Wl
R
These
options
are
passed
as
is
to
the
C
compiler
Refer
to
the
documentation
of
the
C
compiler
item
custom
Force
the
construction
of
a
statically
linked
library
only
even
if
dynamic
linking
is
supported
item
failsafe
Fall
back
to
building
a
statically
linked
library
if
a
problem
occurs
while
building
the
shared
library
e
g
some
of
the
support
libraries
are
not
available
as
shared
libraries
item
L
var
dir
Add
var
dir
to
the
search
path
for
support
libraries
l
var
lib
item
ocamlc
var
cmd
Use
var
cmd
instead
of
ocamlc
to
call
the
bytecode
compiler
item
ocamlopt
var
cmd
Use
var
cmd
instead
of
ocamlopt
to
call
the
native
code
compiler
item
o
var
output
Set
the
name
of
the
generated
OCaml
library
ocamlmklib
will
generate
var
output
cma
and
or
var
output
cmxa
If
not
specified
defaults
to
a
item
oc
var
outputc
Set
the
name
of
the
generated
C
library
ocamlmklib
will
generate
lib
var
outputc
so
if
shared
libraries
are
supported
and
lib
var
outputc
a
If
not
specified
defaults
to
the
output
name
given
with
o
end
options
paragraph
Example
Consider
an
OCaml
interface
to
the
standard
libz
C
library
for
reading
and
writing
compressed
files
Assume
this
library
resides
in
usr
local
zlib
This
interface
is
composed
of
an
OCaml
part
zip
cmo
zip
cmx
and
a
C
part
zipstubs
o
containing
the
stub
code
around
the
libz
entry
points
The
following
command
builds
the
OCaml
libraries
zip
cma
and
zip
cmxa
as
well
as
the
companion
C
libraries
dllzip
so
and
libzip
a
begin
verbatim
ocamlmklib
o
zip
zip
cmo
zip
cmx
zipstubs
o
lz
L
usr
local
zlib
end
verbatim
If
shared
libraries
are
supported
this
performs
the
following
commands
begin
verbatim
ocamlc
a
o
zip
cma
zip
cmo
dllib
lzip
cclib
lzip
cclib
lz
ccopt
L
usr
local
zlib
ocamlopt
a
o
zip
cmxa
zip
cmx
cclib
lzip
cclib
lzip
cclib
lz
ccopt
L
usr
local
zlib
gcc
shared
o
dllzip
so
zipstubs
o
lz
L
usr
local
zlib
ar
rc
libzip
a
zipstubs
o
end
verbatim
Note
This
example
is
on
a
Unix
system
The
exact
command
lines
may
be
different
on
other
systems
If
shared
libraries
are
not
supported
the
following
commands
are
performed
instead
begin
verbatim
ocamlc
a
custom
o
zip
cma
zip
cmo
cclib
lzip
cclib
lz
ccopt
L
usr
local
zlib
ocamlopt
a
o
zip
cmxa
zip
cmx
lzip
cclib
lz
ccopt
L
usr
local
zlib
ar
rc
libzip
a
zipstubs
o
end
verbatim
Instead
of
building
simultaneously
the
bytecode
library
the
native
code
library
and
the
C
libraries
ocamlmklib
can
be
called
three
times
to
build
each
separately
Thus
begin
verbatim
ocamlmklib
o
zip
zip
cmo
lz
L
usr
local
zlib
end
verbatim
builds
the
bytecode
library
zip
cma
and
begin
verbatim
ocamlmklib
o
zip
zip
cmx
lz
L
usr
local
zlib
end
verbatim
builds
the
native
code
library
zip
cmxa
and
begin
verbatim
ocamlmklib
o
zip
zipstubs
o
lz
L
usr
local
zlib
end
verbatim
builds
the
C
libraries
dllzip
so
and
libzip
a
Notice
that
the
support
libraries
lz
and
the
corresponding
options
L
usr
local
zlib
must
be
given
on
all
three
invocations
of
ocamlmklib
because
they
are
needed
at
different
times
depending
on
whether
shared
libraries
are
supported
section
s
c
internal
guidelines
Cautionary
words
the
internal
runtime
API
Not
all
header
available
in
the
caml
directory
were
described
in
previous
sections
All
those
unmentioned
headers
are
part
of
the
internal
runtime
API
for
which
there
is
emph
no
stability
guarantee
If
you
really
need
access
to
this
internal
runtime
API
this
section
provides
some
guidelines
that
may
help
you
to
write
code
that
might
not
break
on
every
new
version
of
OCaml
paragraph
Note
Programmers
which
come
to
rely
on
the
internal
API
for
a
use
case
which
they
find
realistic
and
useful
are
encouraged
to
open
a
request
for
improvement
on
the
bug
tracker
subsection
ss
c
internals
Internal
variables
and
CAML
INTERNALS
Since
OCaml
4
04
it
is
possible
to
get
access
to
every
part
of
the
internal
runtime
API
by
defining
the
CAML
INTERNALS
macro
before
loading
caml
header
files
If
this
macro
is
not
defined
parts
of
the
internal
runtime
API
are
hidden
If
you
are
using
internal
C
variables
do
not
redefine
them
by
hand
You
should
import
those
variables
by
including
the
corresponding
header
files
The
representation
of
those
variables
has
already
changed
once
in
OCaml
4
10
and
is
still
under
evolution
If
your
code
relies
on
such
internal
and
brittle
properties
it
will
be
broken
at
some
point
in
time
For
instance
rather
than
redefining
caml
young
limit
begin
verbatim
extern
int
caml
young
limit
end
verbatim
which
breaks
in
OCaml
ge
4
10
you
should
include
the
minor
gc
header
begin
verbatim
include
caml
minor
gc
h
end
verbatim
subsection
ss
c
internal
macros
OCaml
version
macros
Finally
if
including
the
right
headers
is
not
enough
or
if
you
need
to
support
version
older
than
OCaml
4
04
the
header
file
caml
version
h
should
help
you
to
define
your
own
compatibility
layer
This
file
provides
few
macros
defining
the
current
OCaml
version
In
particular
the
OCAML
VERSION
macro
describes
the
current
version
its
format
is
MmmPP
For
example
if
you
need
some
specific
handling
for
versions
older
than
4
10
0
you
could
write
begin
verbatim
include
caml
version
h
if
OCAML
VERSION
41000
else
endif
end
verbatim
chapter
Foreword
markboth
Foreword
HEVEA
cutname
foreword
html
This
manual
documents
the
release
ocamlversion
of
the
OCaml
system
It
is
organized
as
follows
begin
itemize
item
Part
ref
p
tutorials
An
introduction
to
OCaml
gives
an
overview
of
the
language
item
Part
ref
p
refman
The
OCaml
language
is
the
reference
description
of
the
language
item
Part
ref
p
commands
The
OCaml
tools
documents
the
compilers
toplevel
system
and
programming
utilities
item
Part
ref
p
library
The
OCaml
library
describes
the
modules
provided
in
the
standard
library
begin
latexonly
item
Part
ref
p
indexes
Indexes
contains
an
index
of
all
identifiers
defined
in
the
standard
library
and
an
index
of
keywords
end
latexonly
end
itemize
section
conventions
Conventions
OCaml
runs
on
several
operating
systems
The
parts
of
this
manual
that
are
specific
to
one
operating
system
are
presented
as
shown
below
begin
unix
This
is
material
specific
to
the
Unix
family
of
operating
systems
including
Linux
and
macOS
end
unix
begin
windows
This
is
material
specific
to
Microsoft
Windows
Vista
7
8
10
11
end
windows
section
license
License
The
OCaml
system
is
copyright
copyright
1996
number
year
Institut
National
de
Recherche
en
Informatique
et
en
Automatique
INRIA
INRIA
holds
all
ownership
rights
to
the
OCaml
system
The
OCaml
system
is
open
source
and
can
be
freely
redistributed
See
the
file
LICENSE
in
the
distribution
for
licensing
information
The
OCaml
documentation
and
user
s
manual
is
copyright
copyright
number
year
Institut
National
de
Recherche
en
Informatique
et
en
Automatique
INRIA
begin
latexonly
The
OCaml
documentation
and
user
s
manual
is
licensed
under
a
Creative
Commons
Attribution
ShareAlike
4
0
International
License
CC
BY
SA
4
0
url
https
creativecommons
org
licenses
by
sa
4
0
The
sample
code
in
the
user
s
manual
and
in
the
reference
documentation
of
the
standard
library
is
licensed
under
a
Creative
Commons
CC0
1
0
Universal
CC0
1
0
Public
Domain
Dedication
License
url
https
creativecommons
org
publicdomain
zero
1
0
end
latexonly
begin
htmlonly
begin
rawhtml
a
id
cc
license
logo
rel
license
href
http
creativecommons
org
licenses
by
sa
4
0
img
alt
Creative
Commons
License
style
border
width
0
src
https
licensebuttons
net
l
by
sa
4
0
88x31
png
a
The
OCaml
documentation
and
user
s
manual
is
licensed
under
a
a
rel
license
href
http
creativecommons
org
licenses
by
sa
4
0
Creative
Commons
Attribution
ShareAlike
4
0
International
License
a
end
rawhtml
begin
rawhtml
a
id
cc
license
logo
rel
license
href
https
creativecommons
org
publicdomain
zero
1
0
img
alt
Creative
Commons
License
style
border
width
0
src
https
licensebuttons
net
l
publicdomain
88x31
png
a
The
sample
code
in
the
user
s
manual
and
in
the
reference
documentation
of
the
standard
library
is
licensed
under
a
a
rel
license
href
https
creativecommons
org
publicdomain
zero
1
0
Creative
Commons
CC0
1
0
Universal
CC0
1
0
Public
Domain
Dedication
License
a
end
rawhtml
end
htmlonly
section
availability
Availability
begin
latexonly
The
complete
OCaml
distribution
can
be
accessed
via
the
website
url
https
ocaml
org
This
site
contains
a
lot
of
additional
information
on
OCaml
end
latexonly
begin
htmlonly
The
complete
OCaml
distribution
can
be
accessed
via
the
href
https
ocaml
org
ocaml
org
website
This
site
contains
a
lot
of
additional
information
on
OCaml
end
htmlonly
Ocaml
Web
manual
Copyright
San
Vu
Ngoc
2020
file
process
api
ml
Post
processing
the
HTML
of
the
OCaml
API
open
Soup
open
Printf
open
Common
let
compiler
libref
ref
false
set
this
to
true
to
process
compilerlibref
instead
of
libref
type
config
src
dir
string
dst
dir
string
title
string
HTML
code
for
the
search
widget
We
don
t
add
the
onchange
event
because
it
forces
to
click
twice
to
an
external
link
after
entering
text
let
search
widget
with
description
let
search
decription
if
with
description
then
span
class
search
comment
search
values
type
signatures
and
descriptions
case
sensitive
span
id
help
icon
onclick
showHelp

span
div
id
search
help
class
hide
ul
li
You
may
search
bare
values
like
code
map
code
or
indicate
the
module
like
code
List
map
code
or
type
signatures
like
code
int
float
code
li
li
To
combine
several
keywords
just
separate
them
by
a
space
Quotes
can
be
used
to
prevent
from
splitting
words
at
spaces
For
instance
code
int
array
code
will
search
for
code
int
code
and
or
code
array
code
while
code
int
array
code
will
only
list
functions
whose
signature
contains
the
code
int
array
code
type
li
li
You
may
use
the
special
chars
code
code
and
code
code
to
indicate
where
the
matched
string
should
start
or
end
respectively
For
instance
code
zip
code
will
not
show
you
the
code
unzip
code
function
li
ul
div
span
else
in
sprintf
div
class
api
search
input
type
search
name
apisearch
id
api
search
class
api
search
oninput
mySearch
b
onkeypress
this
oninput
onclick
this
oninput
onpaste
this
oninput
button
onclick
mySearch
b
style
cursor
pointer
Search
span
aria
hidden
true

span
button
s
div
div
id
search
results
div
with
description
with
description
search
decription
parse
We
save
parsed
files
in
a
table
this
is
just
for
speed
optimization
especially
for
make
index
18sec
instead
of
50sec
for
the
whole
index
it
can
be
removed
Although
if
we
really
wanted
a
fast
make
index
we
would
use
Scanf
all
over
the
place
1sec
Warning
the
parsed
files
will
be
mutated
by
processing
so
one
should
never
process
the
same
file
twice
let
parsed
files
Hashtbl
create
50
let
parse
file
original
false
file
match
Hashtbl
find
opt
parsed
files
file
with
Some
soup
if
original
then
failwith
sprintf
File
s
was
already
processed
file
else
soup
None
let
soup
read
file
file
parse
in
Hashtbl
add
parsed
files
file
soup
soup
Create
TOC
with
H2
and
H3
elements
Cf
Scanf
for
an
example
with
H3
elements
let
make
toc
version
search
file
config
title
body
let
header
create
element
id
sidebar
header
in
prepend
child
body
header
let
nav
create
element
nav
class
toc
in
append
child
header
nav
let
ul
create
element
ul
in
append
child
nav
ul
Create
a
li
element
inside
ul
from
a
header
h
h2
or
h3
typically
let
li
of
h
ul
h
let
li
current
create
element
li
in
append
child
ul
li
current
let
match
attribute
id
h
with
Some
id
let
href
id
in
let
a
create
element
a
inner
text
texts
h
String
concat
attributes
href
href
in
append
child
li
current
a
None
in
li
current
in
descendants
body
elements
fold
fun
li
current
h3
current
h
match
name
h
with
h2
li
of
h
ul
h
None
h3
begin
match
h3
current
with
Some
h3
li
of
h
h3
h
h3
current
None
let
h3
create
element
ul
in
append
child
ul
li
current
append
child
li
current
h3
li
of
h
h3
h
Some
h3
end
li
current
h3
current
create
element
li
None
ignore
let
href
let
base
Filename
basename
file
in
if
String
sub
base
0
5
type
then
String
sub
base
5
String
length
base
5
else
top
in
let
a
create
element
a
inner
text
title
attributes
href
href
in
let
div
create
element
class
toc
title
div
in
append
child
div
a
prepend
child
nav
div
In
case
of
indexlist
add
it
to
TOC
This
only
happens
for
index
html
let
match
body
ul
indexlist
with
Some
uli
delete
uli
append
child
ul
uli
unwrap
uli
if
search
then
search
widget
true
prepend
child
body
create
element
h1
inner
text
sprintf
The
OCaml
sAPI
config
title
prepend
child
body
None
if
search
then
search
widget
false
prepend
child
nav
Add
general
index
link
to
all
other
files
create
element
a
inner
text
General
Index
attributes
href
index
html
prepend
child
nav
in
Add
version
number
add
version
link
nav
config
title
API
Version
version
releases
url
Add
sidebar
button
for
mobile
navigation
add
sidebar
button
body
Add
logo
prepend
child
header
logo
html
if
config
title
then
else
manual
page
url
index
html
let
add
anchor
node
node
let
anchor
create
element
class
anchor
attributes
href
R
attribute
id
node
a
in
add
class
anchored
node
prepend
child
node
anchor
let
add
anchors
to
items
body
iter
fun
node
let
rec
loop
function
tag
tags
begin
match
node
Printf
sprintf
span
id
S
tag
with
Some
node
add
anchor
node
node
None
loop
tags
end
in
loop
VAL
TYPE
MODULE
EXCEPTION
EXTENSION
METHOD
ATT
body
pre
let
add
anchors
to
headings
body
List
iter
fun
kind
iter
fun
node
add
anchor
node
node
body
Printf
sprintf
s
id
kind
h2
h3
h4
h5
h6
let
process
search
true
version
config
file
out
dbg
Processing
s
file
let
soup
parse
file
original
true
file
in
Add
javascript
and
favicon
update
head
search
soup
Add
api
wrapper
let
body
wrap
body
classes
api
soup
in
Delete
previous
up
next
links
body
div
navbar
Option
iter
delete
Add
anchors
to
each
API
item
add
anchors
to
items
body
Add
anchors
to
headings
add
anchors
to
headings
body
Add
left
sidebar
with
TOC
let
title
soup
title
R
leaf
text
in
make
toc
version
search
file
config
title
body
dbg
Saving
s
out
Save
new
html
file
let
new
html
to
string
soup
in
write
file
out
new
html
let
process
overwrite
false
version
config
file
out
if
overwrite
not
Sys
file
exists
out
then
Ok
process
version
config
file
out
else
Error
sprintf
File
s
already
exists
out
let
all
html
files
config
Sys
readdir
config
src
dir
Array
to
list
List
filter
fun
s
Filename
extension
s
html
module
Index
struct
Generate
the
index
js
file
for
searching
with
the
quick
search
widget
The
idea
is
to
parse
the
file
index
values
html
to
extract
for
each
entry
of
this
index
the
following
information
list
of
8
strings
Module
name
href
URL
of
the
Module
in
principle
an
html
file
Value
name
href
URL
of
the
value
short
description
html
format
short
description
in
txt
format
type
signature
html
format
type
signature
in
txt
format
The
txt
format
versions
are
used
for
searching
the
html
version
for
display
The
signature
is
not
in
the
index
values
html
file
we
have
to
look
for
it
by
following
the
value
href
The
index
values
html
file
has
the
following
structure
table
tr
td
a
href
List
html
VALappend
append
a
a
href
List
html
List
a
td
td
div
class
info
p
Concatenate
two
lists
p
div
td
tr
table
So
we
need
to
visit
List
html
VALappend
which
has
the
following
structure
pre
span
id
VALappend
span
class
keyword
val
span
append
span
code
class
type
a
list
a
list
a
list
code
pre
and
we
finally
return
List
List
html
rev
append
List
html
VALrev
append
div
class
info
p
code
class
code
span
class
constructor
List
span
rev
append
nbsp
l1
nbsp
l2
code
reverses
code
class
code
l1
code
and
concatenates
it
to
code
class
code
l2
code
p
div
List
rev
append
194
160l1
194
160l2
reverses
l1
and
concatenates
it
to
l2
code
class
type
a
list
gt
a
list
gt
a
list
code
a
list
a
list
a
list
type
item
html
string
txt
string
type
entry
mdule
item
value
item
info
item
signature
item
option
let
anon
t
regexp
Re
Str
regexp
bt
b
let
space
regexp
Re
Str
regexp
let
newline
regexp
Re
Str
regexp
string
n
Remove
n
and
superfluous
spaces
in
string
let
one
line
s
Re
Str
global
replace
newline
regexp
s
Re
Str
global
replace
space
regexp
String
trim
Look
for
signature
with
and
without
html
formatting
id
is
the
HTML
id
of
the
value
Example
get
sig
id
name
VALfloat
of
int
Stdlib
html
Looking
for
signature
for
VALfloat
of
int
in
Stdlib
html
Signature
int
float
string
string
option
Some
code
class
type
int
gt
float
code
int
float
let
get
sig
mod
name
id
name
config
file
dbg
Looking
for
signature
for
s
in
s
id
name
file
let
soup
parse
file
config
src
dir
file
in
Now
we
jump
to
the
html
element
with
id
id
name
Warning
we
cannot
use
the
CSS
id
syntax
for
searching
the
id
like
in
soup
id
because
it
can
have
problematic
chars
like
id
VAL
let
span
soup
pre
span
filter
fun
s
id
s
Some
id
name
first
require
in
let
pre
match
parent
span
with
None
failwith
Cannot
find
signature
for
id
name
Some
pre
pre
in
let
code
pre
type
in
let
sig
txt
texts
code
String
concat
String
escaped
in
We
now
replace
anonymous
t
s
by
the
qualified
Module
t
let
sig
txt
match
mod
name
with
None
sig
txt
Some
mod
name
Re
Str
global
replace
anon
t
regexp
mod
name
t
sig
txt
in
dbg
Signature
s
sig
txt
Some
html
to
string
code
String
escaped
txt
sig
txt
Example
Buffer
html
VALadd
subbytes
Some
VALadd
subbytes
let
get
id
ref
match
String
split
on
char
ref
with
file
id
Some
file
id
dbg
Could
not
find
id
for
s
ref
None
let
make
with
sig
true
config
let
soup
parse
file
config
src
dir
index
values
html
in
soup
table
select
tr
fold
fun
index
list
tr
let
td
list
tr
td
to
list
in
match
td
list
with
We
scan
the
row
it
should
contain
2
td
entries
except
for
separators
with
initials
A
B
C
D
etc
td
val
td
info
let
mdule
value
match
td
val
a
to
list
with
a
val
a
mod
txt
R
leaf
text
a
mod
html
R
attribute
href
a
mod
txt
R
leaf
text
a
val
html
R
attribute
href
a
val
failwith
Cannot
parse
value
in
let
info
match
td
info
div
info
with
Some
info
html
to
string
info
one
line
String
escaped
txt
texts
info
String
concat
one
line
String
escaped
None
html
txt
in
let
signature
if
with
sig
then
get
id
value
html
flat
option
fun
file
id
name
assert
file
mdule
html
get
sig
config
mod
name
mdule
txt
id
name
file
else
None
in
mdule
value
info
signature
index
list
dbg
Ignoring
row
dbg
s
List
map
to
string
td
list
String
concat
index
list
let
save
file
index
let
outch
open
out
file
in
output
string
outch
var
GENERAL
INDEX
n
List
iter
fun
item
fprintf
outch
s
s
s
s
s
s
s
s
item
mdule
txt
item
mdule
html
item
value
txt
item
value
html
item
info
html
item
info
txt
Option
map
fun
i
i
html
item
signature
string
of
opt
Option
map
fun
i
i
txt
item
signature
string
of
opt
output
string
outch
n
index
output
string
outch
n
close
out
outch
let
process
config
print
endline
Creating
index
file
please
wait
let
t
Unix
gettimeofday
in
let
index
make
config
in
dbg
Index
created
Time
f
n
Unix
gettimeofday
t
save
config
dst
dir
index
js
index
dbg
Index
saved
Time
f
n
Unix
gettimeofday
t
end
of
Index
module
let
process
html
config
overwrite
version
print
endline
sprintf
nProcessing
version
s
into
s
n
version
config
dst
dir
let
processed
ref
0
in
all
html
files
config
List
iter
fun
file
match
process
config
overwrite
version
config
src
dir
file
config
dst
dir
file
with
Ok
incr
processed
Error
s
dbg
s
s
sprintf
Version
s
HTML
processing
done
u
files
have
been
processed
version
processed
print
endline
let
copy
files
config
let
ind
config
dst
dir
index
js
in
if
not
Sys
file
exists
ind
then
Index
process
config
let
let
version
find
version
in
let
args
Sys
argv
Array
to
list
List
tl
in
let
config
if
List
mem
compiler
args
then
src
dir
html
maindir
compilerlibref
dst
dir
api
dir
compilerlibref
title
Compiler
else
src
dir
html
maindir
libref
dst
dir
api
dir
title
in
let
overwrite
List
mem
overwrite
args
in
let
makeindex
List
mem
makeindex
args
in
let
makehtml
List
mem
html
args
not
makeindex
in
if
makehtml
then
process
html
config
overwrite
version
if
makeindex
then
Index
process
config
copy
files
config
print
endline
DONE
Local
Variables
compile
command
dune
build
End
Ocaml
Web
manual
Copyright
San
Vu
Ngoc
2020
file
process
api
ml
Post
processing
the
HTML
of
the
OCaml
Manual
The
API
side
is
treated
by
process
api
ml
open
Soup
open
Printf
open
Common
How
the
main
index
html
page
will
be
called
let
index
title
Home
Alternative
formats
for
the
manual
let
archives
refman
html
tar
gz
refman
txt
refman
pdf
refman
info
tar
gz
let
preg
anyspace
String
concat
u
00a0
NO
BREAK
SPACE
u
2000
EN
QUAD
u
2001
EM
QUAD
u
2002
EN
SPACE
u
2003
EM
SPACE
u
2004
THREE
PER
EM
SPACE
u
2005
FOUR
PER
EM
SPACE
u
2006
SIX
PER
EM
SPACE
u
2007
FIGURE
SPACE
u
2008
PUNCTUATION
SPACE
u
2009
THIN
SPACE
u
200a
HAIR
SPACE
u
202f
NARROW
NO
BREAK
SPACE
sprintf
s
WARNING
these
are
sensitive
to
Hevea
fluctuations
long
space
is
either
hevea
2
32
or
u
2003
hevea
2
35
let
preg
emspace
u
2003
What
hevea
inserts
between
Chapter
and
the
chapter
number
let
preg
chapter
space
u
2004
u
200d
preg
anyspace
let
writtenby
css
span
font
it
span
c009
for
hevea
2
32
Remove
number
Chapter
1
The
core
language
The
core
language
let
remove
number
s
Re
Str
global
replace
regexp
preg
emspace
s
let
toc
get
title
li
let
a
li
a
href
in
let
title
trimmed
texts
a
String
concat
remove
number
in
let
file
R
attribute
href
a
String
split
on
char
List
hd
in
file
title
let
register
toc
entry
toc
table
name
li
let
file
title
toc
get
title
li
in
dbg
s
s
name
title
if
not
Hashtbl
mem
toc
table
file
then
begin
Hashtbl
add
toc
table
file
title
dbg
Registering
s
s
file
title
end
file
title
Scan
manual001
html
and
return
two
things
1
toc
table
a
table
with
file
title
2
all
chapters
the
list
of
parts
part
title
chapters
where
chapters
is
a
list
of
title
file
let
parse
toc
let
toc
table
Hashtbl
create
50
in
Hashtbl
add
toc
table
manual001
html
Contents
Hashtbl
add
toc
table
foreword
html
Foreword
Hashtbl
add
toc
table
manual071
html
Keywords
let
soup
read
file
html
file
manual001
html
parse
in
let
toc
soup
ul
toc
in
let
all
chapters
toc
li
li
toc
Parts
fold
fun
all
chapters
li
let
file
title
toc
get
title
li
in
dbg
Part
s
title
let
chapters
li
ul
li
li
toc
Chapters
fold
fun
chapters
li
let
file
title
register
toc
entry
toc
table
Chapters
li
in
li
ul
li
li
toc
Sections
iter
ignore
register
toc
entry
toc
table
Section
file
title
chapters
List
rev
in
if
chapters
then
all
chapters
else
title
chapters
all
chapters
in
toc
table
all
chapters
This
string
is
updated
by
extract
date
let
copyright
text
ref
Copyright
?
2020
Institut
National
de
Recherche
en
Informatique
et
en
Automatique
let
copyright
div
class
copyright
copyright
text
div
parse
New
UTF8
space
chars
have
been
introduced
in
Hevea
2
35
In
Hevea
2
32
only
html
nb
spaces
XA0
were
used
With
2
35
we
have
Chapter
u2004
u200d2
u2003The
module
system
The
u200d
is
Zero
Width
Joiner
and
should
probably
not
be
used
here
see
https
github
com
maranget
hevea
pull
61
let
reg
chapter
Re
Str
regexp
Chapter
preg
chapter
space
0
9
preg
anyspace
let
load
html
file
dbg
s
file
First
we
perform
some
direct
find
replace
in
the
html
string
let
html
read
file
html
file
file
Normalize
non
break
spaces
to
the
utf8
u00A0
Re
Str
global
replace
regexp
string
XA0
Re
Str
global
replace
reg
chapter
if
file
index
html
then
span
class
number
3
span
else
span
class
chapter
number
Chapter
3
span
I
think
it
would
be
good
to
replace
chapter
by
tutorial
for
part
I
The
problem
of
course
is
how
we
number
chapters
in
the
other
parts
Re
Str
global
replace
Re
Str
regexp
string
chapter
tutorial
Re
Str
global
replace
Re
Str
regexp
string
Chapter
Tutorial
Remove
the
chapter
number
in
local
links
it
makes
the
TOC
unnecessarily
unfriendly
Re
Str
global
replace
regexp
0
9
0
9
preg
anyspace
span
class
number
1
span
Re
Str
global
replace
regexp
0
9
0
9
0
9
preg
anyspace
span
class
number
1
span
The
API
libref
and
compilerlibref
directories
should
be
separate
entities
to
better
distinguish
them
from
the
manual
Re
Str
global
replace
regexp
string
libref
sprintf
s
api
page
url
Re
Str
global
replace
regexp
string
compilerlibref
sprintf
s
compilerlibref
api
page
url
in
For
the
main
index
file
we
do
a
few
adjustments
let
html
if
file
index
html
then
Re
Str
global
replace
regexp
Part
preg
chapter
space
I
V
br
n
span
class
number
3
span
html
else
html
in
Set
utf8
encoding
directly
in
the
html
string
let
charset
regexp
Re
Str
regexp
charset
A
Za
z0
9
b
in
match
Re
Str
search
forward
charset
regexp
html
0
with
exception
Not
found
dbg
Warning
no
charset
found
in
html
html
match
String
lowercase
ascii
Re
Str
matched
group
1
html
with
utf
8
dbg
Charset
is
UTF
8
good
html
us
ascii
dbg
Charset
is
US
ASCII
We
change
it
to
UTF
8
Re
Str
global
replace
charset
regexp
charset
UTF
8
2
html
dbg
Warning
charset
not
recognized
html
Save
new
html
file
let
save
to
file
soup
file
let
new
html
to
string
soup
in
write
file
docs
file
file
new
html
Find
title
associated
with
file
let
file
title
file
toc
if
file
index
html
then
Some
index
title
else
Hashtbl
find
opt
toc
file
Replace
the
images
of
one
of
the
previous
next
up
link
by
the
title
of
the
reference
let
nav
replace
img
by
text
toc
alt
a
img
let
file
R
attribute
href
a
in
let
title
match
file
title
file
toc
with
Some
f
begin
match
alt
with
Previous
f
Next
f
Up
f
failwith
This
should
not
happen
end
None
dbg
Unknown
title
for
file
s
file
file
in
let
txt
create
text
title
in
replace
img
txt
add
class
String
lowercase
ascii
alt
a
Replace
three
links
Previous
Up
Next
at
the
end
of
the
file
by
more
useful
titles
and
insert
then
in
a
div
container
keeping
only
2
of
them
either
previous
next
or
previous
up
or
up
next
Remove
them
at
the
top
of
the
file
where
they
are
not
needed
because
we
have
the
TOC
let
update
navigation
soup
toc
Option
iter
delete
soup
hr
let
links
Previous
Up
Next
List
map
fun
alt
alt
to
list
soup
img
alt
alt
In
principle
imgs
will
contain
either
0
or
2
elements
List
filter
fun
alt
imgs
List
length
imgs
2
We
delete
the
first
link
and
replace
image
by
text
List
map
fun
alt
imgs
delete
R
parent
List
hd
imgs
let
img
List
hd
List
rev
imgs
in
let
a
R
parent
img
in
nav
replace
img
by
text
toc
alt
a
img
a
in
if
links
then
begin
We
keep
only
2
links
first
and
last
let
a1
a2
match
links
with
prev
up
next
delete
up
prev
next
a
b
a
b
failwith
Navigation
link
should
have
at
least
2
elements
in
add
class
previous
a1
add
class
next
a2
some
elements
can
have
both
previous
and
up
classes
for
instance
This
helps
css
styling
let
container
create
element
class
bottom
navigation
div
in
wrap
a1
container
append
child
container
a2
end
extract
the
cut
point
just
after
title
and
the
header
of
soup
insert
xfile
content
needs
them
to
insert
external
files
after
the
cut
point
and
include
the
TOC
let
make
template
soup
let
header
soup
header
in
let
title
match
soup
div
maintitle
with
Some
div
div
This
is
the
case
for
index
html
None
soup
h1
in
title
header
Create
a
new
file
by
keeping
only
the
head
headers
parts
of
soup
deleting
everything
after
the
title
and
inserting
the
content
of
external
file
hence
preserving
TOC
and
headers
WARNING
this
mutates
soup
let
insert
xfile
content
soup
title
header
toc
xfile
let
xternal
parse
load
html
xfile
in
update
navigation
xternal
toc
Option
iter
delete
xternal
hr
let
xbody
xternal
body
in
insert
after
title
xbody
create
element
id
start
section
a
insert
after
title
insert
after
title
header
next
siblings
xbody
iter
delete
insert
after
xbody
copyright
set
name
section
xbody
set
attribute
id
section
xbody
save
to
file
soup
xfile
Extract
the
date
and
copyright
from
the
maintitle
block
in
index
html
let
extract
date
maintitle
let
months
January
February
March
April
May
June
July
August
September
October
November
December
in
let
txts
texts
maintitle
List
map
String
trim
in
copyright
text
List
hd
List
rev
txts
txts
List
filter
fun
s
List
exists
fun
month
starts
with
month
s
months
function
s
Some
s
dbg
Warning
date
not
found
None
Special
treatment
of
the
main
index
html
file
let
convert
index
version
soup
Remove
translated
from
LaTeX
soup
blockquote
last
Option
iter
delete
let
title
selector
if
float
of
string
version
4
07
then
div
center
else
div
maintitle
in
let
maintitle
soup
title
selector
in
sprintf
div
class
maintitle
h1
span
The
OCaml
system
span
release
s
h1
h3
s
h3
div
version
extract
date
maintitle
string
of
opt
parse
insert
after
maintitle
delete
maintitle
let
body
soup
index
in
span
class
authors
Xavier
Leroy
br
Damien
Doligez
Alain
Frisch
Jacques
Garrigue
Didier
Rmy
and
Jrme
Vouillon
span
parse
append
child
body
let
change
title
title
soup
let
title
tag
soup
title
in
let
new
title
create
element
title
inner
text
OCaml
title
in
replace
title
tag
new
title
Create
left
sidebar
for
TOC
let
make
toc
sidebar
version
title
file
body
let
toc
match
body
ul
with
None
None
can
be
None
eg
chapters
15
19
Some
t
if
classes
t
as
in
libthreads
html
or
parsing
html
then
dbg
We
don
t
promote
UL
to
TOC
for
file
s
file
None
else
Some
t
in
let
match
body
h2
section
toc
with
None
Some
toc
If
file
has
no
content
sections
we
clone
the
toc
to
leave
it
in
the
main
content
This
applies
to
index
html
as
well
let
original
toc
parse
to
string
toc
in
original
toc
ul
add
class
ul
content
insert
after
toc
original
toc
in
let
nav
create
element
nav
class
toc
in
let
match
toc
with
None
prepend
child
body
nav
Some
toc
wrap
toc
nav
in
let
nav
body
nav
in
wrap
nav
create
element
id
sidebar
header
begin
match
toc
with
None
dbg
No
TOC
for
s
file
Some
toc
begin
TOC
Create
a
title
entry
in
the
menu
let
a
create
element
a
inner
text
title
attributes
href
in
let
li
create
element
li
class
top
in
append
child
li
a
prepend
child
toc
li
index
of
keywords
if
file
index
html
then
begin
let
keywords
body
ul
fold
fun
key
ul
match
key
with
None
begin
match
ul
li
last
with
None
None
Some
l
begin
match
l
a
leaf
text
with
Some
text
dbg
s
text
if
text
Index
of
keywords
then
l
a
attribute
href
else
None
None
None
end
end
key
None
in
begin
match
keywords
with
None
dbg
Could
not
find
Index
of
keywords
Some
keywords
let
a
create
element
a
inner
text
Index
of
keywords
attributes
href
keywords
in
let
li
create
element
li
in
append
child
li
a
append
child
toc
li
end
Link
to
APIs
let
a
create
element
a
inner
text
OCaml
API
attributes
href
api
page
url
index
html
in
let
li
create
element
li
in
append
child
li
a
append
child
toc
li
let
a
create
element
a
inner
text
OCaml
Compiler
API
attributes
href
api
page
url
compilerlibref
index
html
in
let
li
create
element
li
in
append
child
li
a
append
child
toc
li
end
end
end
Add
back
link
to
OCaml
Manual
if
file
index
html
then
begin
let
toc
title
create
element
div
class
toc
title
in
let
a
create
element
a
inner
text
The
OCaml
Manual
attributes
href
index
html
in
append
child
toc
title
a
prepend
child
nav
toc
title
end
Add
version
number
let
version
text
if
file
index
html
then
Select
another
version
else
Version
version
in
add
version
link
nav
version
text
releases
url
toc
Create
menu
for
all
chapters
in
the
part
let
make
part
menu
part
title
chapters
file
body
let
menu
create
element
ul
id
part
menu
in
List
iter
fun
href
title
let
a
create
element
a
inner
text
title
attributes
href
href
in
let
li
if
href
file
then
create
element
li
class
active
else
create
element
li
in
append
child
li
a
append
child
menu
li
chapters
prepend
child
body
menu
Add
part
title
just
before
the
part
menu
if
part
title
then
begin
let
nav
create
element
id
part
title
nav
inner
text
part
title
in
create
element
span
inner
text

prepend
child
nav
prepend
child
body
nav
end
Add
logo
let
add
logo
file
soup
match
soup
header
with
None
dbg
Warning
no
header
for
s
file
Some
header
prepend
child
header
logo
html
https
ocaml
org
Move
authors
to
the
end
let
move
authors
body
body
writtenby
css
Option
iter
fun
authors
match
leaf
text
authors
with
None
Some
s
match
Re
Str
search
forward
regexp
written
by
s
0
with
exception
Not
found
dbg
Moving
authors
delete
authors
add
class
authors
authors
append
child
body
authors
Get
the
list
of
external
files
linked
by
the
current
file
let
get
xfiles
function
None
Some
toc
toc
li
fold
fun
list
li
let
rf
li
a
R
attribute
href
in
dbg
TOC
reference
s
rf
if
not
String
contains
rf
not
starts
with
api
rf
not
starts
with
http
rf
then
begin
li
a
set
attribute
href
rf
start
section
rf
list
end
else
list
This
is
the
main
script
for
processing
a
specified
file
convert
has
to
be
run
for
each
entry
file
of
the
manual
making
a
Chapter
The
list
of
chapters
corresponds
to
a
Part
of
the
manual
let
convert
version
part
title
chapters
toc
table
file
title
dbg
s
s
html
file
file
docs
file
file
Parse
html
let
soup
parse
load
html
file
in
Change
title
add
javascript
and
favicon
change
title
title
soup
update
head
soup
Wrap
body
let
c
if
file
index
html
then
manual
content
index
else
manual
content
in
let
body
wrap
body
classes
c
soup
in
if
file
index
html
then
convert
index
version
soup
Make
sidebar
let
toc
make
toc
sidebar
version
title
file
body
in
Make
top
menu
for
chapters
make
part
menu
part
title
chapters
file
body
Add
side
bar
button
before
part
title
add
sidebar
button
body
Add
logo
add
logo
file
soup
Move
authors
to
the
end
move
authors
body
Bottom
navigation
links
update
navigation
soup
toc
table
Add
copyright
append
child
body
copyright
Save
html
save
to
file
soup
file
Finally
generate
external
files
to
be
converted
this
should
be
done
at
the
end
because
it
deeply
mutates
the
original
soup
let
xfiles
get
xfiles
toc
in
let
template
make
template
soup
in
List
iter
insert
xfile
content
soup
template
toc
table
xfiles
Completely
process
the
given
version
of
the
manual
Returns
the
names
of
the
main
html
files
let
process
version
print
endline
sprintf
nProcessing
version
s
into
s
n
version
docs
maindir
dbg
Current
directory
is
s
Sys
getcwd
dbg
Scanning
index
let
toc
table
all
chapters
parse
toc
in
special
case
of
the
index
html
file
convert
version
toc
table
index
html
The
OCaml
Manual
let
main
files
List
fold
left
fun
list
part
title
chapters
dbg
Processing
chapters
for
s
part
title
List
iter
convert
version
part
title
chapters
toc
table
chapters
fst
List
hd
chapters
list
all
chapters
in
main
files
let
let
list
process
find
version
in
print
endline
DONE
Local
Variables
compile
command
dune
build
End
manual
src
html
processing
src
common
ml
Generated
from
common
ml
in
by
configure
2
manual
src
html
processing
src
common
ml
in
OCaml
Web
manual
Copyright
San
Vu
Ngoc
2020
file
common
ml
This
file
contains
functions
that
are
used
by
process
api
ml
and
process
manual
ml
open
Soup
let
debug
not
Array
mem
quiet
Sys
argv
let
dbg
let
printf
Printf
if
debug
then
kfprintf
else
ikfprintf
in
let
flush
if
debug
then
fun
ch
output
char
ch
n
flush
ch
else
ignore
in
fun
fmt
printf
flush
stdout
fmt
let
Filename
concat
let
process
dir
Filename
current
dir
name
let
ocaml
version
5
5
Output
directory
let
web
dir
Filename
parent
dir
name
webman
ocaml
version
Output
for
manual
let
docs
maindir
web
dir
let
docs
file
docs
maindir
Output
for
API
let
api
dir
web
dir
api
How
to
go
from
manual
to
api
let
api
page
url
api
How
to
go
from
api
to
manual
let
manual
page
url
Set
this
to
the
directory
where
to
find
the
html
sources
of
all
versions
let
html
maindir
htmlman
Where
to
get
the
original
html
files
let
html
file
html
maindir
let
releases
url
https
ocaml
org
releases
let
favicon
favicon
ico
utilities
let
flat
option
f
o
Option
bind
o
f
let
f
g
x
f
g
x
let
string
of
opt
Option
value
default
let
starts
with
substring
s
let
l
String
length
substring
in
l
String
length
s
String
sub
s
0
l
substring
html
processing
Return
next
html
element
let
rec
next
node
match
next
element
node
with
Some
n
n
None
match
parent
node
with
Some
p
next
p
None
raise
Not
found
let
logo
html
url
nav
class
toc
brand
a
class
brand
href
url
img
src
colour
logo
svg
class
svg
alt
OCaml
a
nav
parse
let
wrap
body
classes
soup
let
body
soup
body
in
set
name
div
body
List
iter
fun
c
add
class
c
body
classes
wrap
body
create
element
body
body
Add
favicon
let
add
favicon
head
parse
link
rel
shortcut
icon
type
image
x
icon
href
favicon
append
child
head
Update
html
head
element
with
javascript
and
favicon
Including
script
js
for
OCaml
org
s
instance
of
Plausible
Analytics
let
update
head
search
false
soup
let
head
soup
head
in
if
search
then
begin
create
element
script
attributes
src
search
js
append
child
head
end
create
element
script
attributes
src
scroll
js
append
child
head
create
element
script
attributes
src
navigation
js
append
child
head
create
element
script
attributes
src
https
plausible
ci
dev
js
script
js
defer
data
domain
ocaml
org
append
child
head
add
favicon
head
Add
version
number
let
add
version
link
nav
text
url
let
vnum
create
element
div
class
toc
version
in
let
a
create
element
a
inner
text
text
attributes
href
url
id
version
select
in
append
child
vnum
a
prepend
child
nav
vnum
let
add
sidebar
button
body
let
btn
create
element
div
id
sidebar
button
in
create
element
span
inner
text

prepend
child
btn
prepend
child
body
btn
let
find
version
5
5
Local
Variables
compile
command
dune
build
End
chapter
Further
reading
For
the
interested
reader
we
list
below
some
references
to
books
and
reports
related
sometimes
loosely
to
Caml
Light
section
Programming
in
ML
The
books
below
are
programming
courses
taught
in
ML
Their
main
goal
is
to
teach
programming
not
to
describe
ML
in
full
details
though
most
contain
fairly
good
introductions
to
the
ML
language
Some
of
those
books
use
the
Standard
ML
dialect
instead
of
the
Caml
dialect
so
you
will
have
to
keep
in
mind
the
differences
in
syntax
and
in
semantics
begin
itemize
item
Pierre
Weis
and
Xavier
Leroy
it
Le
langage
Caml
Interditions
1993
The
natural
companion
to
this
manual
provided
you
read
French
This
book
is
a
step
by
step
introduction
to
programming
in
Caml
and
presents
many
realistic
examples
of
Caml
programs
item
Guy
Cousineau
and
Michel
Mauny
it
Approche
fonctionnelle
de
la
programmation
Ediscience
1995
Another
Caml
programming
course
written
in
French
with
many
original
examples
item
Lawrence
C
Paulson
it
ML
for
the
working
programmer
Cambridge
University
Press
1991
A
good
introduction
to
programming
in
Standard
ML
Develops
a
theorem
prover
as
a
complete
example
Contains
a
presentation
of
the
module
system
of
Standard
ML
item
Jeffrey
D
Ullman
it
Elements
of
ML
programming
Prentice
Hall
1993
Another
good
introduction
to
programming
in
Standard
ML
No
realistic
examples
but
a
very
detailed
presentation
of
the
language
constructs
item
Ryan
Stansifer
em
ML
primer
Prentice
Hall
1992
A
short
but
nice
introduction
to
programming
in
Standard
ML
item
Thrse
Accart
Hardin
and
Vronique
Donzeau
Gouge
Vigui
em
Concepts
et
outils
de
la
programmation
Du
fonctionnel
?
l
impratif
avec
Caml
et
Ada
Interditions
1992
A
first
course
in
programming
that
first
introduces
the
main
programming
notions
in
Caml
then
shows
them
underlying
Ada
Intended
for
beginners
slow
paced
for
the
others
item
Rachel
Harrison
em
Abstract
Data
Types
in
Standard
ML
John
Wiley
Sons
1993
A
presentation
of
Standard
ML
from
the
standpoint
of
abstract
data
types
Uses
intensively
the
Standard
ML
module
system
item
Harold
Abelson
and
Gerald
Jay
Sussman
em
Structure
and
Interpretation
of
Computer
Programs
The
MIT
press
1985
French
translation
em
Structure
et
interprtation
des
programmes
informatiques
Interditions
1989
An
outstanding
course
on
programming
taught
in
Scheme
the
modern
dialect
of
Lisp
Well
worth
reading
even
if
you
are
more
interested
in
ML
than
in
Lisp
end
itemize
section
Descriptions
of
ML
dialects
The
books
and
reports
below
are
descriptions
of
various
programming
languages
from
the
ML
family
They
assume
some
familiarity
with
ML
begin
itemize
item
Xavier
Leroy
and
Pierre
Weis
em
Manuel
de
rfrence
du
langage
Caml
Interditions
1993
The
French
edition
of
the
present
reference
manual
and
user
s
manual
item
Robert
Harper
em
Introduction
to
Standard
ML
Technical
report
ECS
LFCS
86
14
University
of
Edinburgh
1986
An
overview
of
Standard
ML
including
the
module
system
Terse
but
still
readable
item
Robin
Milner
Mads
Tofte
and
Robert
Harper
em
The
definition
of
Standard
ML
The
MIT
press
1990
A
complete
formal
definition
of
Standard
ML
in
the
framework
of
structured
operational
semantics
This
book
is
probably
the
most
mathematically
precise
definition
of
a
programming
language
ever
written
It
is
heavy
on
formalism
and
extremely
terse
so
even
readers
who
are
thoroughly
familiar
with
ML
will
have
major
difficulties
with
it
item
Robin
Milner
and
Mads
Tofte
em
Commentary
on
Standard
ML
The
MIT
Press
1991
A
commentary
on
the
book
above
that
attempts
to
explain
the
most
delicate
parts
and
motivate
the
design
choices
Easier
to
read
than
the
Definition
but
still
rather
involving
item
Guy
Cousineau
and
Grard
Huet
em
The
CAML
primer
Technical
report
122
INRIA
1990
A
short
description
of
the
original
Caml
system
from
which
Caml
Light
has
evolved
Some
familiarity
with
Lisp
is
assumed
item
Pierre
Weis
et
al
em
The
CAML
reference
manual
version
2
6
1
Technical
report
121
INRIA
1990
The
manual
for
the
original
Caml
system
from
which
Caml
Light
has
evolved
item
Michael
J
Gordon
Arthur
J
Milner
and
Christopher
P
Wadsworth
em
Edinburgh
LCF
Lecture
Notes
in
Computer
Science
volume
78
Springer
Verlag
1979
This
is
the
first
published
description
of
the
ML
language
at
the
time
when
it
was
nothing
more
than
the
control
language
for
the
LCF
system
a
theorem
prover
This
book
is
now
obsolete
since
the
ML
language
has
much
evolved
since
then
but
it
is
still
of
historical
interest
item
Paul
Hudak
Simon
Peyton
Jones
and
Philip
Wadler
em
Report
on
the
programming
language
Haskell
version
1
1
Technical
report
Yale
University
1991
Haskell
is
a
purely
functional
language
with
lazy
semantics
that
shares
many
important
points
with
ML
full
functionality
polymorphic
typing
but
has
interesting
features
of
its
own
dynamic
overloading
also
called
type
classes
end
itemize
section
Implementing
functional
programming
languages
The
references
below
are
intended
for
those
who
are
curious
to
learn
how
a
language
like
Caml
Light
is
compiled
and
implemented
begin
itemize
item
Xavier
Leroy
em
The
ZINC
experiment
an
economical
implementation
of
the
ML
language
Technical
report
117
INRIA
1990
Available
by
anonymous
FTP
on
ftp
inria
fr
A
description
of
the
ZINC
implementation
the
prototype
ML
implementation
that
has
evolved
into
Caml
Light
Large
parts
of
this
report
still
apply
to
the
current
Caml
Light
system
in
particular
the
description
of
the
execution
model
and
abstract
machine
Other
parts
are
now
obsolete
Yet
this
report
still
gives
a
complete
overview
of
the
implementation
techniques
used
in
Caml
Light
item
Simon
Peyton
Jones
em
The
implementation
of
functional
programming
languages
Prentice
Hall
1987
French
translation
em
Mise
en
oe
uvre
des
langages
fonctionnels
de
programmation
Masson
1990
An
excellent
description
of
the
implementation
of
purely
functional
languages
with
lazy
semantics
using
the
technique
known
as
graph
reduction
The
part
of
the
book
that
deals
with
the
transformation
from
ML
to
enriched
lambda
calculus
directly
applies
to
Caml
Light
You
will
find
a
good
description
of
how
pattern
matching
is
compiled
and
how
types
are
inferred
The
remainder
of
the
book
does
not
apply
directly
to
Caml
Light
since
Caml
Light
is
not
purely
functional
it
has
side
effects
has
strict
semantics
and
does
not
use
graph
reduction
at
all
item
Andrew
W
Appel
em
Compiling
with
continuations
Cambridge
University
Press
1992
A
complete
description
of
an
optimizing
compiler
for
Standard
ML
based
on
an
intermediate
representation
called
continuation
passing
style
Shows
how
many
advanced
program
optimizations
can
be
applied
to
ML
Not
directly
relevant
to
the
Caml
Light
system
since
Caml
Light
does
not
use
continuation
passing
style
at
all
and
makes
little
attempts
at
optimizing
programs
end
itemize
section
Applications
of
ML
The
following
reports
show
ML
at
work
in
various
sometimes
unexpected
areas
begin
itemize
item
Emmanuel
Chailloux
and
Guy
Cousineau
em
The
MLgraph
primer
Technical
report
92
15
cole
Normale
Suprieure
1992
Available
by
anonymous
FTP
on
ftp
ens
fr
rpertoire
biblio
fichier
liens
92
15
A4
300dpi
ps
Z
Describes
a
Caml
Light
library
that
produces
Postscript
pictures
through
high
level
drawing
functions
item
Xavier
Leroy
em
Programmation
du
systme
Unix
en
Caml
Light
Technical
report
147
INRIA
1992
Available
by
anonymous
FTP
on
ftp
inria
fr
rpertoire
INRIA
publication
fichier
RT
0147
ps
Z
A
Unix
systems
programming
course
demonstrating
the
use
of
the
Caml
Light
library
that
gives
access
to
Unix
system
calls
item
John
H
Reppy
em
Concurrent
programming
with
events
The
concurrent
ML
manual
Cornell
University
1990
Available
by
anonymous
FTP
on
research
att
com
rpertoire
dist
ml
fichier
CML
0
9
8
tar
Z
Concurrent
ML
extends
Standard
ML
of
New
Jersey
with
concurrent
processes
that
communicate
through
channels
and
events
item
Jeannette
M
Wing
Manuel
Faehndrich
J
Gregory
Morrisett
and
Scottt
Nettles
em
Extensions
to
Standard
ML
to
support
transactions
Technical
report
CMU
CS
92
132
Carnegie
Mellon
University
1992
Available
by
anonymous
FTP
on
reports
adm
cs
cmu
edu
rpertoire
1992
fichier
CMU
CS
92
132
ps
How
to
integrate
the
basic
database
operations
to
Standard
ML
item
Emden
R
Gansner
and
John
H
Reppy
em
eXene
Bell
Labs
1991
Available
by
anonymous
FTP
on
research
att
com
rpertoire
dist
ml
fichier
eXene
0
4
tar
Z
An
interface
between
Standard
ML
of
New
Jersey
and
the
X
Windows
windowing
system
item
Daniel
de
Rauglaudre
em
X
toolkit
in
Caml
Light
INRIA
1992
Included
in
the
Caml
Light
distribution
Disponible
par
FTP
anonyme
sur
ftp
inria
fr
rpertoire
lang
caml
light
fichier
rt5
tar
Z
An
interface
between
Caml
Light
and
the
X
Windows
windowing
system
end
itemize
section
s
lexical
conventions
Lexical
conventions
HEVEA
cutname
lex
html
subsubsection
sss
lex
text
encoding
Source
file
encoding
OCaml
source
files
are
expected
to
be
valid
UTF
8
encoded
Unicode
text
The
interpretation
of
source
files
which
are
not
UTF
8
encoded
is
unspecified
Such
source
files
may
be
rejected
in
the
future
subsubsection
sss
lex
blanks
Blanks
The
following
characters
are
considered
as
blanks
space
horizontal
tabulation
carriage
return
line
feed
and
form
feed
Blanks
are
ignored
but
they
separate
adjacent
identifiers
literals
and
keywords
that
would
otherwise
be
confused
as
one
single
identifier
literal
or
keyword
subsubsection
sss
lex
comments
Comments
Comments
are
introduced
by
the
two
characters
with
no
intervening
blanks
and
terminated
by
the
characters
with
no
intervening
blanks
Comments
are
treated
as
blank
characters
Comments
do
not
occur
inside
string
or
character
literals
Nested
comments
are
handled
correctly
begin
caml
example
verbatim
single
line
comment
multiple
line
comment
commenting
out
part
of
a
program
and
containing
a
nested
comment
let
f
function
A
Z
Uppercase
Add
other
cases
later
end
caml
example
subsubsection
sss
lex
identifiers
Identifiers
begin
syntax
ident
letter
letter
0
ldots
9
capitalized
ident
uppercase
letter
letter
0
ldots
9
lowercase
ident
lowercase
letter
letter
0
ldots
9
letter
uppercase
letter
lowercase
letter
lowercase
letter
a
ldots
z
U
00DF
ldots
U
00F6
U
00F8
dots
U
00FF
U
0153
U
0161
U
017E
uppercase
letter
A
ldots
Z
U
00C0
ldots
U
00D6
U
00D8
ldots
U
00DE
U
0152
U
0160
U
017D
U
0178
U
1E9E
end
syntax
Identifiers
are
sequences
of
letters
digits
the
underscore
character
and
the
single
quote
starting
with
a
letter
or
an
underscore
Letters
contain
the
52
lowercase
and
uppercase
letters
from
the
ASCII
set
letters
?
?
?

from
the
Latin
1
Supplement
block
letters
?

from
the
Latin
Extended
A
block
and
upper
case

U
189E
Any
byte
sequence
which
is
equivalent
to
one
of
these
Unicode
characters
under
NFC
footnote
Normalization
Form
C
is
supported
too
All
characters
in
an
identifier
are
meaningful
The
current
implementation
accepts
identifiers
up
to
16000000
characters
in
length
In
many
places
OCaml
makes
a
distinction
between
capitalized
identifiers
and
identifiers
that
begin
with
a
lowercase
letter
The
underscore
character
is
considered
a
lowercase
letter
for
this
purpose
subsubsection
sss
integer
literals
Integer
literals
begin
syntax
integer
literal
0
ldots
9
0
ldots
9
0x
0X
0
ldots
9
A
ldots
F
a
ldots
f
0
ldots
9
A
ldots
F
a
ldots
f
0o
0O
0
ldots
7
0
ldots
7
0b
0B
0
ldots
1
0
ldots
1
int32
literal
integer
literal
l
int64
literal
integer
literal
L
nativeint
literal
integer
literal
n
end
syntax
An
integer
literal
is
a
sequence
of
one
or
more
digits
optionally
preceded
by
a
minus
sign
By
default
integer
literals
are
in
decimal
radix
10
The
following
prefixes
select
a
different
radix
begin
tableau
l
l
Prefix
Radix
entree
0x
0X
hexadecimal
radix
16
entree
0o
0O
octal
radix
8
entree
0b
0B
binary
radix
2
end
tableau
The
initial
0
is
the
digit
zero
the
O
for
octal
is
the
letter
O
An
integer
literal
can
be
followed
by
one
of
the
letters
l
L
or
n
to
indicate
that
this
integer
has
type
int32
int64
or
nativeint
respectively
instead
of
the
default
type
int
for
integer
literals
The
interpretation
of
integer
literals
that
fall
outside
the
range
of
representable
integer
values
is
undefined
For
convenience
and
readability
underscore
characters
are
accepted
and
ignored
within
integer
literals
begin
caml
example
toplevel
let
house
number
37
let
million
1
000
000
let
copyright
0x00A9
let
counter64bit
ref
0L
end
caml
example
subsubsection
sss
floating
point
literals
Floating
point
literals
begin
syntax
float
literal
0
ldots
9
0
ldots
9
0
ldots
9
e
E
0
ldots
9
0
ldots
9
0x
0X
0
ldots
9
A
ldots
F
a
ldots
f
0
ldots
9
A
ldots
F
a
ldots
f
0
ldots
9
A
ldots
F
a
ldots
f
p
P
0
ldots
9
0
ldots
9
end
syntax
Floating
point
decimal
literals
consist
in
an
integer
part
a
fractional
part
and
an
exponent
part
The
integer
part
is
a
sequence
of
one
or
more
digits
optionally
preceded
by
a
minus
sign
The
fractional
part
is
a
decimal
point
followed
by
zero
one
or
more
digits
The
exponent
part
is
the
character
e
or
E
followed
by
an
optional
or
sign
followed
by
one
or
more
digits
It
is
interpreted
as
a
power
of
10
The
fractional
part
or
the
exponent
part
can
be
omitted
but
not
both
to
avoid
ambiguity
with
integer
literals
The
interpretation
of
floating
point
literals
that
fall
outside
the
range
of
representable
floating
point
values
is
undefined
Floating
point
hexadecimal
literals
are
denoted
with
the
0x
or
0X
prefix
The
syntax
is
similar
to
that
of
floating
point
decimal
literals
with
the
following
differences
The
integer
part
and
the
fractional
part
use
hexadecimal
digits
The
exponent
part
starts
with
the
character
p
or
P
It
is
written
in
decimal
and
interpreted
as
a
power
of
2
For
convenience
and
readability
underscore
characters
are
accepted
and
ignored
within
floating
point
literals
begin
caml
example
toplevel
let
pi
3
141
592
653
589
793
12
let
small
negative
1e
5
let
machine
epsilon
0x1p
52
end
caml
example
subsubsection
sss
character
literals
Character
literals
label
s
characterliteral
begin
syntax
char
literal
regular
char
escape
sequence
escape
sequence
n
t
b
r
space
0
ldots
9
0
ldots
9
0
ldots
9
x
0
ldots
9
A
ldots
F
a
ldots
f
0
ldots
9
A
ldots
F
a
ldots
f
o
0
ldots
3
0
ldots
7
0
ldots
7
end
syntax
Character
literals
are
delimited
by
single
quote
characters
The
two
single
quotes
enclose
either
one
character
different
from
and
or
one
of
the
escape
sequences
below
begin
tableau
l
l
Sequence
Character
denoted
entree
backslash
entree
double
quote
entree
single
quote
entree
n
linefeed
LF
entree
r
carriage
return
CR
entree
t
horizontal
tabulation
TAB
entree
b
backspace
BS
entree
var
space
space
SPC
entree
var
ddd
the
character
with
ASCII
code
var
ddd
in
decimal
entree
x
var
hh
the
character
with
ASCII
code
var
hh
in
hexadecimal
entree
o
var
ooo
the
character
with
ASCII
code
var
ooo
in
octal
end
tableau
begin
caml
example
toplevel
let
a
a
let
single
quote
let
copyright
xA9
end
caml
example
subsubsection
sss
stringliterals
String
literals
begin
syntax
string
literal
string
character
quoted
string
id
newline
any
char
quoted
string
id
quoted
string
id
lowercase
letter
string
character
regular
string
char
escape
sequence
u
0
ldots
9
A
ldots
F
a
ldots
f
newline
newline
space
tab
end
syntax
String
literals
are
delimited
by
double
quote
characters
The
two
double
quotes
enclose
a
sequence
of
either
characters
different
from
and
or
escape
sequences
from
the
table
given
above
for
character
literals
or
a
Unicode
character
escape
sequence
A
Unicode
character
escape
sequence
is
substituted
by
the
UTF
8
encoding
of
the
specified
Unicode
scalar
value
The
Unicode
scalar
value
an
integer
in
the
ranges
0x0000
0xD7FF
or
0xE000
0x10FFFF
is
defined
using
1
to
6
hexadecimal
digits
leading
zeros
are
allowed
begin
caml
example
toplevel
let
greeting
Hello
World
n
let
superscript
plus
u
207A
end
caml
example
A
newline
sequence
is
a
line
feed
optionally
preceded
by
a
carriage
return
Since
OCaml
5
2
a
newline
sequence
occurring
in
a
string
literal
is
normalized
into
a
single
line
feed
character
To
allow
splitting
long
string
literals
across
lines
the
sequence
var
newline
var
spaces
or
tabs
a
backslash
at
the
end
of
a
line
followed
by
any
number
of
spaces
and
horizontal
tabulations
at
the
beginning
of
the
next
line
is
ignored
inside
string
literals
begin
caml
example
toplevel
let
longstr
Call
me
Ishmael
Some
years
ago

never
mind
how
long
precisely

having
little
or
no
money
in
my
purse
and
nothing
particular
to
interest
me
on
shore
I
thought
I
would
sail
about
a
little
and
see
the
watery
part
of
t
he
world
end
caml
example
Escaped
newlines
provide
more
convenient
behavior
than
non
escaped
newlines
as
the
indentation
is
not
considered
part
of
the
string
literal
begin
caml
example
toplevel
let
contains
unexpected
spaces
This
multiline
literal
contains
three
consecutive
spaces
let
no
unexpected
spaces
This
multiline
literal
n
uses
a
single
space
between
all
words
end
caml
example
Quoted
string
literals
provide
an
alternative
lexical
syntax
for
string
literals
They
are
useful
to
represent
strings
of
arbitrary
content
without
escaping
Quoted
strings
are
delimited
by
a
matching
pair
of
quoted
string
id
and
quoted
string
id
with
the
same
quoted
string
id
on
both
sides
Quoted
strings
do
not
interpret
any
character
in
a
special
way
footnote
Except
for
the
normalization
of
newline
sequences
into
a
single
line
feed
mentioned
earlier
but
requires
that
the
sequence
quoted
string
id
does
not
occur
in
the
string
itself
The
identifier
quoted
string
id
is
a
possibly
empty
sequence
of
lowercase
letters
and
underscores
that
can
be
freely
chosen
to
avoid
such
issue
begin
caml
example
toplevel
let
quoted
greeting
Hello
World
let
nested
ext
hello
world
ext
end
caml
example
The
current
implementation
places
practically
no
restrictions
on
the
length
of
string
literals
subsubsection
sss
labelname
Naming
labels
To
avoid
ambiguities
naming
labels
in
expressions
cannot
just
be
defined
syntactically
as
the
sequence
of
the
three
tokens
ident
and
and
have
to
be
defined
at
the
lexical
level
begin
syntax
label
name
lowercase
ident
label
label
name
optlabel
label
name
end
syntax
Naming
labels
come
in
two
flavours
label
for
normal
arguments
and
optlabel
for
optional
ones
They
are
simply
distinguished
by
their
first
character
either
or
Despite
label
and
optlabel
being
lexical
entities
in
expressions
their
expansions
label
name
and
label
name
will
be
used
in
grammars
for
the
sake
of
readability
Note
also
that
inside
type
expressions
this
expansion
can
be
taken
literally
em
i
e
there
are
really
3
tokens
with
optional
blanks
between
them
subsubsection
sss
lex
ops
symbols
Prefix
and
infix
symbols
lowercase
ident
begin
syntax
infix
symbol
core
operator
char
operator
char
operator
char
prefix
symbol
operator
char
operator
char
operator
char
core
operator
char
core
operator
char
end
syntax
See
also
the
following
language
extensions
hyperref
s
ext
ops
extension
operators
hyperref
s
index
operators
extended
indexing
operators
and
hyperref
s
binding
operators
binding
operators
Sequences
of
operator
characters
such
as
or
are
read
as
a
single
token
from
the
infix
symbol
or
prefix
symbol
class
These
symbols
are
parsed
as
prefix
and
infix
operators
inside
expressions
but
otherwise
behave
like
normal
identifiers
Identifiers
starting
with
a
lowercase
letter
and
enclosed
between
backquote
characters
lowercase
ident
are
also
parsed
as
infix
operators
subsubsection
sss
keywords
Keywords
The
identifiers
below
are
reserved
as
keywords
and
cannot
be
employed
otherwise
begin
verbatim
and
as
assert
asr
begin
class
constraint
do
done
downto
else
end
exception
external
false
for
fun
function
functor
if
in
include
inherit
initializer
land
lazy
let
lor
lsl
lsr
lxor
match
method
mod
module
mutable
new
nonrec
object
of
open
or
private
rec
sig
struct
then
to
true
try
type
val
virtual
when
while
with
end
verbatim
goodbreak
The
following
character
sequences
are
also
keywords
FIXME
the
token
is
not
used
anywhere
in
the
syntax
begin
alltt
end
alltt
Note
that
the
following
identifiers
are
keywords
of
the
now
unmaintained
Camlp4
system
and
should
be
avoided
for
backwards
compatibility
reasons
begin
verbatim
parser
value
end
verbatim
subsubsection
sss
lex
ambiguities
Ambiguities
Lexical
ambiguities
are
resolved
according
to
the
longest
match
rule
when
a
character
sequence
can
be
decomposed
into
two
tokens
in
several
different
ways
the
decomposition
retained
is
the
one
with
the
longest
first
token
subsubsection
sss
lex
linedir
Line
number
directives
begin
syntax
linenum
directive
0
ldots
9
string
character
end
syntax
Preprocessors
that
generate
OCaml
source
code
can
insert
line
number
directives
in
their
output
so
that
error
messages
produced
by
the
compiler
contain
line
numbers
and
file
names
referring
to
the
source
file
before
preprocessing
instead
of
after
preprocessing
A
line
number
directive
starts
at
the
beginning
of
a
line
is
composed
of
a
sharp
sign
followed
by
a
positive
integer
the
source
line
number
followed
by
a
character
string
the
source
file
name
Line
number
directives
are
treated
as
blanks
during
lexical
analysis
FIXME
spaces
and
tabs
are
allowed
before
and
after
the
number
FIXME
string
character
is
inaccurate
everything
is
allowed
except
CR
LF
and
doublequote
moreover
backslash
escapes
are
not
interpreted
especially
backslash
doublequote
FIXME
any
number
of
random
characters
are
allowed
and
ignored
at
the
end
of
the
line
except
CR
and
LF
section
s
patterns
Patterns
ikwd
as
texttt
as
HEVEA
cutname
patterns
html
begin
syntax
pattern
value
name
constant
pattern
as
value
name
pattern
pattern
typexpr
pattern
pattern
constr
pattern
tag
name
pattern
typeconstr
pattern
pattern
field
typexpr
pattern
field
typexpr
pattern
pattern
pattern
pattern
pattern
pattern
pattern
char
literal
char
literal
lazy
pattern
exception
pattern
module
path
pattern
module
path
pattern
module
path
pattern
module
path
pattern
end
syntax
See
also
the
following
language
extensions
hyperref
s
first
class
modules
first
class
modules
hyperref
s
attributes
attributes
hyperref
s
extension
nodes
extension
nodes
hyperref
s
effect
handlers
effect
handlers
hyperref
s
array
literals
type
directed
disambiguation
of
array
literals
and
hyperref
s
labeled
tuples
labeled
tuples
The
table
below
shows
the
relative
precedences
and
associativity
of
operators
and
non
closed
pattern
constructions
The
constructions
with
higher
precedences
come
first
ikwd
as
texttt
as
begin
tableau
l
l
Operator
Associativity
entree
entree
lazy
see
section
ref
sss
pat
lazy
entree
Constructor
application
Tag
application
right
entree
right
entree
entree
left
entree
as
end
tableau
Patterns
are
templates
that
allow
selecting
data
structures
of
a
given
shape
and
binding
identifiers
to
components
of
the
data
structure
This
selection
operation
is
called
pattern
matching
its
outcome
is
either
this
value
does
not
match
this
pattern
or
this
value
matches
this
pattern
resulting
in
the
following
bindings
of
names
to
values
subsubsection
sss
pat
variable
Variable
patterns
A
pattern
that
consists
in
a
value
name
matches
any
value
binding
the
name
to
the
value
The
pattern
also
matches
any
value
but
does
not
bind
any
name
begin
caml
example
toplevel
let
is
empty
function
true
false
end
caml
example
Patterns
are
em
linear
a
variable
cannot
be
bound
several
times
by
a
given
pattern
In
particular
there
is
no
way
to
test
for
equality
between
two
parts
of
a
data
structure
using
only
a
pattern
begin
caml
example
toplevel
error
let
pair
equal
function
x
x
true
x
y
false
end
caml
example
However
we
can
use
a
when
guard
for
this
purpose
begin
caml
example
toplevel
let
pair
equal
function
x
y
when
x
y
true
false
end
caml
example
subsubsection
sss
pat
const
Constant
patterns
A
pattern
consisting
in
a
constant
matches
the
values
that
are
equal
to
this
constant
begin
caml
example
toplevel
let
bool
of
string
function
true
true
false
false
raise
Invalid
argument
bool
of
string
end
caml
example
FIXME
for
negative
numbers
blanks
are
allowed
between
the
minus
sign
and
the
first
digit
subsubsection
sss
pat
alias
Alias
patterns
ikwd
as
texttt
as
The
pattern
pattern
1
as
value
name
matches
the
same
values
as
pattern
1
If
the
matching
against
pattern
1
is
successful
the
name
value
name
is
bound
to
the
matched
value
in
addition
to
the
bindings
performed
by
the
matching
against
pattern
1
begin
caml
example
toplevel
let
sort
pair
x
y
as
p
if
x
y
then
p
else
y
x
end
caml
example
subsubsection
sss
pat
parenthesized
Parenthesized
patterns
The
pattern
pattern
1
matches
the
same
values
as
pattern
1
A
type
constraint
can
appear
in
a
parenthesized
pattern
as
in
pattern
1
typexpr
This
constraint
forces
the
type
of
pattern
1
to
be
compatible
with
typexpr
begin
caml
example
toplevel
let
int
triple
is
ordered
a
b
c
int
int
int
a
b
b
c
end
caml
example
subsubsection
sss
pat
or
Or
patterns
The
pattern
pattern
1
pattern
2
represents
the
logical
or
of
the
two
patterns
pattern
1
and
pattern
2
A
value
matches
pattern
1
pattern
2
if
it
matches
pattern
1
or
pattern
2
The
two
sub
patterns
pattern
1
and
pattern
2
must
bind
exactly
the
same
identifiers
to
values
having
the
same
types
Matching
is
performed
from
left
to
right
More
precisely
in
case
some
value
v
matches
pattern
1
pattern
2
the
bindings
performed
are
those
of
pattern
1
when
v
matches
pattern
1
Otherwise
value
v
matches
pattern
2
whose
bindings
are
performed
begin
caml
example
toplevel
type
shape
Square
of
float
Rect
of
float
float
Circle
of
float
let
is
rectangular
function
Square
Rect
true
Circle
false
end
caml
example
subsubsection
sss
pat
variant
Variant
patterns
The
pattern
constr
pattern
1
ldots
pattern
n
matches
all
variants
whose
constructor
is
equal
to
constr
and
whose
arguments
match
pattern
1
ldots
pattern
n
It
is
a
type
error
if
n
is
not
the
number
of
arguments
expected
by
the
constructor
The
pattern
constr
matches
all
variants
whose
constructor
is
constr
begin
caml
example
toplevel
type
a
tree
Lf
Br
of
a
tree
a
a
tree
let
rec
total
function
Br
l
x
r
total
l
x
total
r
Lf
0
end
caml
example
The
pattern
pattern
1
pattern
2
matches
non
empty
lists
whose
heads
match
pattern
1
and
whose
tails
match
pattern
2
The
pattern
pattern
1
ldots
pattern
n
matches
lists
of
length
n
whose
elements
match
pattern
1
ldots
pattern
n
respectively
This
pattern
behaves
like
pattern
1
ldots
pattern
n
begin
caml
example
toplevel
let
rec
destutter
function
a
a
a
b
t
if
a
b
then
destutter
b
t
else
a
destutter
b
t
end
caml
example
subsubsection
sss
pat
polyvar
Polymorphic
variant
patterns
The
pattern
tag
name
pattern
1
matches
all
polymorphic
variants
whose
tag
is
equal
to
tag
name
and
whose
argument
matches
pattern
1
begin
caml
example
toplevel
let
rec
split
function
h
t
let
ss
gs
split
t
in
match
h
with
Sheep
as
s
s
ss
gs
Goat
as
g
ss
g
gs
end
caml
example
subsubsection
sss
pat
polyvar
abbrev
Polymorphic
variant
abbreviation
patterns
If
the
type
a
b
ldots
typeconstr
tag
name
1
typexpr
1
ldots
tag
name
n
typexpr
n
is
defined
then
the
pattern
typeconstr
is
a
shorthand
for
the
following
or
pattern
tag
name
1
typexpr
1
ldots
tag
name
n
typexpr
n
It
matches
all
values
of
type
typeconstr
begin
caml
example
toplevel
type
a
rectangle
Square
of
a
Rectangle
of
a
a
type
a
shape
Circle
of
a
a
rectangle
let
try
rectangle
function
rectangle
as
r
Some
r
Circle
None
end
caml
example
subsubsection
sss
pat
tuple
Tuple
patterns
The
pattern
pattern
1
ldots
pattern
n
matches
n
tuples
whose
components
match
the
patterns
pattern
1
through
pattern
n
That
is
the
pattern
matches
the
tuple
values
v
1
ldots
v
n
such
that
pattern
i
matches
v
i
for
fromoneto
i
n
begin
caml
example
toplevel
let
vector
x0
y0
x1
y1
x1
x0
y1
y0
end
caml
example
subsubsection
sss
pat
record
Record
patterns
The
pattern
field
1
pattern
1
ldots
field
n
pattern
n
matches
records
that
define
at
least
the
fields
field
1
through
field
n
and
such
that
the
value
associated
to
field
i
matches
the
pattern
pattern
i
for
fromoneto
i
n
A
single
identifier
field
k
stands
for
field
k
field
k
and
a
single
qualified
identifier
module
path
field
k
stands
for
module
path
field
k
field
k
The
record
value
can
define
more
fields
than
field
1
ldots
field
n
the
values
associated
to
these
extra
fields
are
not
taken
into
account
for
matching
Optionally
a
record
pattern
can
be
terminated
by
to
convey
the
fact
that
not
all
fields
of
the
record
type
are
listed
in
the
record
pattern
and
that
it
is
intentional
Optional
type
constraints
can
be
added
field
by
field
with
field
1
typexpr
1
pattern
1
ldots
field
n
typexpr
n
pattern
n
to
force
the
type
of
field
k
to
be
compatible
with
typexpr
k
begin
caml
example
toplevel
let
bytes
allocated
Gc
minor
words
minor
Gc
major
words
major
Gc
promoted
words
prom
Sys
word
size
4
int
of
float
minor
major
prom
end
caml
example
subsubsection
sss
pat
array
Array
patterns
The
pattern
pattern
1
ldots
pattern
n
matches
arrays
of
length
n
such
that
the
i
th
array
element
matches
the
pattern
pattern
i
for
fromoneto
i
n
begin
caml
example
toplevel
let
matrix3
is
symmetric
function
b
c
d
f
g
h
b
d
c
g
f
h
failwith
matrix3
is
symmetric
not
a
3x3
matrix
end
caml
example
subsubsection
sss
pat
range
Range
patterns
The
pattern
c
d
is
a
shorthand
for
the
pattern
begin
center
c
c
1
c
2
ldots
c
n
d
end
center
where
nth
c
1
nth
c
2
ldots
nth
c
n
are
the
characters
that
occur
between
var
c
and
var
d
in
the
ASCII
character
set
For
instance
the
pattern
0
9
matches
all
characters
that
are
digits
begin
caml
example
toplevel
type
char
class
Uppercase
Lowercase
Digit
Other
let
classify
char
function
A
Z
Uppercase
a
z
Lowercase
0
9
Digit
Other
end
caml
example
subsubsection
sss
pat
lazy
Lazy
patterns
ikwd
lazy
texttt
lazy
Introduced
in
Objective
Caml
3
11
The
pattern
lazy
pattern
matches
a
value
var
v
of
type
Lazy
t
provided
pattern
matches
the
result
of
forcing
var
v
with
Lazy
force
A
successful
match
of
a
pattern
containing
lazy
sub
patterns
forces
the
corresponding
parts
of
the
value
being
matched
even
those
that
imply
no
test
such
as
lazy
value
name
or
lazy
Matching
a
value
with
a
pattern
matching
where
some
patterns
contain
lazy
sub
patterns
may
imply
forcing
parts
of
the
value
even
when
the
pattern
selected
in
the
end
has
no
lazy
sub
pattern
begin
caml
example
toplevel
let
force
opt
function
Some
lazy
n
n
None
0
end
caml
example
For
more
information
see
the
description
of
module
Lazy
in
the
standard
library
module
stdmoduleref
Lazy
index
Lazy
module
verb
Lazy
module
index
force
verb
force
subsubsection
sss
exception
match
Exception
patterns
Introduced
in
OCaml
4
02
A
new
form
of
exception
pattern
exception
pattern
is
allowed
only
as
a
toplevel
pattern
or
inside
a
toplevel
or
pattern
under
a
match
with
pattern
matching
other
occurrences
are
rejected
by
the
type
checker
Cases
with
such
a
toplevel
pattern
are
called
exception
cases
as
opposed
to
regular
value
cases
Exception
cases
are
applied
when
the
evaluation
of
the
matched
expression
raises
an
exception
The
exception
value
is
then
matched
against
all
the
exception
cases
and
re
raised
if
none
of
them
accept
the
exception
as
with
a
try
with
block
Since
the
bodies
of
all
exception
and
value
cases
are
outside
the
scope
of
the
exception
handler
they
are
all
considered
to
be
in
tail
position
if
the
match
with
block
itself
is
in
tail
position
in
the
current
function
any
function
call
in
tail
position
in
one
of
the
case
bodies
results
in
an
actual
tail
call
A
pattern
match
must
contain
at
least
one
value
case
It
is
an
error
if
all
cases
are
exceptions
because
there
would
be
no
code
to
handle
the
return
of
a
value
begin
caml
example
toplevel
let
find
opt
p
l
match
List
find
p
l
with
exception
Not
found
None
x
Some
x
end
caml
example
subsubsection
sss
pat
open
Local
opens
for
patterns
ikwd
open
texttt
open
Introduced
in
OCaml
4
04
For
patterns
local
opens
are
limited
to
the
module
path
pattern
construction
This
construction
locally
opens
the
module
referred
to
by
the
module
path
module
path
in
the
scope
of
the
pattern
pattern
When
the
body
of
a
local
open
pattern
is
delimited
by
or
the
parentheses
can
be
omitted
For
example
module
path
pattern
is
equivalent
to
module
path
pattern
and
module
path
pattern
is
equivalent
to
module
path
pattern
begin
caml
example
toplevel
let
bytes
allocated
Gc
minor
words
major
words
promoted
words
Sys
word
size
4
int
of
float
minor
words
major
words
promoted
words
end
caml
example
section
s
value
expr
Expressions
HEVEA
cutname
expr
html
ikwd
in
texttt
in
see
texttt
let
ikwd
and
texttt
and
ikwd
rec
texttt
rec
see
texttt
let
texttt
module
ikwd
let
texttt
let
ikwd
try
texttt
try
ikwd
function
texttt
function
ikwd
fun
texttt
fun
ikwd
with
texttt
with
ikwd
done
texttt
done
see
texttt
while
texttt
for
ikwd
do
texttt
do
see
texttt
while
texttt
for
ikwd
downto
texttt
downto
see
texttt
for
ikwd
to
texttt
to
see
texttt
for
ikwd
for
texttt
for
ikwd
else
texttt
else
see
texttt
if
ikwd
then
texttt
then
see
texttt
if
ikwd
if
texttt
if
ikwd
or
texttt
or
ikwd
match
texttt
match
ikwd
begin
texttt
begin
ikwd
end
texttt
end
ikwd
when
texttt
when
ikwd
new
texttt
new
ikwd
object
texttt
object
ikwd
lazy
texttt
lazy
begin
syntax
expr
value
path
constant
expr
begin
expr
end
expr
typexpr
expr
expr
constr
expr
tag
name
expr
expr
expr
expr
expr
expr
expr
field
typexpr
expr
field
typexpr
expr
expr
with
field
typexpr
expr
field
typexpr
expr
expr
argument
prefix
symbol
expr
expr
expr
expr
infix
op
expr
expr
field
expr
field
expr
expr
expr
expr
expr
expr
expr
expr
expr
expr
expr
if
expr
then
expr
else
expr
while
expr
do
expr
done
for
value
name
expr
to
downto
expr
do
expr
done
expr
expr
match
expr
with
pattern
matching
function
pattern
matching
fun
parameter
typexpr
expr
try
expr
with
pattern
matching
let
rec
let
binding
and
let
binding
in
expr
let
exception
constr
decl
in
expr
let
module
module
name
module
name
module
type
module
type
module
expr
in
expr
expr
typexpr
expr
typexpr
typexpr
assert
expr
lazy
expr
local
open
object
expr
BEGIN
LATEX
end
syntax
begin
syntax
END
LATEX
argument
expr
label
name
label
name
expr
label
name
label
name
expr
end
syntax
begin
syntax
pattern
matching
pattern
when
expr
expr
pattern
when
expr
expr
let
binding
pattern
expr
value
name
parameter
typexpr
typexpr
expr
value
name
poly
typexpr
expr
since
3
12
parameter
pattern
label
name
label
name
typexpr
label
name
pattern
label
name
label
name
typexpr
expr
label
name
pattern
label
name
pattern
typexpr
expr
local
open
let
open
module
path
in
expr
module
path
expr
module
path
expr
module
path
expr
module
path
expr
module
path
expr
object
expr
new
class
path
object
class
body
end
expr
method
name
inst
var
name
inst
var
name
expr
inst
var
name
expr
inst
var
name
expr
end
syntax
See
also
the
following
language
extensions
hyperref
s
first
class
modules
first
class
modules
hyperref
s
explicit
overriding
open
overriding
in
open
statements
hyperref
s
bigarray
access
syntax
for
Bigarray
access
hyperref
s
attributes
attributes
hyperref
s
extension
nodes
extension
nodes
hyperref
s
index
operators
extended
indexing
operators
hyperref
s
array
literals
type
directed
disambiguation
of
array
literals
and
hyperref
s
labeled
tuples
labeled
tuples
subsection
ss
precedence
and
associativity
Precedence
and
associativity
The
table
below
shows
the
relative
precedences
and
associativity
of
operators
and
non
closed
constructions
The
constructions
with
higher
precedence
come
first
For
infix
and
prefix
symbols
we
write
ldots
to
mean
any
symbol
starting
with
Note
that
this
table
is
duplicated
in
stdlib
ocaml
operators
mld
these
tables
should
be
kept
in
sync
with
the
one
below
ikwd
or
texttt
or
ikwd
if
texttt
if
ikwd
fun
texttt
fun
ikwd
function
texttt
function
ikwd
match
texttt
match
ikwd
try
texttt
try
ikwd
let
texttt
let
ikwd
mod
texttt
mod
ikwd
land
texttt
land
ikwd
lor
texttt
lor
ikwd
lxor
texttt
lxor
ikwd
lsl
texttt
lsl
ikwd
lsr
texttt
lsr
ikwd
asr
texttt
asr
begin
tableau
l
l
Construction
or
operator
Associativity
entree
prefix
symbol
entree
see
section
ref
s
bigarray
access
entree
ldots
left
entree
function
application
constructor
application
tag
application
assert
lazy
left
entree
prefix
entree
ldots
lsl
lsr
asr
right
entree
ldots
ldots
ldots
mod
land
lor
lxor
left
ident
entree
ldots
ldots
left
entree
right
entree
tt
char64
ldots
ldots
right
entree
ldots
ldots
ldots
ldots
ldots
ldots
left
entree
right
entree
or
right
entree
entree
right
entree
if
entree
right
entree
let
match
fun
function
try
end
tableau
It
is
simple
to
test
or
refresh
one
s
understanding
begin
caml
example
toplevel
3
3
mod
2
3
3
mod
2
3
3
mod
2
end
caml
example
subsection
ss
expr
basic
Basic
expressions
subsubsection
sss
expr
constants
Constants
An
expression
consisting
in
a
constant
evaluates
to
this
constant
For
example
texttt
3
14
or
texttt
subsubsection
sss
expr
var
Value
paths
An
expression
consisting
in
an
access
path
evaluates
to
the
value
bound
to
this
path
in
the
current
evaluation
environment
The
path
can
be
either
a
value
name
or
an
access
path
to
a
value
component
of
a
module
begin
caml
example
toplevel
Float
ArrayLabels
to
list
end
caml
example
subsubsection
sss
expr
parenthesized
Parenthesized
expressions
ikwd
begin
texttt
begin
ikwd
end
texttt
end
The
expressions
expr
and
begin
expr
end
have
the
same
value
as
expr
The
two
constructs
are
semantically
equivalent
but
it
is
good
style
to
use
begin
ldots
end
inside
control
structures
begin
alltt
if
ldots
then
begin
ldots
ldots
end
else
begin
ldots
ldots
end
end
alltt
and
ldots
for
the
other
grouping
situations
begin
caml
example
toplevel
let
x
1
2
3
let
y
1
2
3
end
caml
example
begin
caml
example
toplevel
let
f
a
b
if
a
b
then
print
endline
Equal
else
begin
print
string
Not
Equal
print
int
a
print
string
and
print
int
b
print
newline
end
end
caml
example
Parenthesized
expressions
can
contain
a
type
constraint
as
in
expr
typexpr
This
constraint
forces
the
type
of
expr
to
be
compatible
with
typexpr
Parenthesized
expressions
can
also
contain
coercions
expr
typexpr
typexpr
see
subsection
ref
ss
expr
coercions
below
subsubsection
sss
expr
functions
application
Function
application
Function
application
is
denoted
by
juxtaposition
of
possibly
labeled
expressions
The
expression
expr
argument
1
ldots
argument
n
evaluates
the
expression
expr
and
those
appearing
in
argument
1
to
argument
n
The
expression
expr
must
evaluate
to
a
functional
value
f
which
is
then
applied
to
the
values
of
argument
1
ldots
argument
n
The
order
in
which
the
expressions
expr
argument
1
ldots
argument
n
are
evaluated
is
not
specified
begin
caml
example
toplevel
List
fold
left
0
1
2
3
4
5
end
caml
example
Arguments
and
parameters
are
matched
according
to
their
respective
labels
Argument
order
is
irrelevant
except
among
arguments
with
the
same
label
or
no
label
begin
caml
example
toplevel
ListLabels
fold
left
f
init
1
2
3
4
5
6
7
8
9
end
caml
example
If
a
parameter
is
specified
as
optional
label
prefixed
by
in
the
type
of
expr
the
corresponding
argument
will
be
automatically
wrapped
with
the
constructor
Some
except
if
the
argument
itself
is
also
prefixed
by
in
which
case
it
is
passed
as
is
begin
caml
example
toplevel
let
fullname
title
first
second
match
title
with
Some
t
t
first
second
None
first
second
let
name
fullname
title
Mrs
Jane
Fisher
let
address
title
first
second
town
fullname
title
first
second
n
town
end
caml
example
If
a
non
labeled
argument
is
passed
and
its
corresponding
parameter
is
preceded
by
one
or
several
optional
parameters
then
these
parameters
are
em
defaulted
em
i
e
the
value
None
will
be
passed
for
them
All
other
missing
parameters
without
corresponding
argument
both
optional
and
non
optional
will
be
kept
and
the
result
of
the
function
will
still
be
a
function
of
these
missing
parameters
to
the
body
of
f
begin
caml
example
toplevel
let
fullname
title
first
second
match
title
with
Some
t
t
first
second
None
first
second
let
name
fullname
Jane
Fisher
end
caml
example
In
all
cases
but
exact
match
of
order
and
labels
without
optional
parameters
the
function
type
should
be
known
at
the
application
point
This
can
be
ensured
by
adding
a
type
constraint
Principality
of
the
derivation
can
be
checked
in
the
principal
mode
As
a
special
case
OCaml
supports
labels
omitted
full
applications
if
the
function
has
a
known
arity
all
the
arguments
are
unlabeled
and
their
number
matches
the
number
of
non
optional
parameters
then
labels
are
ignored
and
non
optional
parameters
are
matched
in
their
definition
order
Optional
arguments
are
defaulted
This
omission
of
labels
is
discouraged
and
results
in
a
warning
see
ref
ss
warn6
subsubsection
sss
expr
function
definition
Function
definition
Two
syntactic
forms
are
provided
to
define
functions
The
first
form
is
introduced
by
the
keyword
function
ikwd
function
texttt
function
begin
array
rlll
token
function
textsl
pattern
1
token
textsl
expr
1
token
ldots
token
textsl
pattern
n
token
textsl
expr
n
end
array
This
expression
evaluates
to
a
functional
value
with
one
argument
When
this
function
is
applied
to
a
value
var
v
this
value
is
matched
against
each
pattern
pattern
1
to
pattern
n
If
one
of
these
matchings
succeeds
that
is
if
the
value
var
v
matches
the
pattern
pattern
i
for
some
var
i
then
the
expression
expr
i
associated
to
the
selected
pattern
is
evaluated
and
its
value
becomes
the
value
of
the
function
application
The
evaluation
of
expr
i
takes
place
in
an
environment
enriched
by
the
bindings
performed
during
the
matching
If
several
patterns
match
the
argument
var
v
the
one
that
occurs
first
in
the
function
definition
is
selected
If
none
of
the
patterns
matches
the
argument
the
exception
Match
failure
is
raised
index
Matchfailure
verb
Match
failure
begin
caml
example
toplevel
function
0
0
both
zero
0
first
only
zero
0
second
only
zero
neither
zero
7
0
end
caml
example
The
other
form
of
function
definition
is
introduced
by
the
keyword
fun
ikwd
fun
texttt
fun
begin
center
fun
parameter
1
ldots
parameter
n
expr
end
center
This
expression
is
equivalent
to
begin
center
fun
parameter
1
ldots
fun
parameter
n
expr
end
center
begin
caml
example
toplevel
let
f
fun
a
fun
b
fun
c
a
b
c
let
g
fun
a
b
c
a
b
c
end
caml
example
An
optional
type
constraint
typexpr
can
be
added
before
to
enforce
the
type
of
the
result
to
be
compatible
with
the
constraint
typexpr
begin
center
fun
parameter
1
ldots
parameter
n
typexpr
expr
end
center
is
equivalent
to
begin
center
fun
parameter
1
ldots
fun
parameter
n
expr
typexpr
end
center
Beware
of
the
small
syntactic
difference
between
a
type
constraint
on
the
last
parameter
begin
center
fun
parameter
1
ldots
parameter
n
typexpr
expr
end
center
and
one
on
the
result
begin
center
fun
parameter
1
ldots
parameter
n
typexpr
expr
end
center
begin
caml
example
toplevel
let
eq
fun
a
int
b
int
a
b
let
eq2
fun
a
b
bool
a
b
let
eq3
fun
a
int
b
int
bool
a
b
end
caml
example
The
parameter
patterns
lab
and
lab
typ
are
shorthands
for
respectively
lab
lab
and
lab
lab
typ
and
similarly
for
their
optional
counterparts
begin
caml
example
toplevel
let
bool
map
cmp
cmp
int
int
bool
l
List
map
cmp
l
let
bool
map
cmp
int
int
bool
l
List
map
cmp
l
end
caml
example
A
function
of
the
form
fun
lab
pattern
expr
0
expr
is
equivalent
to
begin
center
fun
lab
ident
let
pattern
match
ident
with
Some
ident
ident
None
expr
0
in
expr
end
center
where
ident
is
a
fresh
variable
except
that
it
is
unspecified
when
expr
0
is
evaluated
begin
caml
example
toplevel
let
open
file
for
input
binary
filename
match
binary
with
Some
true
open
in
bin
filename
Some
false
None
open
in
filename
let
open
file
for
input
binary
false
filename
if
binary
then
open
in
bin
filename
else
open
in
filename
end
caml
example
After
these
two
transformations
expressions
are
of
the
form
begin
center
fun
label
1
pattern
1
ldots
fun
label
n
pattern
n
expr
end
center
If
we
ignore
labels
which
will
only
be
meaningful
at
function
application
this
is
equivalent
to
begin
center
function
pattern
1
ldots
function
pattern
n
expr
end
center
That
is
the
fun
expression
above
evaluates
to
a
curried
function
with
var
n
arguments
after
applying
this
function
n
times
to
the
values
v
1
ldots
v
n
the
values
will
be
matched
in
parallel
against
the
patterns
pattern
1
ldots
pattern
n
If
the
matching
succeeds
the
function
returns
the
value
of
expr
in
an
environment
enriched
by
the
bindings
performed
during
the
matchings
If
the
matching
fails
the
exception
Match
failure
is
raised
subsubsection
sss
guards
in
pattern
matchings
Guards
in
pattern
matchings
ikwd
when
texttt
when
The
cases
of
a
pattern
matching
in
the
function
match
and
try
constructs
can
include
guard
expressions
which
are
arbitrary
boolean
expressions
that
must
evaluate
to
true
for
the
match
case
to
be
selected
Guards
occur
just
before
the
token
and
are
introduced
by
the
when
keyword
begin
array
rlll
token
function
nt
pattern
1
token
when
nt
cond
1
token
nt
expr
1
token
ldots
token
nt
pattern
n
token
when
nt
cond
n
token
nt
expr
n
end
array
Matching
proceeds
as
described
before
except
that
if
the
value
matches
some
pattern
pattern
i
which
has
a
guard
cond
i
then
the
expression
cond
i
is
evaluated
in
an
environment
enriched
by
the
bindings
performed
during
matching
If
cond
i
evaluates
to
true
then
expr
i
is
evaluated
and
its
value
returned
as
the
result
of
the
matching
as
usual
But
if
cond
i
evaluates
to
false
the
matching
is
resumed
against
the
patterns
following
pattern
i
begin
caml
example
toplevel
let
rec
repeat
f
function
0
n
when
n
0
f
repeat
f
n
1
raise
Invalid
argument
repeat
end
caml
example
subsubsection
sss
expr
localdef
Local
definitions
ikwd
let
texttt
let
The
let
and
let
rec
constructs
bind
value
names
locally
The
construct
begin
center
let
pattern
1
expr
1
and
ldots
and
pattern
n
expr
n
in
expr
end
center
evaluates
expr
1
ldots
expr
n
in
some
unspecified
order
and
matches
their
values
against
the
patterns
pattern
1
ldots
pattern
n
If
the
matchings
succeed
expr
is
evaluated
in
the
environment
enriched
by
the
bindings
performed
during
matching
and
the
value
of
expr
is
returned
as
the
value
of
the
whole
let
expression
If
one
of
the
matchings
fails
the
exception
Match
failure
is
raised
index
Matchfailure
verb
Match
failure
begin
caml
example
toplevel
let
v
let
x
1
in
x
x
x
let
v
let
a
b
1
2
in
a
b
let
v
let
a
1
and
b
2
in
a
b
end
caml
example
An
alternate
syntax
is
provided
to
bind
variables
to
functional
values
instead
of
writing
begin
center
let
ident
fun
parameter
1
ldots
parameter
m
expr
end
center
in
a
let
expression
one
may
instead
write
begin
center
let
ident
parameter
1
ldots
parameter
m
expr
end
center
begin
caml
example
toplevel
let
f
fun
x
fun
y
fun
z
x
y
z
let
f
fun
x
y
z
x
y
z
let
f
x
y
z
x
y
z
end
caml
example
noindent
Recursive
definitions
of
names
are
introduced
by
let
rec
begin
center
let
rec
pattern
1
expr
1
and
ldots
and
pattern
n
expr
n
in
expr
end
center
The
only
difference
with
the
let
construct
described
above
is
that
the
bindings
of
names
to
values
performed
by
the
pattern
matching
are
considered
already
performed
when
the
expressions
expr
1
to
expr
n
are
evaluated
That
is
the
expressions
expr
1
to
expr
n
can
reference
identifiers
that
are
bound
by
one
of
the
patterns
pattern
1
ldots
pattern
n
and
expect
them
to
have
the
same
value
as
in
expr
the
body
of
the
let
rec
construct
begin
caml
example
toplevel
let
rec
even
function
0
true
n
odd
n
1
and
odd
function
0
false
n
even
n
1
in
even
1000
end
caml
example
The
recursive
definition
is
guaranteed
to
behave
as
described
above
if
the
expressions
expr
1
to
expr
n
are
function
definitions
fun
ldots
or
function
ldots
and
the
patterns
pattern
1
ldots
pattern
n
are
just
value
names
as
in
begin
center
let
rec
name
1
fun
ldots
and
ldots
and
name
n
fun
ldots
in
expr
end
center
This
defines
name
1
ldots
name
n
as
mutually
recursive
functions
local
to
expr
The
behavior
of
other
forms
of
let
rec
definitions
is
implementation
dependent
The
current
implementation
also
supports
a
certain
class
of
recursive
definitions
of
non
functional
values
as
explained
in
section
ref
s
letrecvalues
subsubsection
sss
expr
let
exception
Local
exceptions
Introduced
in
OCaml
4
04
It
is
possible
to
define
local
exceptions
in
expressions
let
exception
constr
decl
in
expr
begin
caml
example
toplevel
let
map
empty
on
negative
f
l
let
exception
Negative
in
let
aux
x
if
x
0
then
raise
Negative
else
f
x
in
try
List
map
aux
l
with
Negative
end
caml
example
The
syntactic
scope
of
the
exception
constructor
is
the
inner
expression
but
nothing
prevents
exception
values
created
with
this
constructor
from
escaping
this
scope
Two
executions
of
the
definition
above
result
in
two
incompatible
exception
constructors
as
for
any
exception
definition
For
instance
begin
caml
example
toplevel
let
gen
let
exception
A
in
A
let
assert
gen
gen
end
caml
example
subsubsection
sss
expr
explicit
polytype
Explicit
polymorphic
type
annotations
Introduced
in
OCaml
3
12
Polymorphic
type
annotations
in
let
definitions
behave
in
a
way
similar
to
polymorphic
methods
begin
center
let
pattern
1
typ
1
ldots
typ
n
typexpr
expr
end
center
These
annotations
explicitly
require
the
defined
value
to
be
polymorphic
and
allow
one
to
use
this
polymorphism
in
recursive
occurrences
when
using
let
rec
Note
however
that
this
is
a
normal
polymorphic
type
unifiable
with
any
instance
of
itself
subsection
ss
expr
control
Control
structures
subsubsection
sss
expr
sequence
Sequence
The
expression
expr
1
expr
2
evaluates
expr
1
first
then
expr
2
and
returns
the
value
of
expr
2
begin
caml
example
toplevel
let
print
pair
a
b
print
string
print
string
string
of
int
a
print
string
print
string
string
of
int
b
print
endline
end
caml
example
subsubsection
sss
expr
conditional
Conditional
ikwd
if
texttt
if
The
expression
if
expr
1
then
expr
2
else
expr
3
evaluates
to
the
value
of
expr
2
if
expr
1
evaluates
to
the
boolean
true
and
to
the
value
of
expr
3
if
expr
1
evaluates
to
the
boolean
false
begin
caml
example
toplevel
let
rec
factorial
x
if
x
1
then
1
else
x
factorial
x
1
end
caml
example
The
else
expr
3
part
can
be
omitted
in
which
case
it
defaults
to
else
begin
caml
example
toplevel
let
debug
ref
false
let
log
msg
if
debug
then
prerr
endline
msg
end
caml
example
subsubsection
sss
expr
case
Case
expression
ikwd
match
texttt
match
The
expression
begin
array
rlll
token
match
textsl
expr
token
with
textsl
pattern
1
token
textsl
expr
1
token
ldots
token
textsl
pattern
n
token
textsl
expr
n
end
array
matches
the
value
of
expr
against
the
patterns
pattern
1
to
pattern
n
If
the
matching
against
pattern
i
succeeds
the
associated
expression
expr
i
is
evaluated
and
its
value
becomes
the
value
of
the
whole
match
expression
The
evaluation
of
expr
i
takes
place
in
an
environment
enriched
by
the
bindings
performed
during
matching
If
several
patterns
match
the
value
of
expr
the
one
that
occurs
first
in
the
match
expression
is
selected
begin
caml
example
toplevel
let
rec
sum
l
match
l
with
0
h
t
h
sum
t
end
caml
example
If
none
of
the
patterns
match
the
value
of
expr
the
exception
Match
failure
is
raised
index
Matchfailure
verb
Match
failure
begin
caml
example
toplevel
let
unoption
o
match
o
with
Some
x
x
expect
warning
8
let
l
List
map
unoption
Some
1
Some
10
None
Some
2
end
caml
example
subsubsection
sss
expr
boolean
operators
Boolean
operators
The
expression
expr
1
expr
2
evaluates
to
true
if
both
expr
1
and
expr
2
evaluate
to
true
otherwise
it
evaluates
to
false
The
first
component
expr
1
is
evaluated
first
The
second
component
expr
2
is
not
evaluated
if
the
first
component
evaluates
to
false
Hence
the
expression
expr
1
expr
2
behaves
exactly
as
begin
center
if
expr
1
then
expr
2
else
false
end
center
The
expression
expr
1
expr
2
evaluates
to
true
if
one
of
the
expressions
expr
1
and
expr
2
evaluates
to
true
otherwise
it
evaluates
to
false
The
first
component
expr
1
is
evaluated
first
The
second
component
expr
2
is
not
evaluated
if
the
first
component
evaluates
to
true
Hence
the
expression
expr
1
expr
2
behaves
exactly
as
begin
center
if
expr
1
then
true
else
expr
2
end
center
ikwd
or
texttt
or
The
boolean
operators
and
or
are
deprecated
synonyms
for
respectively
and
begin
caml
example
toplevel
let
xor
a
b
a
b
not
a
b
end
caml
example
subsubsection
sss
expr
loops
Loops
ikwd
while
texttt
while
The
expression
while
expr
1
do
expr
2
done
repeatedly
evaluates
expr
2
while
expr
1
evaluates
to
true
The
loop
condition
expr
1
is
evaluated
and
tested
at
the
beginning
of
each
iteration
The
whole
while
ldots
done
expression
evaluates
to
the
unit
value
begin
caml
example
toplevel
let
chars
of
string
s
let
i
ref
0
in
let
chars
ref
in
while
i
String
length
s
do
chars
s
i
chars
i
i
1
done
List
rev
chars
end
caml
example
As
a
special
case
while
true
do
expr
done
is
given
a
polymorphic
type
allowing
it
to
be
used
in
place
of
any
expression
for
example
as
a
branch
of
any
pattern
matching
ikwd
for
texttt
for
The
expression
for
name
expr
1
to
expr
2
do
expr
3
done
first
evaluates
the
expressions
expr
1
and
expr
2
the
boundaries
into
integer
values
var
n
and
var
p
Then
the
loop
body
expr
3
is
repeatedly
evaluated
in
an
environment
where
name
is
successively
bound
to
the
values
n
n
1
ldots
p
1
p
The
loop
body
is
never
evaluated
if
n
p
begin
caml
example
toplevel
let
chars
of
string
s
let
l
ref
in
for
p
0
to
String
length
s
1
do
l
s
p
l
done
List
rev
l
end
caml
example
The
expression
for
name
expr
1
downto
expr
2
do
expr
3
done
evaluates
similarly
except
that
name
is
successively
bound
to
the
values
n
n
1
ldots
p
1
p
The
loop
body
is
never
evaluated
if
n
p
begin
caml
example
toplevel
let
chars
of
string
s
let
l
ref
in
for
p
String
length
s
1
downto
0
do
l
s
p
l
done
l
end
caml
example
In
both
cases
the
whole
for
expression
evaluates
to
the
unit
value
subsubsection
sss
expr
exception
handling
Exception
handling
ikwd
try
texttt
try
The
expression
begin
array
rlll
token
try
textsl
expr
token
with
textsl
pattern
1
token
textsl
expr
1
token
ldots
token
textsl
pattern
n
token
textsl
expr
n
end
array
evaluates
the
expression
expr
and
returns
its
value
if
the
evaluation
of
expr
does
not
raise
any
exception
If
the
evaluation
of
expr
raises
an
exception
the
exception
value
is
matched
against
the
patterns
pattern
1
to
pattern
n
If
the
matching
against
pattern
i
succeeds
the
associated
expression
expr
i
is
evaluated
and
its
value
becomes
the
value
of
the
whole
try
expression
The
evaluation
of
expr
i
takes
place
in
an
environment
enriched
by
the
bindings
performed
during
matching
If
several
patterns
match
the
value
of
expr
the
one
that
occurs
first
in
the
try
expression
is
selected
If
none
of
the
patterns
matches
the
value
of
expr
the
exception
value
is
raised
again
thereby
transparently
passing
through
the
try
construct
begin
caml
example
toplevel
let
find
opt
p
l
try
Some
List
find
p
l
with
Not
found
None
end
caml
example
subsection
ss
expr
ops
on
data
Operations
on
data
structures
subsubsection
sss
expr
products
Products
The
expression
expr
1
ldots
expr
n
evaluates
to
the
var
n
tuple
of
the
values
of
expressions
expr
1
to
expr
n
The
evaluation
order
of
the
subexpressions
is
not
specified
begin
caml
example
toplevel
1
2
3
1
2
3
1
2
3
end
caml
example
subsubsection
sss
expr
variants
Variants
The
expression
constr
expr
evaluates
to
the
unary
variant
value
whose
constructor
is
constr
and
whose
argument
is
the
value
of
expr
Similarly
the
expression
constr
expr
1
ldots
expr
n
evaluates
to
the
n
ary
variant
value
whose
constructor
is
constr
and
whose
arguments
are
the
values
of
expr
1
ldots
expr
n
The
expression
constr
expr
1
ldots
expr
n
evaluates
to
the
variant
value
whose
constructor
is
constr
and
whose
arguments
are
the
values
of
expr
1
ldots
expr
n
begin
caml
example
toplevel
type
t
Var
of
string
Not
of
t
And
of
t
t
Or
of
t
t
let
test
And
Var
x
Not
Or
Var
y
Var
z
end
caml
example
For
lists
some
syntactic
sugar
is
provided
The
expression
expr
1
expr
2
stands
for
the
constructor
applied
to
the
arguments
expr
1
expr
2
and
therefore
evaluates
to
the
list
whose
head
is
the
value
of
expr
1
and
whose
tail
is
the
value
of
expr
2
The
expression
expr
1
ldots
expr
n
is
equivalent
to
expr
1
ldots
expr
n
and
therefore
evaluates
to
the
list
whose
elements
are
the
values
of
expr
1
to
expr
n
begin
caml
example
toplevel
0
1
2
3
0
1
2
3
end
caml
example
subsubsection
sss
expr
polyvars
Polymorphic
variants
The
expression
tag
name
expr
evaluates
to
the
polymorphic
variant
value
whose
tag
is
tag
name
and
whose
argument
is
the
value
of
expr
begin
caml
example
toplevel
let
with
counter
x
V
x
ref
0
end
caml
example
subsubsection
sss
expr
records
Records
The
expression
field
1
expr
1
ldots
field
n
expr
n
evaluates
to
the
record
value
field
1
v
1
ldots
field
n
v
n
where
v
i
is
the
value
of
expr
i
for
fromoneto
i
n
A
single
identifier
field
k
stands
for
field
k
field
k
and
a
qualified
identifier
module
path
field
k
stands
for
module
path
field
k
field
k
The
fields
field
1
to
field
n
must
all
belong
to
the
same
record
type
each
field
of
this
record
type
must
appear
exactly
once
in
the
record
expression
though
they
can
appear
in
any
order
The
order
in
which
expr
1
to
expr
n
are
evaluated
is
not
specified
Optional
type
constraints
can
be
added
after
each
field
field
1
typexpr
1
expr
1
ldots
field
n
typexpr
n
expr
n
to
force
the
type
of
field
k
to
be
compatible
with
typexpr
k
begin
caml
example
toplevel
type
t
house
no
int
street
string
town
string
postcode
string
let
address
x
Printf
sprintf
The
occupier
n
i
s
n
s
n
s
x
house
no
x
street
x
town
x
postcode
end
caml
example
The
expression
expr
with
field
1
expr
1
ldots
field
n
expr
n
builds
a
fresh
record
with
fields
field
1
ldots
field
n
equal
to
expr
1
ldots
expr
n
and
all
other
fields
having
the
same
value
as
in
the
record
expr
In
other
terms
it
returns
a
shallow
copy
of
the
record
expr
except
for
the
fields
field
1
ldots
field
n
which
are
initialized
to
expr
1
ldots
expr
n
As
previously
single
identifier
field
k
stands
for
field
k
field
k
a
qualified
identifier
module
path
field
k
stands
for
module
path
field
k
field
k
and
it
is
possible
to
add
an
optional
type
constraint
on
each
field
being
updated
with
expr
with
field
1
typexpr
1
expr
1
ldots
field
n
typexpr
n
expr
n
begin
caml
example
toplevel
type
t
house
no
int
street
string
town
string
postcode
string
let
uppercase
town
address
address
with
town
String
uppercase
ascii
address
town
end
caml
example
The
expression
expr
1
field
evaluates
expr
1
to
a
record
value
and
returns
the
value
associated
to
field
in
this
record
value
The
expression
expr
1
field
expr
2
evaluates
expr
1
to
a
record
value
which
is
then
modified
in
place
by
replacing
the
value
associated
to
field
in
this
record
by
the
value
of
expr
2
This
operation
is
permitted
only
if
field
has
been
declared
mutable
in
the
definition
of
the
record
type
The
whole
expression
expr
1
field
expr
2
evaluates
to
the
unit
value
begin
caml
example
toplevel
type
t
mutable
upper
int
mutable
lower
int
mutable
other
int
let
stats
upper
0
lower
0
other
0
let
collect
String
iter
function
A
Z
stats
upper
stats
upper
1
a
z
stats
lower
stats
lower
1
stats
other
stats
other
1
end
caml
example
subsubsection
sss
expr
arrays
Arrays
The
expression
expr
1
ldots
expr
n
evaluates
to
a
var
n
element
array
whose
elements
are
initialized
with
the
values
of
expr
1
to
expr
n
respectively
The
order
in
which
these
expressions
are
evaluated
is
unspecified
The
expression
expr
1
expr
2
returns
the
value
of
element
number
expr
2
in
the
array
denoted
by
expr
1
The
first
element
has
number
0
the
last
element
has
number
n
1
where
var
n
is
the
size
of
the
array
The
exception
Invalid
argument
is
raised
if
the
access
is
out
of
bounds
The
expression
expr
1
expr
2
expr
3
modifies
in
place
the
array
denoted
by
expr
1
replacing
element
number
expr
2
by
the
value
of
expr
3
The
exception
Invalid
argument
is
raised
if
the
access
is
out
of
bounds
The
value
of
the
whole
expression
is
begin
caml
example
toplevel
let
scale
arr
n
for
x
0
to
Array
length
arr
1
do
arr
x
arr
x
n
done
let
x
1
10
100
let
scale
x
2
end
caml
example
subsubsection
sss
expr
strings
Strings
The
expression
expr
1
expr
2
returns
the
value
of
character
number
expr
2
in
the
string
denoted
by
expr
1
The
first
character
has
number
0
the
last
character
has
number
n
1
where
var
n
is
the
length
of
the
string
The
exception
Invalid
argument
is
raised
if
the
access
is
out
of
bounds
begin
caml
example
toplevel
let
iter
f
s
for
x
0
to
String
length
s
1
do
f
s
x
done
end
caml
example
The
expression
expr
1
expr
2
expr
3
modifies
in
place
the
string
denoted
by
expr
1
replacing
character
number
expr
2
by
the
value
of
expr
3
The
exception
Invalid
argument
is
raised
if
the
access
is
out
of
bounds
The
value
of
the
whole
expression
is
bf
Note
this
possibility
is
offered
only
for
backward
compatibility
with
older
versions
of
OCaml
and
will
be
removed
in
a
future
version
New
code
should
use
byte
sequences
and
the
Bytes
set
function
subsection
ss
expr
operators
Operators
ikwd
mod
texttt
mod
ikwd
land
texttt
land
ikwd
lor
texttt
lor
ikwd
lxor
texttt
lxor
ikwd
lsl
texttt
lsl
ikwd
lsr
texttt
lsr
ikwd
asr
texttt
asr
Symbols
from
the
class
infix
symbol
as
well
as
the
keywords
or
mod
land
lor
lxor
lsl
lsr
and
asr
can
appear
in
infix
position
between
two
expressions
Symbols
from
the
class
prefix
symbol
as
well
as
the
keywords
and
can
appear
in
prefix
position
in
front
of
an
expression
begin
caml
example
toplevel
end
caml
example
Infix
and
prefix
symbols
do
not
have
a
fixed
meaning
they
are
simply
interpreted
as
applications
of
functions
bound
to
the
names
corresponding
to
the
symbols
The
expression
prefix
symbol
expr
is
interpreted
as
the
application
prefix
symbol
expr
Similarly
the
expression
expr
1
infix
symbol
expr
2
is
interpreted
as
the
application
infix
symbol
expr
1
expr
2
The
table
below
lists
the
symbols
defined
in
the
initial
environment
and
their
initial
meaning
See
the
description
of
the
core
library
module
Stdlib
in
chapter
ref
c
corelib
for
more
details
Their
meaning
may
be
changed
at
any
time
using
let
infix
op
name
1
name
2
ldots
begin
caml
example
toplevel
let
Int64
add
sub
mul
div
end
caml
example
Note
the
operators
and
are
handled
specially
and
it
is
not
advisable
to
change
their
meaning
The
keywords
and
can
appear
both
as
infix
and
prefix
operators
When
they
appear
as
prefix
operators
they
are
interpreted
respectively
as
the
functions
and
Conversely
a
regular
function
identifier
can
also
be
used
as
an
infix
operator
by
enclosing
it
in
backquotes
expr
1
ident
expr
2
is
interpreted
as
the
application
ident
expr
1
expr
2
ikwd
mod
texttt
mod
ikwd
land
texttt
land
ikwd
lor
texttt
lor
ikwd
lxor
texttt
lxor
ikwd
lsl
texttt
lsl
ikwd
lsr
texttt
lsr
ikwd
asr
texttt
asr
begin
tableau
l
p
12cm
Operator
Initial
meaning
entree
Integer
addition
entree
infix
Integer
subtraction
entree
prefix
Integer
negation
entree
Integer
multiplication
entree
Integer
division
Raise
Division
by
zero
if
second
argument
is
zero
entree
mod
Integer
modulus
Raise
Division
by
zero
if
second
argument
is
zero
entree
land
Bitwise
logical
and
on
integers
entree
lor
Bitwise
logical
or
on
integers
entree
lxor
Bitwise
logical
exclusive
or
on
integers
entree
lsl
Bitwise
logical
shift
left
on
integers
entree
lsr
Bitwise
logical
shift
right
on
integers
entree
asr
Bitwise
arithmetic
shift
right
on
integers
entree
Floating
point
addition
entree
infix
Floating
point
subtraction
entree
prefix
Floating
point
negation
entree
Floating
point
multiplication
entree
Floating
point
division
entree
Floating
point
exponentiation
entree
tt
char64
List
concatenation
entree
String
concatenation
entree
Dereferencing
return
the
current
contents
of
a
reference
entree
Reference
assignment
update
the
reference
given
as
first
argument
with
the
value
of
the
second
argument
entree
Structural
equality
test
entree
Structural
inequality
test
entree
Physical
equality
test
entree
Physical
inequality
test
entree
Test
less
than
entree
Test
less
than
or
equal
entree
Test
greater
than
entree
Test
greater
than
or
equal
entree
Boolean
conjunction
entree
or
Boolean
disjunction
end
tableau
subsection
ss
expr
obj
Objects
label
s
objects
subsubsection
sss
expr
obj
creation
Object
creation
ikwd
new
texttt
new
When
class
path
evaluates
to
a
class
body
new
class
path
evaluates
to
a
new
object
containing
the
instance
variables
and
methods
of
this
class
begin
caml
example
toplevel
class
of
list
lst
int
list
object
val
mutable
l
lst
method
next
match
l
with
raise
Failure
empty
list
h
t
l
t
h
end
let
a
new
of
list
1
1
2
3
5
8
13
let
b
new
of
list
end
caml
example
When
class
path
evaluates
to
a
class
function
new
class
path
evaluates
to
a
function
expecting
the
same
number
of
arguments
and
returning
a
new
object
of
this
class
subsubsection
sss
expr
obj
immediate
Immediate
object
creation
ikwd
object
texttt
object
Creating
directly
an
object
through
the
object
class
body
end
construct
is
operationally
equivalent
to
defining
locally
a
class
class
name
object
class
body
end
see
sections
ref
sss
class
body
and
following
for
the
syntax
of
class
body
and
immediately
creating
a
single
object
from
it
by
new
class
name
begin
caml
example
toplevel
let
o
object
val
secret
99
val
password
unlock
method
get
guess
if
guess
password
then
None
else
Some
secret
end
end
caml
example
The
typing
of
immediate
objects
is
slightly
different
from
explicitly
defining
a
class
in
two
respects
First
the
inferred
object
type
may
contain
free
type
variables
Second
since
the
class
body
of
an
immediate
object
will
never
be
extended
its
self
type
can
be
unified
with
a
closed
object
type
subsubsection
sss
expr
method
Method
invocation
The
expression
expr
method
name
invokes
the
method
method
name
of
the
object
denoted
by
expr
begin
caml
example
toplevel
class
of
list
lst
int
list
object
val
mutable
l
lst
method
next
match
l
with
raise
Failure
empty
list
h
t
l
t
h
end
let
a
new
of
list
1
1
2
3
5
8
13
let
third
ignore
a
next
ignore
a
next
a
next
end
caml
example
If
method
name
is
a
polymorphic
method
its
type
should
be
known
at
the
invocation
site
This
is
true
for
instance
if
expr
is
the
name
of
a
fresh
object
let
ident
new
class
path
dots
or
if
there
is
a
type
constraint
Principality
of
the
derivation
can
be
checked
in
the
principal
mode
subsubsection
sss
expr
obj
variables
Accessing
and
modifying
instance
variables
The
instance
variables
of
a
class
are
visible
only
in
the
body
of
the
methods
defined
in
the
same
class
or
a
class
that
inherits
from
the
class
defining
the
instance
variables
The
expression
inst
var
name
evaluates
to
the
value
of
the
given
instance
variable
The
expression
inst
var
name
expr
assigns
the
value
of
expr
to
the
instance
variable
inst
var
name
which
must
be
mutable
The
whole
expression
inst
var
name
expr
evaluates
to
begin
caml
example
toplevel
class
of
list
lst
int
list
object
val
mutable
l
lst
method
next
match
l
with
access
instance
variable
raise
Failure
empty
list
h
t
l
t
h
modify
instance
variable
end
end
caml
example
subsubsection
sss
expr
obj
duplication
Object
duplication
An
object
can
be
duplicated
using
the
library
function
Oo
copy
see
module
stdmoduleref
Oo
Inside
a
method
the
expression
inst
var
name
expr
inst
var
name
expr
returns
a
copy
of
self
with
the
given
instance
variables
replaced
by
the
values
of
the
associated
expressions
A
single
instance
variable
name
id
stands
for
id
id
Other
instance
variables
have
the
same
value
in
the
returned
object
as
in
self
begin
caml
example
toplevel
let
o
object
val
secret
99
val
password
unlock
method
get
guess
if
guess
password
then
None
else
Some
secret
method
with
new
secret
s
secret
s
end
end
caml
example
subsection
ss
expr
coercions
Coercions
Expressions
whose
type
contains
object
or
polymorphic
variant
types
can
be
explicitly
coerced
weakened
to
a
supertype
The
expression
expr
typexpr
coerces
the
expression
expr
to
type
typexpr
The
expression
expr
typexpr
1
typexpr
2
coerces
the
expression
expr
from
type
typexpr
1
to
type
typexpr
2
The
former
operator
will
sometimes
fail
to
coerce
an
expression
expr
from
a
type
typ
1
to
a
type
typ
2
even
if
type
typ
1
is
a
subtype
of
type
typ
2
in
the
current
implementation
it
only
expands
two
levels
of
type
abbreviations
containing
objects
and
or
polymorphic
variants
keeping
only
recursion
when
it
is
explicit
in
the
class
type
for
objects
As
an
exception
to
the
above
algorithm
if
both
the
inferred
type
of
expr
and
typ
are
ground
em
i
e
do
not
contain
type
variables
the
former
operator
behaves
as
the
latter
one
taking
the
inferred
type
of
expr
as
typ
1
In
case
of
failure
with
the
former
operator
the
latter
one
should
be
used
It
is
only
possible
to
coerce
an
expression
expr
from
type
typ
1
to
type
typ
2
if
the
type
of
expr
is
an
instance
of
typ
1
like
for
a
type
annotation
and
typ
1
is
a
subtype
of
typ
2
The
type
of
the
coerced
expression
is
an
instance
of
typ
2
If
the
types
contain
variables
they
may
be
instantiated
by
the
subtyping
algorithm
but
this
is
only
done
after
determining
whether
typ
1
is
a
potential
subtype
of
typ
2
This
means
that
typing
may
fail
during
this
latter
unification
step
even
if
some
instance
of
typ
1
is
a
subtype
of
some
instance
of
typ
2
In
the
following
paragraphs
we
describe
the
subtyping
relation
used
subsubsection
sss
expr
obj
types
Object
types
A
fixed
object
type
admits
as
subtype
any
object
type
that
includes
all
its
methods
The
types
of
the
methods
shall
be
subtypes
of
those
in
the
supertype
Namely
begin
center
met
1
typ
1
dots
met
n
typ
n
end
center
is
a
supertype
of
begin
center
met
1
typ
1
dots
met
n
typ
n
met
n
1
typ
n
1
dots
met
n
m
typ
n
m
end
center
which
may
contain
an
ellipsis
if
every
typ
i
is
a
supertype
of
the
corresponding
typ
i
A
monomorphic
method
type
can
be
a
supertype
of
a
polymorphic
method
type
Namely
if
typ
is
an
instance
of
typ
then
a
1
dots
a
n
typ
is
a
subtype
of
typ
Inside
a
class
definition
newly
defined
types
are
not
available
for
subtyping
as
the
type
abbreviations
are
not
yet
completely
defined
There
is
an
exception
for
coercing
self
to
the
exact
type
of
its
class
this
is
allowed
if
the
type
of
self
does
not
appear
in
a
contravariant
position
in
the
class
type
em
i
e
if
there
are
no
binary
methods
subsubsection
sss
expr
polyvar
types
Polymorphic
variant
types
A
polymorphic
variant
type
typ
is
a
subtype
of
another
polymorphic
variant
type
typ
if
the
upper
bound
of
typ
em
i
e
the
maximum
set
of
constructors
that
may
appear
in
an
instance
of
typ
is
included
in
the
lower
bound
of
typ
and
the
types
of
arguments
for
the
constructors
of
typ
are
subtypes
of
those
in
typ
Namely
begin
center
C
1
of
typ
1
dots
C
n
of
typ
n
end
center
which
may
be
a
shrinkable
type
is
a
subtype
of
begin
center
C
1
of
typ
1
dots
C
n
of
typ
n
C
n
1
of
typ
n
1
dots
C
n
m
of
typ
n
m
end
center
which
may
be
an
extensible
type
if
every
typ
i
is
a
subtype
of
typ
i
subsubsection
sss
expr
variance
Variance
Other
types
do
not
introduce
new
subtyping
but
they
may
propagate
the
subtyping
of
their
arguments
For
instance
typ
1
typ
2
is
a
subtype
of
typ
1
typ
2
when
typ
1
and
typ
2
are
respectively
subtypes
of
typ
1
and
typ
2
For
function
types
the
relation
is
more
subtle
typ
1
typ
2
is
a
subtype
of
typ
1
typ
2
if
typ
1
is
a
supertype
of
typ
1
and
typ
2
is
a
subtype
of
typ
2
For
this
reason
function
types
are
covariant
in
their
second
argument
like
tuples
but
contravariant
in
their
first
argument
Mutable
types
like
array
or
ref
are
neither
covariant
nor
contravariant
they
are
nonvariant
that
is
they
do
not
propagate
subtyping
For
user
defined
types
the
variance
is
automatically
inferred
a
parameter
is
covariant
if
it
has
only
covariant
occurrences
contravariant
if
it
has
only
contravariant
occurrences
variance
free
if
it
has
no
occurrences
and
nonvariant
otherwise
A
variance
free
parameter
may
change
freely
through
subtyping
it
does
not
have
to
be
a
subtype
or
a
supertype
For
abstract
and
private
types
the
variance
must
be
given
explicitly
see
section
ref
ss
typedefs
otherwise
the
default
is
nonvariant
This
is
also
the
case
for
constrained
arguments
in
type
definitions
subsection
ss
expr
other
Other
subsubsection
sss
expr
assertion
Assertion
checking
ikwd
assert
texttt
assert
OCaml
supports
the
assert
construct
to
check
debugging
assertions
The
expression
assert
expr
evaluates
the
expression
expr
and
returns
if
expr
evaluates
to
true
If
it
evaluates
to
false
the
exception
Assert
failure
is
raised
with
the
source
file
name
and
the
location
of
expr
as
arguments
Assertion
checking
can
be
turned
off
with
the
noassert
compiler
option
In
this
case
expr
is
not
evaluated
at
all
begin
caml
example
toplevel
let
f
a
b
c
assert
a
b
b
c
b
a
c
b
end
caml
example
As
a
special
case
assert
false
is
reduced
to
raise
Assert
failure
which
gives
it
a
polymorphic
type
This
means
that
it
can
be
used
in
place
of
any
expression
for
example
as
a
branch
of
any
pattern
matching
It
also
means
that
the
assert
false
assertions
cannot
be
turned
off
by
the
noassert
option
index
Assertfailure
verb
Assert
failure
begin
caml
example
toplevel
let
min
known
nonempty
function
assert
false
l
List
hd
List
sort
compare
l
end
caml
example
subsubsection
sss
expr
lazy
Lazy
expressions
ikwd
lazy
texttt
lazy
The
expression
lazy
expr
returns
a
value
var
v
of
type
Lazy
t
that
encapsulates
the
computation
of
expr
The
argument
expr
is
not
evaluated
at
this
point
in
the
program
Instead
its
evaluation
will
be
performed
the
first
time
the
function
Lazy
force
is
applied
to
the
value
var
v
returning
the
actual
value
of
expr
Subsequent
applications
of
Lazy
force
to
var
v
do
not
evaluate
expr
again
Applications
of
Lazy
force
may
be
implicit
through
pattern
matching
see
ref
sss
pat
lazy
begin
caml
example
toplevel
let
lazy
greeter
lazy
print
string
Hello
World
n
Lazy
force
lazy
greeter
end
caml
example
subsubsection
sss
expr
local
modules
Local
modules
ikwd
let
texttt
let
ikwd
module
texttt
module
The
expression
let
module
module
name
module
expr
in
expr
locally
binds
the
module
expression
module
expr
to
the
identifier
module
name
during
the
evaluation
of
the
expression
expr
It
then
returns
the
value
of
expr
For
example
begin
caml
example
toplevel
let
remove
duplicates
comparison
fun
string
list
let
module
StringSet
Set
Make
struct
type
t
string
let
compare
comparison
fun
end
in
StringSet
elements
List
fold
right
StringSet
add
string
list
StringSet
empty
end
caml
example
subsubsection
sss
local
opens
Local
opens
ikwd
let
texttt
let
ikwd
module
texttt
open
The
expressions
let
open
module
path
in
expr
and
module
path
expr
are
strictly
equivalent
These
constructions
locally
open
the
module
referred
to
by
the
module
path
module
path
in
the
respective
scope
of
the
expression
expr
begin
caml
example
toplevel
let
map
3d
matrix
f
m
let
open
Array
in
map
map
map
f
m
let
map
3d
matrix
f
Array
map
map
map
f
end
caml
example
When
the
body
of
a
local
open
expression
is
delimited
by
or
the
parentheses
can
be
omitted
For
expression
parentheses
can
also
be
omitted
for
For
example
module
path
expr
is
equivalent
to
module
path
expr
and
module
path
expr
is
equivalent
to
module
path
expr
begin
caml
example
toplevel
let
vector
Random
int
255
int
255
int
255
int
255
end
caml
example
newpage
section
s
classes
Classes
HEVEA
cutname
classes
html
Classes
are
defined
using
a
small
language
similar
to
the
module
language
subsection
ss
classes
class
types
Class
types
Class
types
are
the
class
level
equivalent
of
type
expressions
they
specify
the
general
shape
and
type
properties
of
classes
ikwd
object
texttt
object
ikwd
end
texttt
end
ikwd
inherit
texttt
inherit
ikwd
val
texttt
val
ikwd
mutable
texttt
mutable
ikwd
method
texttt
method
ikwd
private
texttt
private
ikwd
virtual
texttt
virtual
see
texttt
val
texttt
method
texttt
class
ikwd
constraint
texttt
constraint
begin
syntax
class
type
label
name
typexpr
class
type
class
body
type
class
body
type
object
typexpr
class
field
spec
end
typexpr
typexpr
classtype
path
let
open
module
path
in
class
body
type
end
syntax
begin
syntax
class
field
spec
inherit
class
body
type
val
mutable
virtual
inst
var
name
typexpr
val
virtual
mutable
inst
var
name
typexpr
method
private
virtual
method
name
poly
typexpr
method
virtual
private
method
name
poly
typexpr
constraint
typexpr
typexpr
end
syntax
See
also
the
following
language
extensions
hyperref
s
attributes
attributes
and
hyperref
s
extension
nodes
extension
nodes
subsubsection
sss
clty
simple
Simple
class
expressions
The
expression
classtype
path
is
equivalent
to
the
class
type
bound
to
the
name
classtype
path
Similarly
the
expression
typexpr
1
ldots
typexpr
n
classtype
path
is
equivalent
to
the
parametric
class
type
bound
to
the
name
classtype
path
in
which
type
parameters
have
been
instantiated
to
respectively
typexpr
1
ldots
typexpr
n
subsubsection
sss
clty
fun
Class
function
type
The
class
type
expression
typexpr
class
type
is
the
type
of
class
functions
functions
from
values
to
classes
that
take
as
argument
a
value
of
type
typexpr
and
return
as
result
a
class
of
type
class
type
subsubsection
sss
clty
body
Class
body
type
The
class
type
expression
object
typexpr
class
field
spec
end
is
the
type
of
a
class
body
It
specifies
its
instance
variables
and
methods
In
this
type
typexpr
is
matched
against
the
self
type
therefore
providing
a
name
for
the
self
type
A
class
body
will
match
a
class
body
type
if
it
provides
definitions
for
all
the
components
specified
in
the
class
body
type
and
these
definitions
meet
the
type
requirements
given
in
the
class
body
type
Furthermore
all
methods
either
virtual
or
public
present
in
the
class
body
must
also
be
present
in
the
class
body
type
on
the
other
hand
some
instance
variables
and
concrete
private
methods
may
be
omitted
A
virtual
method
will
match
a
concrete
method
which
makes
it
possible
to
forget
its
implementation
An
immutable
instance
variable
will
match
a
mutable
instance
variable
subsubsection
sss
clty
open
Local
opens
Local
opens
are
supported
in
class
types
since
OCaml
4
06
subsubsection
sss
clty
inheritance
Inheritance
ikwd
inherit
texttt
inherit
The
inheritance
construct
inherit
class
body
type
provides
for
inclusion
of
methods
and
instance
variables
from
other
class
types
The
instance
variable
and
method
types
from
class
body
type
are
added
into
the
current
class
type
subsubsection
sss
clty
variable
Instance
variable
specification
ikwd
val
texttt
val
ikwd
mutable
texttt
mutable
A
specification
of
an
instance
variable
is
written
val
mutable
virtual
inst
var
name
typexpr
where
inst
var
name
is
the
name
of
the
instance
variable
and
typexpr
its
expected
type
The
flag
mutable
indicates
whether
this
instance
variable
can
be
physically
modified
The
flag
virtual
indicates
that
this
instance
variable
is
not
initialized
It
can
be
initialized
later
through
inheritance
An
instance
variable
specification
will
hide
any
previous
specification
of
an
instance
variable
of
the
same
name
subsubsection
sss
clty
meth
Method
specification
ikwd
method
texttt
method
ikwd
private
texttt
private
The
specification
of
a
method
is
written
method
private
method
name
poly
typexpr
where
method
name
is
the
name
of
the
method
and
poly
typexpr
its
expected
type
possibly
polymorphic
The
flag
private
indicates
that
the
method
cannot
be
accessed
from
outside
the
object
The
polymorphism
may
be
left
implicit
in
public
method
specifications
any
type
variable
which
is
not
bound
to
a
class
parameter
and
does
not
appear
elsewhere
inside
the
class
specification
will
be
assumed
to
be
universal
and
made
polymorphic
in
the
resulting
method
type
Writing
an
explicit
polymorphic
type
will
disable
this
behaviour
If
several
specifications
are
present
for
the
same
method
they
must
have
compatible
types
Any
non
private
specification
of
a
method
forces
it
to
be
public
subsubsection
sss
class
virtual
meth
spec
Virtual
method
specification
ikwd
method
texttt
method
ikwd
private
texttt
private
A
virtual
method
specification
is
written
method
private
virtual
method
name
poly
typexpr
where
method
name
is
the
name
of
the
method
and
poly
typexpr
its
expected
type
subsubsection
sss
class
constraints
Constraints
on
type
parameters
ikwd
constraint
texttt
constraint
The
construct
constraint
typexpr
1
typexpr
2
forces
the
two
type
expressions
to
be
equal
This
is
typically
used
to
specify
type
parameters
in
this
way
they
can
be
bound
to
specific
type
expressions
subsection
ss
class
expr
Class
expressions
Class
expressions
are
the
class
level
equivalent
of
value
expressions
they
evaluate
to
classes
thus
providing
implementations
for
the
specifications
expressed
in
class
types
ikwd
object
texttt
object
ikwd
end
texttt
end
ikwd
fun
texttt
fun
ikwd
let
texttt
let
ikwd
and
texttt
and
ikwd
inherit
texttt
inherit
ikwd
as
texttt
as
ikwd
val
texttt
val
ikwd
mutable
texttt
mutable
ikwd
method
texttt
method
ikwd
private
texttt
private
ikwd
constraint
texttt
constraint
ikwd
initializer
texttt
initializer
begin
syntax
class
expr
class
path
typexpr
typexpr
class
path
class
expr
class
expr
class
type
class
expr
argument
fun
parameter
class
expr
let
rec
let
binding
and
let
binding
in
class
expr
object
class
body
end
let
open
module
path
in
class
expr
BEGIN
LATEX
end
syntax
begin
syntax
END
LATEX
class
field
inherit
class
expr
as
lowercase
ident
inherit
class
expr
as
lowercase
ident
val
mutable
inst
var
name
typexpr
expr
val
mutable
inst
var
name
typexpr
expr
val
mutable
virtual
inst
var
name
typexpr
val
virtual
mutable
inst
var
name
typexpr
method
private
method
name
parameter
typexpr
expr
method
private
method
name
parameter
typexpr
expr
method
private
method
name
poly
typexpr
expr
method
private
method
name
poly
typexpr
expr
method
private
virtual
method
name
poly
typexpr
method
virtual
private
method
name
poly
typexpr
constraint
typexpr
typexpr
initializer
expr
end
syntax
See
also
the
following
language
extensions
hyperref
s
locally
abstract
locally
abstract
types
hyperref
s
attributes
attributes
and
hyperref
s
extension
nodes
extension
nodes
subsubsection
sss
class
simple
Simple
class
expressions
The
expression
class
path
evaluates
to
the
class
bound
to
the
name
class
path
Similarly
the
expression
typexpr
1
ldots
typexpr
n
class
path
evaluates
to
the
parametric
class
bound
to
the
name
class
path
in
which
type
parameters
have
been
instantiated
respectively
to
typexpr
1
ldots
typexpr
n
The
expression
class
expr
evaluates
to
the
same
module
as
class
expr
The
expression
class
expr
class
type
checks
that
class
type
matches
the
type
of
class
expr
that
is
that
the
implementation
class
expr
meets
the
type
specification
class
type
The
whole
expression
evaluates
to
the
same
class
as
class
expr
except
that
all
components
not
specified
in
class
type
are
hidden
and
can
no
longer
be
accessed
subsubsection
sss
class
app
Class
application
Class
application
is
denoted
by
juxtaposition
of
possibly
labeled
expressions
It
denotes
the
class
whose
constructor
is
the
first
expression
applied
to
the
given
arguments
The
arguments
are
evaluated
as
for
expression
application
but
the
constructor
itself
will
only
be
evaluated
when
objects
are
created
In
particular
side
effects
caused
by
the
application
of
the
constructor
will
only
occur
at
object
creation
time
subsubsection
sss
class
fun
Class
function
The
expression
fun
label
name
pattern
class
expr
evaluates
to
a
function
from
values
to
classes
When
this
function
is
applied
to
a
value
var
v
this
value
is
matched
against
the
pattern
pattern
and
the
result
is
the
result
of
the
evaluation
of
class
expr
in
the
extended
environment
Conversion
from
functions
with
default
values
to
functions
with
patterns
only
works
identically
for
class
functions
as
for
normal
functions
The
expression
begin
center
fun
parameter
1
ldots
parameter
n
class
expr
end
center
is
a
short
form
for
begin
center
fun
parameter
1
ldots
fun
parameter
n
expr
end
center
subsubsection
sss
class
localdefs
Local
definitions
The
tt
let
and
tt
let
rec
constructs
bind
value
names
locally
as
for
the
core
language
expressions
If
a
local
definition
occurs
at
the
very
beginning
of
a
class
definition
it
will
be
evaluated
when
the
class
is
created
just
as
if
the
definition
was
outside
of
the
class
Otherwise
it
will
be
evaluated
when
the
object
constructor
is
called
subsubsection
sss
class
opens
Local
opens
Local
opens
are
supported
in
class
expressions
since
OCaml
4
06
subsubsection
sss
class
body
Class
body
begin
syntax
class
body
pattern
typexpr
class
field
end
syntax
The
expression
object
class
body
end
denotes
a
class
body
This
is
the
prototype
for
an
object
it
lists
the
instance
variables
and
methods
of
an
object
of
this
class
A
class
body
is
a
class
value
it
is
not
evaluated
at
once
Rather
its
components
are
evaluated
each
time
an
object
is
created
In
a
class
body
the
pattern
pattern
typexpr
is
matched
against
self
therefore
providing
a
binding
for
self
and
self
type
Self
can
only
be
used
in
method
and
initializers
Self
type
cannot
be
a
closed
object
type
so
that
the
class
remains
extensible
Since
OCaml
4
01
it
is
an
error
if
the
same
method
or
instance
variable
name
is
defined
several
times
in
the
same
class
body
subsubsection
sss
class
inheritance
Inheritance
ikwd
inherit
texttt
inherit
The
inheritance
construct
inherit
class
expr
allows
reusing
methods
and
instance
variables
from
other
classes
The
class
expression
class
expr
must
evaluate
to
a
class
body
The
instance
variables
methods
and
initializers
from
this
class
body
are
added
into
the
current
class
The
addition
of
a
method
will
override
any
previously
defined
method
of
the
same
name
ikwd
as
texttt
as
An
ancestor
can
be
bound
by
appending
as
lowercase
ident
to
the
inheritance
construct
lowercase
ident
is
not
a
true
variable
and
can
only
be
used
to
select
a
method
i
e
in
an
expression
lowercase
ident
method
name
This
gives
access
to
the
method
method
name
as
it
was
defined
in
the
parent
class
even
if
it
is
redefined
in
the
current
class
The
scope
of
this
ancestor
binding
is
limited
to
the
current
class
The
ancestor
method
may
be
called
from
a
subclass
but
only
indirectly
subsubsection
sss
class
variables
Instance
variable
definition
ikwd
val
texttt
val
ikwd
mutable
texttt
mutable
The
definition
val
mutable
inst
var
name
expr
adds
an
instance
variable
inst
var
name
whose
initial
value
is
the
value
of
expression
expr
The
flag
mutable
allows
physical
modification
of
this
variable
by
methods
An
instance
variable
can
only
be
used
in
the
methods
and
initializers
that
follow
its
definition
Since
version
3
10
redefinitions
of
a
visible
instance
variable
with
the
same
name
do
not
create
a
new
variable
but
are
merged
using
the
last
value
for
initialization
They
must
have
identical
types
and
mutability
However
if
an
instance
variable
is
hidden
by
omitting
it
from
an
interface
it
will
be
kept
distinct
from
other
instance
variables
with
the
same
name
subsubsection
sss
class
virtual
variable
Virtual
instance
variable
definition
ikwd
val
texttt
val
ikwd
mutable
texttt
mutable
A
variable
specification
is
written
val
mutable
virtual
inst
var
name
typexpr
It
specifies
whether
the
variable
is
modifiable
and
gives
its
type
Virtual
instance
variables
were
added
in
version
3
10
subsubsection
sss
class
method
Method
definition
ikwd
method
texttt
method
ikwd
private
texttt
private
A
method
definition
is
written
method
method
name
expr
The
definition
of
a
method
overrides
any
previous
definition
of
this
method
The
method
will
be
public
that
is
not
private
if
any
of
the
definition
states
so
A
private
method
method
private
method
name
expr
is
a
method
that
can
only
be
invoked
on
self
from
other
methods
of
the
same
object
defined
in
this
class
or
one
of
its
subclasses
This
invocation
is
performed
using
the
expression
value
name
method
name
where
value
name
is
directly
bound
to
self
at
the
beginning
of
the
class
definition
Private
methods
do
not
appear
in
object
types
A
method
may
have
both
public
and
private
definitions
but
as
soon
as
there
is
a
public
one
all
subsequent
definitions
will
be
made
public
Methods
may
have
an
explicitly
polymorphic
type
allowing
them
to
be
used
polymorphically
in
programs
even
for
the
same
object
The
explicit
declaration
may
be
done
in
one
of
three
ways
1
by
giving
an
explicit
polymorphic
type
in
the
method
definition
immediately
after
the
method
name
em
i
e
method
private
method
name
ident
typexpr
expr
2
by
a
forward
declaration
of
the
explicit
polymorphic
type
through
a
virtual
method
definition
3
by
importing
such
a
declaration
through
inheritance
and
or
constraining
the
type
of
em
self
Some
special
expressions
are
available
in
method
bodies
for
manipulating
instance
variables
and
duplicating
self
begin
syntax
expr
ldots
inst
var
name
expr
inst
var
name
expr
inst
var
name
expr
end
syntax
The
expression
inst
var
name
expr
modifies
in
place
the
current
object
by
replacing
the
value
associated
to
inst
var
name
by
the
value
of
expr
Of
course
this
instance
variable
must
have
been
declared
mutable
The
expression
inst
var
name
1
expr
1
ldots
inst
var
name
n
expr
n
evaluates
to
a
copy
of
the
current
object
in
which
the
values
of
instance
variables
inst
var
name
1
ldots
inst
var
name
n
have
been
replaced
by
the
values
of
the
corresponding
expressions
expr
1
ldots
expr
n
subsubsection
sss
class
virtual
meth
Virtual
method
definition
ikwd
method
texttt
method
ikwd
private
texttt
private
A
method
specification
is
written
method
private
virtual
method
name
poly
typexpr
It
specifies
whether
the
method
is
public
or
private
and
gives
its
type
If
the
method
is
intended
to
be
polymorphic
the
type
must
be
explicitly
polymorphic
subsubsection
sss
class
explicit
overriding
Explicit
overriding
Since
Ocaml
3
12
the
keywords
inherit
val
and
method
have
the
same
semantics
as
inherit
val
and
method
but
they
additionally
require
the
definition
they
introduce
to
be
overriding
Namely
method
requires
method
name
to
be
already
defined
in
this
class
val
requires
inst
var
name
to
be
already
defined
in
this
class
and
inherit
requires
class
expr
to
override
some
definitions
If
no
such
overriding
occurs
an
error
is
signaled
As
a
side
effect
these
3
keywords
avoid
the
warnings
7
method
override
and
13
instance
variable
override
Note
that
warning
7
is
disabled
by
default
subsubsection
sss
class
type
constraints
Constraints
on
type
parameters
ikwd
constraint
texttt
constraint
The
construct
constraint
typexpr
1
typexpr
2
forces
the
two
type
expressions
to
be
equals
This
is
typically
used
to
specify
type
parameters
in
that
way
they
can
be
bound
to
specific
type
expressions
subsubsection
sss
class
initializers
Initializers
ikwd
initializer
texttt
initializer
A
class
initializer
initializer
expr
specifies
an
expression
that
will
be
evaluated
whenever
an
object
is
created
from
the
class
once
all
its
instance
variables
have
been
initialized
subsection
ss
class
def
Class
definitions
label
s
classdef
ikwd
class
texttt
class
ikwd
and
texttt
and
begin
syntax
class
definition
class
class
binding
and
class
binding
class
binding
virtual
type
parameters
class
name
parameter
class
type
class
expr
type
parameters
ident
ident
end
syntax
A
class
definition
class
class
binding
and
class
binding
is
recursive
Each
class
binding
defines
a
class
name
that
can
be
used
in
the
whole
expression
except
for
inheritance
It
can
also
be
used
for
inheritance
but
only
in
the
definitions
that
follow
its
own
A
class
binding
binds
the
class
name
class
name
to
the
value
of
expression
class
expr
It
also
binds
the
class
type
class
name
to
the
type
of
the
class
and
defines
two
type
abbreviations
class
name
and
class
name
The
first
one
is
the
type
of
objects
of
this
class
while
the
second
is
more
general
as
it
unifies
with
the
type
of
any
object
belonging
to
a
subclass
see
section
ref
sss
typexpr
sharp
types
subsubsection
sss
class
virtual
Virtual
class
A
class
must
be
flagged
virtual
if
one
of
its
methods
is
virtual
that
is
appears
in
the
class
type
but
is
not
actually
defined
Objects
cannot
be
created
from
a
virtual
class
subsubsection
sss
class
type
params
Type
parameters
The
class
type
parameters
correspond
to
the
ones
of
the
class
type
and
of
the
two
type
abbreviations
defined
by
the
class
binding
They
must
be
bound
to
actual
types
in
the
class
definition
using
type
constraints
So
that
the
abbreviations
are
well
formed
type
variables
of
the
inferred
type
of
the
class
must
either
be
type
parameters
or
be
bound
in
the
constraint
clause
subsection
ss
class
spec
Class
specifications
ikwd
class
texttt
class
ikwd
and
texttt
and
begin
syntax
class
specification
class
class
spec
and
class
spec
class
spec
virtual
type
parameters
class
name
class
type
end
syntax
This
is
the
counterpart
in
signatures
of
class
definitions
A
class
specification
matches
a
class
definition
if
they
have
the
same
type
parameters
and
their
types
match
subsection
ss
classtype
Class
type
definitions
ikwd
class
texttt
class
ikwd
type
texttt
type
ikwd
and
texttt
and
begin
syntax
classtype
definition
class
type
classtype
def
and
classtype
def
classtype
def
virtual
type
parameters
class
name
class
body
type
end
syntax
A
class
type
definition
class
class
name
class
body
type
defines
an
abbreviation
class
name
for
the
class
body
type
class
body
type
As
for
class
definitions
two
type
abbreviations
class
name
and
class
name
are
also
defined
The
definition
can
be
parameterized
by
some
type
parameters
If
any
method
in
the
class
type
body
is
virtual
the
definition
must
be
flagged
virtual
Two
class
type
definitions
match
if
they
have
the
same
type
parameters
and
they
expand
to
matching
types
section
s
modtypes
Module
types
module
specifications
HEVEA
cutname
modtypes
html
Module
types
are
the
module
level
equivalent
of
type
expressions
they
specify
the
general
shape
and
type
properties
of
modules
ikwd
sig
texttt
sig
ikwd
end
texttt
end
ikwd
functor
texttt
functor
ikwd
with
texttt
with
ikwd
and
texttt
and
ikwd
val
texttt
val
ikwd
external
texttt
external
ikwd
type
texttt
type
ikwd
exception
texttt
exception
ikwd
class
texttt
class
ikwd
module
texttt
module
ikwd
open
texttt
open
ikwd
include
texttt
include
begin
syntax
module
type
modtype
path
sig
specification
end
functor
module
name
module
type
module
type
module
type
module
type
module
type
with
mod
constraint
and
mod
constraint
module
type
mod
constraint
type
type
params
typeconstr
type
equation
type
constraint
module
module
path
extended
module
path
BEGIN
LATEX
end
syntax
begin
syntax
END
LATEX
specification
val
value
name
typexpr
external
value
name
typexpr
external
declaration
type
definition
exception
constr
decl
class
specification
classtype
definition
module
module
name
module
type
module
module
name
module
name
module
type
module
type
module
type
modtype
name
module
type
modtype
name
module
type
open
module
path
include
module
type
end
syntax
See
also
the
following
language
extensions
hyperref
s
module
type
of
recovering
the
type
of
a
module
hyperref
s
signature
substitution
substitution
inside
a
signature
hyperref
s
module
alias
type
level
module
aliases
hyperref
s
attributes
attributes
hyperref
s
extension
nodes
extension
nodes
hyperref
s
generative
functors
generative
functors
and
hyperref
ss
module
type
substitution
module
type
substitutions
subsection
ss
mty
simple
Simple
module
types
The
expression
modtype
path
is
equivalent
to
the
module
type
bound
to
the
name
modtype
path
The
expression
module
type
denotes
the
same
type
as
module
type
subsection
ss
mty
signatures
Signatures
ikwd
sig
texttt
sig
ikwd
end
texttt
end
Signatures
are
type
specifications
for
structures
Signatures
sig
ldots
end
are
collections
of
type
specifications
for
value
names
type
names
exceptions
module
names
and
module
type
names
A
structure
will
match
a
signature
if
the
structure
provides
definitions
implementations
for
all
the
names
specified
in
the
signature
and
possibly
more
and
these
definitions
meet
the
type
requirements
given
in
the
signature
An
optional
is
allowed
after
each
specification
in
a
signature
It
serves
as
a
syntactic
separator
with
no
semantic
meaning
subsubsection
sss
mty
values
Value
specifications
ikwd
val
texttt
val
A
specification
of
a
value
component
in
a
signature
is
written
val
value
name
typexpr
where
value
name
is
the
name
of
the
value
and
typexpr
its
expected
type
ikwd
external
texttt
external
The
form
external
value
name
typexpr
external
declaration
is
similar
except
that
it
requires
in
addition
the
name
to
be
implemented
as
the
external
function
specified
in
external
declaration
see
chapter
ref
c
intf
c
subsubsection
sss
mty
type
Type
specifications
ikwd
type
texttt
type
A
specification
of
one
or
several
type
components
in
a
signature
is
written
type
typedef
and
typedef
and
consists
of
a
sequence
of
mutually
recursive
definitions
of
type
names
Each
type
definition
in
the
signature
specifies
an
optional
type
equation
typexpr
and
an
optional
type
representation
constr
decl
ldots
or
field
decl
ldots
The
implementation
of
the
type
name
in
a
matching
structure
must
be
compatible
with
the
type
expression
specified
in
the
equation
if
given
and
have
the
specified
representation
if
given
Conversely
users
of
that
signature
will
be
able
to
rely
on
the
type
equation
or
type
representation
if
given
More
precisely
we
have
the
following
four
situations
begin
description
item
Abstract
type
no
equation
no
representation
Names
that
are
defined
as
abstract
types
in
a
signature
can
be
implemented
in
a
matching
structure
by
any
kind
of
type
definition
provided
it
has
the
same
number
of
type
parameters
The
exact
implementation
of
the
type
will
be
hidden
to
the
users
of
the
structure
In
particular
if
the
type
is
implemented
as
a
variant
type
or
record
type
the
associated
constructors
and
fields
will
not
be
accessible
to
the
users
if
the
type
is
implemented
as
an
abbreviation
the
type
equality
between
the
type
name
and
the
right
hand
side
of
the
abbreviation
will
be
hidden
from
the
users
of
the
structure
Users
of
the
structure
consider
that
type
as
incompatible
with
any
other
type
a
fresh
type
has
been
generated
item
Type
abbreviation
an
equation
typexpr
no
representation
The
type
name
must
be
implemented
by
a
type
compatible
with
typexpr
All
users
of
the
structure
know
that
the
type
name
is
compatible
with
typexpr
item
New
variant
type
or
record
type
no
equation
a
representation
The
type
name
must
be
implemented
by
a
variant
type
or
record
type
with
exactly
the
constructors
or
fields
specified
All
users
of
the
structure
have
access
to
the
constructors
or
fields
and
can
use
them
to
create
or
inspect
values
of
that
type
However
users
of
the
structure
consider
that
type
as
incompatible
with
any
other
type
a
fresh
type
has
been
generated
item
Re
exported
variant
type
or
record
type
an
equation
a
representation
This
case
combines
the
previous
two
the
representation
of
the
type
is
made
visible
to
all
users
and
no
fresh
type
is
generated
end
description
subsubsection
sss
mty
exn
Exception
specification
ikwd
exception
texttt
exception
The
specification
exception
constr
decl
in
a
signature
requires
the
matching
structure
to
provide
an
exception
with
the
name
and
arguments
specified
in
the
definition
and
makes
the
exception
available
to
all
users
of
the
structure
subsubsection
sss
mty
class
Class
specifications
ikwd
class
texttt
class
A
specification
of
one
or
several
classes
in
a
signature
is
written
class
class
spec
and
class
spec
and
consists
of
a
sequence
of
mutually
recursive
definitions
of
class
names
Class
specifications
are
described
more
precisely
in
section
ref
ss
class
spec
subsubsection
sss
mty
classtype
Class
type
specifications
ikwd
class
texttt
class
ikwd
type
texttt
type
A
specification
of
one
or
several
class
types
in
a
signature
is
written
class
type
classtype
def
and
classtype
def
and
consists
of
a
sequence
of
mutually
recursive
definitions
of
class
type
names
Class
type
specifications
are
described
more
precisely
in
section
ref
ss
classtype
subsubsection
sss
mty
module
Module
specifications
ikwd
module
texttt
module
A
specification
of
a
module
component
in
a
signature
is
written
module
module
name
module
type
where
module
name
is
the
name
of
the
module
component
and
module
type
its
expected
type
Modules
can
be
nested
arbitrarily
in
particular
functors
can
appear
as
components
of
structures
and
functor
types
as
components
of
signatures
For
specifying
a
module
component
that
is
a
functor
one
may
write
begin
center
module
module
name
name
1
module
type
1
ldots
name
n
module
type
n
module
type
end
center
instead
of
begin
center
module
module
name
name
1
module
type
1
ldots
name
n
module
type
n
module
type
end
center
subsubsection
sss
mty
mty
Module
type
specifications
ikwd
type
texttt
type
ikwd
module
texttt
module
A
module
type
component
of
a
signature
can
be
specified
either
as
a
manifest
module
type
or
as
an
abstract
module
type
An
abstract
module
type
specification
module
type
modtype
name
allows
the
name
modtype
name
to
be
implemented
by
any
module
type
in
a
matching
signature
but
hides
the
implementation
of
the
module
type
to
all
users
of
the
signature
A
manifest
module
type
specification
module
type
modtype
name
module
type
requires
the
name
modtype
name
to
be
implemented
by
the
module
type
module
type
in
a
matching
signature
but
makes
the
equality
between
modtype
name
and
module
type
apparent
to
all
users
of
the
signature
subsubsection
sss
mty
open
Opening
a
module
path
ikwd
open
texttt
open
The
expression
open
module
path
in
a
signature
does
not
specify
any
components
It
simply
affects
the
parsing
of
the
following
items
of
the
signature
allowing
components
of
the
module
denoted
by
module
path
to
be
referred
to
by
their
simple
names
name
instead
of
path
accesses
module
path
name
The
scope
of
the
open
stops
at
the
end
of
the
signature
expression
subsubsection
sss
mty
include
Including
a
signature
ikwd
include
texttt
include
The
expression
include
module
type
in
a
signature
performs
textual
inclusion
of
the
components
of
the
signature
denoted
by
module
type
It
behaves
as
if
the
components
of
the
included
signature
were
copied
at
the
location
of
the
include
The
module
type
argument
must
refer
to
a
module
type
that
is
a
signature
not
a
functor
type
subsection
ss
mty
functors
Functor
types
ikwd
functor
texttt
functor
The
module
type
expression
functor
module
name
module
type
1
module
type
2
is
the
type
of
functors
functions
from
modules
to
modules
that
take
as
argument
a
module
of
type
module
type
1
and
return
as
result
a
module
of
type
module
type
2
The
module
type
module
type
2
can
use
the
name
module
name
to
refer
to
type
components
of
the
actual
argument
of
the
functor
If
the
type
module
type
2
does
not
depend
on
type
components
of
module
name
the
module
type
expression
can
be
simplified
with
the
alternative
short
syntax
module
type
1
module
type
2
No
restrictions
are
placed
on
the
type
of
the
functor
argument
in
particular
a
functor
may
take
another
functor
as
argument
higher
order
functor
When
the
result
module
type
is
itself
a
functor
begin
center
name
1
module
type
1
ldots
name
n
module
type
n
module
type
end
center
one
may
use
the
abbreviated
form
begin
center
name
1
module
type
1
ldots
name
n
module
type
n
module
type
end
center
subsection
ss
mty
with
The
with
operator
ikwd
with
texttt
with
Assuming
module
type
denotes
a
signature
the
expression
module
type
with
mod
constraint
and
mod
constraint
denotes
the
same
signature
where
type
equations
have
been
added
to
some
of
the
type
specifications
as
described
by
the
constraints
following
the
with
keyword
The
constraint
type
type
parameters
typeconstr
typexpr
adds
the
type
equation
typexpr
to
the
specification
of
the
type
component
named
typeconstr
of
the
constrained
signature
The
constraint
module
module
path
extended
module
path
adds
type
equations
to
all
type
components
of
the
sub
structure
denoted
by
module
path
making
them
equivalent
to
the
corresponding
type
components
of
the
structure
denoted
by
extended
module
path
For
instance
if
the
module
type
name
S
is
bound
to
the
signature
begin
verbatim
sig
type
t
module
M
sig
type
u
end
end
end
verbatim
then
S
with
type
t
int
denotes
the
signature
begin
verbatim
sig
type
t
int
module
M
sig
type
u
end
end
end
verbatim
and
S
with
module
M
N
denotes
the
signature
begin
verbatim
sig
type
t
module
M
sig
type
u
N
u
end
end
end
verbatim
A
functor
taking
two
arguments
of
type
S
that
share
their
t
component
is
written
begin
verbatim
functor
A
S
B
S
with
type
t
A
t
end
verbatim
Constraints
are
added
left
to
right
After
each
constraint
has
been
applied
the
resulting
signature
must
be
a
subtype
of
the
signature
before
the
constraint
was
applied
Thus
the
with
operator
can
only
add
information
on
the
type
components
of
a
signature
but
never
remove
information
section
s
tydef
Type
and
exception
definitions
HEVEA
cutname
typedecl
html
subsection
ss
typedefs
Type
definitions
Type
definitions
bind
type
constructors
to
data
types
either
variant
types
record
types
type
abbreviations
or
abstract
data
types
They
also
bind
the
value
constructors
and
record
fields
associated
with
the
definition
ikwd
type
texttt
type
ikwd
and
texttt
and
ikwd
nonrec
texttt
nonrec
ikwd
of
texttt
of
begin
syntax
type
definition
type
nonrec
typedef
and
typedef
typedef
type
params
typeconstr
name
type
information
type
information
type
equation
type
representation
type
constraint
type
equation
typexpr
type
representation
constr
decl
constr
decl
record
decl
type
params
type
param
type
param
type
param
type
param
ext
variance
ident
ext
variance
variance
injectivity
injectivity
variance
variance
injectivity
record
decl
field
decl
field
decl
constr
decl
constr
name
of
constr
args
constr
args
typexpr
typexpr
field
decl
mutable
field
name
poly
typexpr
type
constraint
constraint
typexpr
typexpr
end
syntax
ikwd
mutable
texttt
mutable
ikwd
constraint
texttt
constraint
See
also
the
following
language
extensions
hyperref
s
private
types
private
types
hyperref
s
gadts
generalized
algebraic
datatypes
hyperref
s
attributes
attributes
hyperref
s
extension
nodes
extension
nodes
hyperref
s
extensible
variants
extensible
variant
types
and
hyperref
s
inline
records
inline
records
Type
definitions
are
introduced
by
the
type
keyword
and
consist
in
one
or
several
simple
definitions
possibly
mutually
recursive
separated
by
the
and
keyword
Each
simple
definition
defines
one
type
constructor
A
simple
definition
consists
in
a
lowercase
identifier
possibly
preceded
by
one
or
several
type
parameters
and
followed
by
an
optional
type
equation
then
an
optional
type
representation
and
then
a
constraint
clause
The
identifier
is
the
name
of
the
type
constructor
being
defined
begin
verbatim
type
colour
Red
Green
Blue
Yellow
Black
White
RGB
of
r
int
g
int
b
int
type
a
tree
Lf
Br
of
a
a
tree
a
type
t
decoration
string
substance
t
and
t
Int
of
int
List
of
t
list
end
verbatim
In
the
right
hand
side
of
type
definitions
references
to
one
of
the
type
constructor
name
being
defined
are
considered
as
recursive
unless
type
is
followed
by
nonrec
The
nonrec
keyword
was
introduced
in
OCaml
4
02
2
The
optional
type
parameters
are
either
one
type
variable
ident
for
type
constructors
with
one
parameter
or
a
list
of
type
variables
ident
1
ldots
ident
n
for
type
constructors
with
several
parameters
Each
type
parameter
may
be
prefixed
by
a
variance
constraint
resp
indicating
that
the
parameter
is
covariant
resp
contravariant
and
an
injectivity
annotation
indicating
that
the
parameter
can
be
deduced
from
the
whole
type
These
type
parameters
can
appear
in
the
type
expressions
of
the
right
hand
side
of
the
definition
optionally
restricted
by
a
variance
constraint
em
i
e
a
covariant
parameter
may
only
appear
on
the
right
side
of
a
functional
arrow
more
precisely
follow
the
left
branch
of
an
even
number
of
arrows
and
a
contravariant
parameter
only
the
left
side
left
branch
of
an
odd
number
of
arrows
If
the
type
has
a
representation
or
an
equation
and
the
parameter
is
free
em
i
e
not
bound
via
a
type
constraint
to
a
constructed
type
its
variance
constraint
is
checked
but
subtyping
em
etc
will
use
the
inferred
variance
of
the
parameter
which
may
be
less
restrictive
otherwise
em
i
e
for
abstract
types
or
non
free
parameters
the
variance
must
be
given
explicitly
and
the
parameter
is
invariant
if
no
variance
is
given
The
optional
type
equation
typexpr
makes
the
defined
type
equivalent
to
the
type
expression
typexpr
one
can
be
substituted
for
the
other
during
typing
If
no
type
equation
is
given
a
new
type
is
generated
the
defined
type
is
incompatible
with
any
other
type
The
optional
type
representation
describes
the
data
structure
representing
the
defined
type
by
giving
the
list
of
associated
constructors
if
it
is
a
variant
type
or
associated
fields
if
it
is
a
record
type
If
no
type
representation
is
given
nothing
is
assumed
on
the
structure
of
the
type
besides
what
is
stated
in
the
optional
type
equation
The
type
representation
constr
decl
constr
decl
describes
a
variant
type
The
constructor
declarations
constr
decl
1
ldots
constr
decl
n
describe
the
constructors
associated
to
this
variant
type
The
constructor
declaration
constr
name
of
typexpr
1
ldots
typexpr
n
declares
the
name
constr
name
as
a
non
constant
constructor
whose
arguments
have
types
typexpr
1
ldots
typexpr
n
The
constructor
declaration
constr
name
declares
the
name
constr
name
as
a
constant
constructor
Constructor
names
must
be
capitalized
The
type
representation
field
decl
field
decl
describes
a
record
type
The
field
declarations
field
decl
1
ldots
field
decl
n
describe
the
fields
associated
to
this
record
type
The
field
declaration
field
name
poly
typexpr
declares
field
name
as
a
field
whose
argument
has
type
poly
typexpr
The
field
declaration
mutable
field
name
poly
typexpr
ikwd
mutable
texttt
mutable
behaves
similarly
in
addition
it
allows
physical
modification
of
this
field
Immutable
fields
are
covariant
mutable
fields
are
non
variant
Since
OCaml
5
4
mutable
fields
may
be
marked
atomic
for
concurrent
access
see
ref
s
atomic
record
fields
Both
mutable
and
immutable
fields
may
have
explicitly
polymorphic
types
The
polymorphism
of
the
contents
is
statically
checked
whenever
a
record
value
is
created
or
modified
Extracted
values
may
have
their
types
instantiated
The
two
components
of
a
type
definition
the
optional
equation
and
the
optional
representation
can
be
combined
independently
giving
rise
to
four
typical
situations
begin
description
item
Abstract
type
no
equation
no
representation
When
appearing
in
a
module
signature
this
definition
specifies
nothing
on
the
type
constructor
besides
its
number
of
parameters
its
representation
is
hidden
and
it
is
assumed
incompatible
with
any
other
type
item
Type
abbreviation
an
equation
no
representation
This
defines
the
type
constructor
as
an
abbreviation
for
the
type
expression
on
the
right
of
the
sign
item
New
variant
type
or
record
type
no
equation
a
representation
This
generates
a
new
type
constructor
and
defines
associated
constructors
or
fields
through
which
values
of
that
type
can
be
directly
built
or
inspected
item
Re
exported
variant
type
or
record
type
an
equation
a
representation
In
this
case
the
type
constructor
is
defined
as
an
abbreviation
for
the
type
expression
given
in
the
equation
but
in
addition
the
constructors
or
fields
given
in
the
representation
remain
attached
to
the
defined
type
constructor
The
type
expression
in
the
equation
part
must
agree
with
the
representation
it
must
be
of
the
same
kind
record
or
variant
and
have
exactly
the
same
constructors
or
fields
in
the
same
order
with
the
same
arguments
Moreover
the
new
type
constructor
must
have
the
same
arity
and
the
same
type
constraints
as
the
original
type
constructor
end
description
The
type
variables
appearing
as
type
parameters
can
optionally
be
prefixed
by
or
to
indicate
that
the
type
constructor
has
a
specific
variance
with
respect
to
this
parameter
A
parameter
prefixed
with
is
covariant
one
prefixed
with
is
contravariant
A
parameter
can
be
both
covariant
and
contravariant
also
known
as
bivariant
with
either
a
or
prefix
This
variance
information
is
used
to
decide
subtyping
relations
when
checking
the
validity
of
coercions
see
section
ref
ss
expr
coercions
For
instance
type
a
t
declares
t
as
an
abstract
type
that
is
covariant
in
its
parameter
this
means
that
if
the
type
tau
is
a
subtype
of
the
type
sigma
then
tau
t
is
a
subtype
of
sigma
t
Similarly
type
a
t
declares
that
the
abstract
type
t
is
contravariant
in
its
parameter
if
tau
is
a
subtype
of
sigma
then
sigma
t
is
a
subtype
of
tau
t
If
no
or
variance
annotation
is
given
the
type
constructor
is
assumed
non
variant
in
the
corresponding
parameter
For
instance
the
abstract
type
declaration
type
a
t
means
that
tau
t
is
neither
a
subtype
nor
a
supertype
of
sigma
t
if
tau
is
subtype
of
sigma
The
variance
indicated
by
the
and
annotations
on
parameters
is
enforced
only
for
abstract
and
private
types
or
when
there
are
type
constraints
Otherwise
for
abbreviations
variant
and
record
types
without
type
constraints
the
variance
properties
of
the
type
constructor
are
inferred
from
its
definition
and
the
variance
annotations
are
only
checked
for
conformance
with
the
definition
Injectivity
annotations
are
only
necessary
for
abstract
types
and
private
row
types
since
they
can
otherwise
be
deduced
from
the
type
declaration
all
parameters
are
injective
for
record
and
variant
type
declarations
including
extensible
types
for
type
abbreviations
a
parameter
is
injective
if
it
has
an
injective
occurrence
in
its
defining
equation
be
it
private
or
not
For
constrained
type
parameters
in
type
abbreviations
they
are
injective
if
either
they
appear
at
an
injective
position
in
the
body
or
if
all
their
type
variables
are
injective
in
particular
if
a
constrained
type
parameter
contains
a
variable
that
doesn
t
appear
in
the
body
it
cannot
be
injective
ikwd
constraint
texttt
constraint
The
construct
constraint
ident
typexpr
allows
the
specification
of
type
parameters
Any
actual
type
argument
corresponding
to
the
type
parameter
ident
has
to
be
an
instance
of
typexpr
more
precisely
ident
and
typexpr
are
unified
Type
variables
of
typexpr
can
appear
in
the
type
equation
and
the
type
declaration
subsection
ss
exndef
Exception
definitions
ikwd
exception
texttt
exception
begin
syntax
exception
definition
exception
constr
decl
exception
constr
name
constr
end
syntax
Exception
definitions
add
new
constructors
to
the
built
in
variant
type
verb
exn
of
exception
values
The
constructors
are
declared
as
for
a
definition
of
a
variant
type
begin
caml
example
toplevel
exception
E
of
int
string
end
caml
example
The
form
exception
constr
decl
generates
a
new
exception
distinct
from
all
other
exceptions
in
the
system
The
form
exception
constr
name
constr
gives
an
alternate
name
to
an
existing
exception
begin
caml
example
toplevel
exception
E
of
int
string
exception
F
E
let
eq
E
1
one
F
1
one
end
caml
example
section
s
extension
nodes
Extension
nodes
HEVEA
cutname
extensionnodes
html
Introduced
in
OCaml
4
02
infix
notations
for
constructs
other
than
expressions
added
in
4
03
infix
notation
e1
ext
e2
added
in
4
04
Extension
nodes
are
generic
placeholders
in
the
syntax
tree
They
are
rejected
by
the
type
checker
and
are
intended
to
be
expanded
by
external
tools
such
as
ppx
rewriters
Extension
nodes
share
the
same
notion
of
identifier
and
payload
as
attributes
ref
s
attributes
The
first
form
of
extension
node
is
used
for
algebraic
categories
begin
syntax
extension
attr
id
attr
payload
expr
extension
typexpr
extension
pattern
extension
module
expr
extension
module
type
extension
class
expr
extension
class
type
extension
end
syntax
A
second
form
of
extension
node
can
be
used
in
structures
and
signatures
both
in
the
module
and
object
languages
begin
syntax
item
extension
attr
id
attr
payload
definition
item
extension
specification
item
extension
class
field
spec
item
extension
class
field
item
extension
end
syntax
An
infix
form
is
available
for
extension
nodes
when
the
payload
is
of
the
same
kind
expression
with
expression
pattern
with
pattern
Examples
begin
verbatim
let
foo
x
2
in
x
1
foo
let
x
2
in
x
1
begin
foo
end
foo
begin
end
x
foo
2
foo
x
2
module
foo
M
foo
module
M
val
foo
x
t
foo
val
x
t
end
verbatim
When
this
form
is
used
together
with
the
infix
syntax
for
attributes
the
attributes
are
considered
to
apply
to
the
payload
begin
verbatim
fun
foo
bar
x
x
1
foo
fun
x
x
1
bar
end
verbatim
An
additional
shorthand
let
foo
x
in
is
available
for
convenience
when
extension
nodes
are
used
to
implement
binding
operators
See
ref
ss
letops
punning
Furthermore
quoted
strings
can
be
combined
with
extension
nodes
to
embed
foreign
syntax
fragments
Those
fragments
can
be
interpreted
by
a
preprocessor
and
turned
into
OCaml
code
without
requiring
escaping
quotes
A
syntax
shortcut
is
available
for
them
begin
verbatim
foo
foo
let
x
foo
let
x
foo
let
y
foo
bar
bar
let
y
foo
bar
bar
end
verbatim
For
instance
you
can
use
sql
to
represent
arbitrary
SQL
statements
assuming
you
have
a
ppx
rewriter
that
recognizes
the
sql
extension
Note
that
the
word
delimited
form
for
example
sql
sql
should
not
be
used
for
signaling
that
an
extension
is
in
use
Indeed
the
user
cannot
see
from
the
code
whether
this
string
literal
has
different
semantics
than
they
expect
Moreover
giving
semantics
to
a
specific
delimiter
limits
the
freedom
to
change
the
delimiter
to
avoid
escaping
issues
subsection
ss
builtin
extension
nodes
Built
in
extension
nodes
Introduced
in
OCaml
4
03
Some
extension
nodes
are
understood
by
the
compiler
itself
begin
itemize
item
ocaml
extension
constructor
or
extension
constructor
extensions
take
as
payload
a
constructor
from
an
extensible
variant
type
see
ref
s
extensible
variants
and
return
its
extension
constructor
slot
begin
caml
example
verbatim
type
t
type
t
X
of
int
Y
of
string
let
x
extension
constructor
X
let
y
extension
constructor
Y
end
caml
example
begin
caml
example
toplevel
x
y
end
caml
example
item
ocaml
atomic
loc
or
atomic
loc
extensions
take
as
payload
an
OCaml
expression
denoting
an
atomic
location
See
ref
s
atomic
record
fields
for
more
details
end
itemize
section
s
first
class
modules
First
class
modules
HEVEA
cutname
firstclassmodules
html
ikwd
module
texttt
module
ikwd
val
texttt
val
ikwd
with
texttt
with
ikwd
and
texttt
and
Introduced
in
OCaml
3
12
pattern
syntax
and
package
type
inference
introduced
in
4
00
structural
comparison
of
package
types
introduced
in
4
02
fewer
parens
required
starting
from
4
05
begin
syntax
typexpr
module
package
type
module
expr
val
expr
package
type
expr
module
module
expr
package
type
pattern
module
module
name
package
type
package
type
modtype
path
modtype
path
with
package
constraint
and
package
constraint
package
constraint
type
typeconstr
typexpr
end
syntax
Modules
are
typically
thought
of
as
static
components
This
extension
makes
it
possible
to
pack
a
module
as
a
first
class
value
which
can
later
be
dynamically
unpacked
into
a
module
The
expression
module
module
expr
package
type
converts
the
module
structure
or
functor
denoted
by
module
expression
module
expr
to
a
value
of
the
core
language
that
encapsulates
this
module
The
type
of
this
core
language
value
is
module
package
type
The
package
type
annotation
can
be
omitted
if
it
can
be
inferred
from
the
context
Conversely
the
module
expression
val
expr
package
type
evaluates
the
core
language
expression
expr
to
a
value
which
must
have
type
module
package
type
and
extracts
the
module
that
was
encapsulated
in
this
value
Again
package
type
can
be
omitted
if
the
type
of
expr
is
known
If
the
module
expression
is
already
parenthesized
like
the
arguments
of
functors
are
no
additional
parens
are
needed
Map
Make
val
key
The
pattern
module
module
name
package
type
matches
a
package
with
type
package
type
and
binds
it
to
module
name
It
is
not
allowed
in
toplevel
let
bindings
Again
package
type
can
be
omitted
if
it
can
be
inferred
from
the
enclosing
pattern
The
package
type
syntactic
class
appearing
in
the
module
package
type
type
expression
and
in
the
annotated
forms
represents
a
subset
of
module
types
This
subset
consists
of
named
module
types
with
optional
constraints
of
a
limited
form
only
non
parametrized
types
can
be
specified
For
type
checking
purposes
and
starting
from
OCaml
4
02
package
types
are
compared
using
the
structural
comparison
of
module
types
In
general
the
module
expression
val
expr
package
type
cannot
be
used
in
the
body
of
a
functor
because
this
could
cause
unsoundness
in
conjunction
with
applicative
functors
Since
OCaml
4
02
this
is
relaxed
in
two
ways
if
package
type
does
not
contain
nominal
type
declarations
em
i
e
types
that
are
created
with
a
proper
identity
then
this
expression
can
be
used
anywhere
and
even
if
it
contains
such
types
it
can
be
used
inside
the
body
of
a
generative
functor
described
in
section
ref
s
generative
functors
It
can
also
be
used
anywhere
in
the
context
of
a
local
module
binding
let
module
module
name
val
expr
1
package
type
in
expr
2
lparagraph
p
fst
mod
example
Basic
example
A
typical
use
of
first
class
modules
is
to
select
at
run
time
among
several
implementations
of
a
signature
Each
implementation
is
a
structure
that
we
can
encapsulate
as
a
first
class
module
then
store
in
a
data
structure
such
as
a
hash
table
begin
caml
example
verbatim
type
picture
unit
ellipsis
module
type
DEVICE
sig
val
draw
picture
unit
ellipsis
end
let
devices
string
module
DEVICE
Hashtbl
t
Hashtbl
create
17
module
SVG
struct
let
draw
ellipsis
end
let
Hashtbl
add
devices
SVG
module
SVG
DEVICE
module
PDF
struct
let
draw
ellipsis
end
let
Hashtbl
add
devices
PDF
module
PDF
DEVICE
end
caml
example
We
can
then
select
one
implementation
based
on
command
line
arguments
for
instance
begin
caml
example
verbatim
let
parse
cmdline
SVG
ellipsis
module
Device
val
let
device
name
parse
cmdline
in
try
Hashtbl
find
devices
device
name
with
Not
found
Printf
eprintf
Unknown
device
s
n
device
name
exit
2
DEVICE
end
caml
example
Alternatively
the
selection
can
be
performed
within
a
function
begin
caml
example
verbatim
let
draw
using
device
device
name
picture
let
module
Device
val
Hashtbl
find
devices
device
name
DEVICE
in
Device
draw
picture
end
caml
example
lparagraph
p
fst
mod
advexamples
Advanced
examples
With
first
class
modules
it
is
possible
to
parametrize
some
code
over
the
implementation
of
a
module
without
using
a
functor
begin
caml
example
verbatim
let
sort
type
s
module
Set
Set
S
with
type
elt
s
l
Set
elements
List
fold
right
Set
add
l
Set
empty
end
caml
example
To
use
this
function
one
can
wrap
the
Set
Make
functor
begin
caml
example
verbatim
let
make
set
type
s
cmp
let
module
S
Set
Make
struct
type
t
s
let
compare
cmp
end
in
module
S
Set
S
with
type
elt
s
end
caml
example
iffalse
Another
advanced
use
of
first
class
module
is
to
encode
existential
types
In
particular
they
can
be
used
to
simulate
generalized
algebraic
data
types
GADT
To
demonstrate
this
we
first
define
a
type
of
witnesses
for
type
equalities
begin
caml
example
verbatim
module
TypEq
sig
type
a
b
t
val
apply
a
b
t
a
b
val
refl
a
a
t
val
sym
a
b
t
b
a
t
end
struct
type
a
b
t
a
b
b
a
let
refl
fun
x
x
fun
x
x
let
apply
f
x
f
x
let
sym
f
g
g
f
end
end
caml
example
We
can
then
define
a
parametrized
algebraic
data
type
whose
constructors
provide
some
information
about
the
type
parameter
begin
caml
example
verbatim
module
rec
Typ
sig
module
type
PAIR
sig
type
t
and
t1
and
t2
val
eq
t
t1
t2
TypEq
t
val
t1
t1
Typ
typ
val
t2
t2
Typ
typ
end
type
a
typ
Int
of
a
int
TypEq
t
String
of
a
string
TypEq
t
Pair
of
module
PAIR
with
type
t
a
end
Typ
end
caml
example
Values
of
type
a
typ
are
supposed
to
be
runtime
representations
for
the
type
a
The
constructors
Int
and
String
are
easy
they
directly
give
a
witness
of
type
equality
between
the
parameter
a
and
the
ground
types
int
resp
string
The
constructor
Pair
is
more
complex
One
wants
to
give
a
witness
of
type
equality
between
a
and
a
type
of
the
form
t1
t2
together
with
the
representations
for
t1
and
t2
However
these
two
types
are
unknown
The
code
above
shows
how
to
use
first
class
modules
to
simulate
existentials
Here
is
how
to
construct
values
of
type
a
typ
begin
caml
example
verbatim
let
int
Typ
Int
TypEq
refl
let
str
Typ
String
TypEq
refl
let
pair
type
s1
type
s2
t1
t2
let
module
P
struct
type
t
s1
s2
type
t1
s1
type
t2
s2
let
eq
TypEq
refl
let
t1
t1
let
t2
t2
end
in
let
pair
module
P
Typ
PAIR
with
type
t
s1
s2
in
Typ
Pair
pair
end
caml
example
And
finally
here
is
an
example
of
a
polymorphic
function
that
takes
the
runtime
representation
of
some
type
a
and
a
value
of
the
same
type
then
pretty
prints
the
value
into
a
string
begin
caml
example
verbatim
open
Typ
let
rec
to
string
a
a
Typ
typ
a
string
fun
type
s
t
x
match
t
with
Int
eq
Int
to
string
TypEq
apply
eq
x
String
eq
Printf
sprintf
S
TypEq
apply
eq
x
Pair
p
let
module
P
val
p
PAIR
with
type
t
s
in
let
x1
x2
TypEq
apply
P
eq
x
in
Printf
sprintf
s
s
to
string
P
t1
x1
to
string
P
t2
x2
end
caml
example
Note
that
this
function
uses
an
explicit
polymorphic
annotation
to
obtain
polymorphic
recursion
fi
section
s
private
types
Private
types
HEVEA
cutname
privatetypes
html
ikwd
private
texttt
private
Private
type
declarations
in
module
signatures
of
the
form
type
t
private
enable
libraries
to
reveal
some
but
not
all
aspects
of
the
implementation
of
a
type
to
clients
of
the
library
In
this
respect
they
strike
a
middle
ground
between
abstract
type
declarations
where
no
information
is
revealed
on
the
type
implementation
and
data
type
definitions
and
type
abbreviations
where
all
aspects
of
the
type
implementation
are
publicized
Private
type
declarations
come
in
three
flavors
for
variant
and
record
types
section
ref
ss
private
types
variant
for
type
abbreviations
section
ref
ss
private
types
abbrev
and
for
row
types
section
ref
ss
private
rows
subsection
ss
private
types
variant
Private
variant
and
record
types
Introduced
in
Objective
Caml
3
07
begin
syntax
type
representation
private
constr
decl
constr
decl
private
record
decl
end
syntax
Values
of
a
variant
or
record
type
declared
private
can
be
de
structured
normally
in
pattern
matching
or
via
the
expr
field
notation
for
record
accesses
However
values
of
these
types
cannot
be
constructed
directly
by
constructor
application
or
record
construction
Moreover
assignment
on
a
mutable
field
of
a
private
record
type
is
not
allowed
The
typical
use
of
private
types
is
in
the
export
signature
of
a
module
to
ensure
that
construction
of
values
of
the
private
type
always
go
through
the
functions
provided
by
the
module
while
still
allowing
pattern
matching
outside
the
defining
module
For
example
begin
caml
example
verbatim
module
M
sig
type
t
private
A
B
of
int
val
a
t
val
b
int
t
end
struct
type
t
A
B
of
int
let
a
A
let
b
n
assert
n
0
B
n
end
end
caml
example
Here
the
private
declaration
ensures
that
in
any
value
of
type
M
t
the
argument
to
the
B
constructor
is
always
a
positive
integer
With
respect
to
the
variance
of
their
parameters
private
types
are
handled
like
abstract
types
That
is
if
a
private
type
has
parameters
their
variance
is
the
one
explicitly
given
by
prefixing
the
parameter
by
a
or
a
it
is
invariant
otherwise
subsection
ss
private
types
abbrev
Private
type
abbreviations
Introduced
in
Objective
Caml
3
11
begin
syntax
type
equation
private
typexpr
end
syntax
Unlike
a
regular
type
abbreviation
a
private
type
abbreviation
declares
a
type
that
is
distinct
from
its
implementation
type
typexpr
However
coercions
from
the
type
to
typexpr
are
permitted
Moreover
the
compiler
knows
the
implementation
type
and
can
take
advantage
of
this
knowledge
to
perform
type
directed
optimizations
The
following
example
uses
a
private
type
abbreviation
to
define
a
module
of
nonnegative
integers
begin
caml
example
verbatim
module
N
sig
type
t
private
int
val
of
int
int
t
val
to
int
t
int
end
struct
type
t
int
let
of
int
n
assert
n
0
n
let
to
int
n
n
end
end
caml
example
The
type
N
t
is
incompatible
with
int
ensuring
that
nonnegative
integers
and
regular
integers
are
not
confused
However
if
x
has
type
N
t
the
coercion
x
int
is
legal
and
returns
the
underlying
integer
just
like
N
to
int
x
Deep
coercions
are
also
supported
if
l
has
type
N
t
list
the
coercion
l
int
list
returns
the
list
of
underlying
integers
like
List
map
N
to
int
l
but
without
copying
the
list
l
Note
that
the
coercion
expr
typexpr
is
actually
an
abbreviated
form
and
will
only
work
in
presence
of
private
abbreviations
if
neither
the
type
of
expr
nor
typexpr
contain
any
type
variables
If
they
do
you
must
use
the
full
form
expr
typexpr
1
typexpr
2
where
typexpr
1
is
the
expected
type
of
expr
Concretely
this
would
be
x
N
t
int
and
l
N
t
list
int
list
for
the
above
examples
subsection
ss
private
rows
Private
row
types
ikwd
private
texttt
private
Introduced
in
Objective
Caml
3
09
begin
syntax
type
equation
private
typexpr
end
syntax
Private
row
types
are
type
abbreviations
where
part
of
the
structure
of
the
type
is
left
abstract
Concretely
typexpr
in
the
above
should
denote
either
an
object
type
or
a
polymorphic
variant
type
with
some
possibility
of
refinement
left
If
the
private
declaration
is
used
in
an
interface
the
corresponding
implementation
may
either
provide
a
ground
instance
or
a
refined
private
type
begin
caml
example
verbatim
module
M
sig
type
c
private
x
int
val
o
c
end
struct
class
c
object
method
x
3
method
y
2
end
let
o
new
c
end
end
caml
example
This
declaration
does
more
than
hiding
the
y
method
it
also
makes
the
type
c
incompatible
with
any
other
closed
object
type
meaning
that
only
o
will
be
of
type
c
In
that
respect
it
behaves
similarly
to
private
record
types
But
private
row
types
are
more
flexible
with
respect
to
incremental
refinement
This
feature
can
be
used
in
combination
with
functors
begin
caml
example
verbatim
module
F
X
sig
type
c
private
x
int
end
struct
let
get
x
o
X
c
o
x
end
module
G
X
sig
type
c
private
x
int
y
int
end
struct
include
F
X
let
get
y
o
X
c
o
y
end
end
caml
example
A
polymorphic
variant
type
t
for
example
begin
caml
example
verbatim
type
t
A
of
int
B
of
bool
end
caml
example
can
be
refined
in
two
ways
A
definition
u
may
add
new
field
to
t
and
the
declaration
begin
caml
example
verbatim
type
u
private
t
end
caml
example
will
keep
those
new
fields
abstract
Construction
of
values
of
type
u
is
possible
using
the
known
variants
of
t
but
any
pattern
matching
will
require
a
default
case
to
handle
the
potential
extra
fields
Dually
a
declaration
u
may
restrict
the
fields
of
t
through
abstraction
the
declaration
begin
caml
example
verbatim
type
v
private
t
A
end
caml
example
corresponds
to
private
variant
types
One
cannot
create
a
value
of
the
private
type
v
except
using
the
constructors
that
are
explicitly
listed
as
present
A
n
in
this
example
yet
when
pattern
matching
on
a
v
one
should
assume
that
any
of
the
constructors
of
t
could
be
present
Similarly
to
abstract
types
the
variance
of
type
parameters
is
not
inferred
and
must
be
given
explicitly
section
s
explicit
overriding
open
Overriding
in
open
statements
HEVEA
cutname
overridingopen
html
ikwd
open
texttt
open
char33
Introduced
in
OCaml
4
01
begin
syntax
definition
open
module
path
specification
open
module
path
expr
let
open
module
path
in
expr
class
body
type
let
open
module
path
in
class
body
type
class
expr
let
open
module
path
in
class
expr
end
syntax
Since
OCaml
4
01
open
statements
shadowing
an
existing
identifier
which
is
later
used
trigger
the
warning
44
Adding
a
character
after
the
open
keyword
indicates
that
such
a
shadowing
is
intentional
and
should
not
trigger
the
warning
This
is
also
available
since
OCaml
4
06
for
local
opens
in
class
expressions
and
class
type
expressions
section
s
letrecvalues
Recursive
definitions
of
values
HEVEA
cutname
letrecvalues
html
Introduced
in
Objective
Caml
1
00
As
mentioned
in
section
ref
sss
expr
localdef
the
let
rec
binding
construct
in
addition
to
the
definition
of
recursive
functions
also
supports
a
certain
class
of
recursive
definitions
of
non
functional
values
such
as
begin
center
let
rec
name
1
1
name
2
and
name
2
2
name
1
in
expr
end
center
which
binds
name
1
to
the
cyclic
list
1
2
1
2
ldots
and
name
2
to
the
cyclic
list
2
1
2
1
ldots
Informally
the
class
of
accepted
definitions
consists
of
those
definitions
where
the
defined
names
occur
only
inside
function
bodies
or
as
argument
to
a
data
constructor
More
precisely
consider
the
expression
begin
center
let
rec
name
1
expr
1
and
ldots
and
name
n
expr
n
in
expr
end
center
It
will
be
accepted
if
each
one
of
expr
1
ldots
expr
n
is
statically
constructive
with
respect
to
name
1
ldots
name
n
is
not
immediately
linked
to
any
of
name
1
ldots
name
n
and
is
not
an
array
constructor
whose
arguments
have
abstract
type
An
expression
e
is
said
to
be
em
statically
constructive
with
respect
to
the
variables
name
1
ldots
name
n
if
at
least
one
of
the
following
conditions
is
true
begin
itemize
item
e
has
no
free
occurrence
of
any
of
name
1
ldots
name
n
item
e
is
a
variable
item
e
has
the
form
fun
ldots
ldots
item
e
has
the
form
function
ldots
ldots
item
e
has
the
form
lazy
ldots
item
e
has
one
of
the
following
forms
where
each
one
of
expr
1
ldots
expr
m
is
statically
constructive
with
respect
to
name
1
ldots
name
n
and
expr
0
is
statically
constructive
with
respect
to
name
1
ldots
name
n
xname
1
ldots
xname
m
begin
itemize
item
let
rec
xname
1
expr
1
and
ldots
and
xname
m
expr
m
in
expr
0
item
let
module
ldots
in
expr
1
item
constr
expr
1
ldots
expr
m
item
tag
name
expr
1
ldots
expr
m
item
expr
1
ldots
expr
m
item
field
1
expr
1
ldots
field
m
expr
m
item
expr
1
with
field
2
expr
2
ldots
field
m
expr
m
where
expr
1
is
not
immediately
linked
to
name
1
ldots
name
n
item
expr
1
ldots
expr
m
item
expr
1
ldots
expr
m
end
itemize
end
itemize
An
expression
e
is
said
to
be
em
immediately
linked
to
the
variable
name
in
the
following
cases
begin
itemize
item
e
is
name
item
e
has
the
form
expr
1
ldots
expr
m
where
expr
m
is
immediately
linked
to
name
item
e
has
the
form
let
rec
xname
1
expr
1
and
ldots
and
xname
m
expr
m
in
expr
0
where
expr
0
is
immediately
linked
to
name
or
to
one
of
the
xname
i
such
that
expr
i
is
immediately
linked
to
name
end
itemize
section
s
empty
variants
Empty
variant
types
HEVEA
cutname
emptyvariants
html
Introduced
in
4
07
0
begin
syntax
type
representation
end
syntax
This
extension
allows
user
to
define
empty
variants
Empty
variant
type
can
be
eliminated
by
refutation
case
of
pattern
matching
begin
caml
example
verbatim
type
t
let
f
x
t
match
x
with
end
caml
example
section
s
module
type
of
Recovering
the
type
of
a
module
HEVEA
cutname
moduletypeof
html
ikwd
module
texttt
module
ikwd
type
texttt
type
ikwd
of
texttt
of
ikwd
include
texttt
include
Introduced
in
OCaml
3
12
begin
syntax
module
type
module
type
of
module
expr
end
syntax
The
construction
module
type
of
module
expr
expands
to
the
module
type
signature
or
functor
type
inferred
for
the
module
expression
module
expr
To
make
this
module
type
reusable
in
many
situations
it
is
intentionally
not
strengthened
abstract
types
and
datatypes
are
not
explicitly
related
with
the
types
of
the
original
module
For
the
same
reason
module
aliases
in
the
inferred
type
are
expanded
A
typical
use
in
conjunction
with
the
signature
level
include
construct
is
to
extend
the
signature
of
an
existing
structure
In
that
case
one
wants
to
keep
the
types
equal
to
types
in
the
original
module
This
can
done
using
the
following
idiom
begin
caml
example
verbatim
module
type
MYHASH
sig
include
module
type
of
struct
include
Hashtbl
end
val
replace
a
b
t
a
b
unit
end
end
caml
example
The
signature
MYHASH
then
contains
all
the
fields
of
the
signature
of
the
module
Hashtbl
with
strengthened
type
definitions
plus
the
new
field
replace
An
implementation
of
this
signature
can
be
obtained
easily
by
using
the
include
construct
again
but
this
time
at
the
structure
level
begin
caml
example
verbatim
module
MyHash
MYHASH
struct
include
Hashtbl
let
replace
t
k
v
remove
t
k
add
t
k
v
end
end
caml
example
Another
application
where
the
absence
of
strengthening
comes
handy
is
to
provide
an
alternative
implementation
for
an
existing
module
begin
caml
example
verbatim
module
MySet
module
type
of
Set
struct
include
Set
ellipsis
end
end
caml
example
This
idiom
guarantees
that
Myset
is
compatible
with
Set
but
allows
it
to
represent
sets
internally
in
a
different
way
section
s
attributes
Attributes
HEVEA
cutname
attributes
html
ikwd
when
texttt
when
Introduced
in
OCaml
4
02
infix
notations
for
constructs
other
than
expressions
added
in
4
03
Attributes
are
decorations
of
the
syntax
tree
which
are
mostly
ignored
by
the
type
checker
but
can
be
used
by
external
tools
An
attribute
is
made
of
an
identifier
and
a
payload
which
can
be
a
structure
a
type
expression
prefixed
with
a
signature
prefixed
with
or
a
pattern
prefixed
with
optionally
followed
by
a
when
clause
begin
syntax
attr
id
lowercase
ident
capitalized
ident
attr
id
attr
id
attr
payload
module
items
typexpr
specification
pattern
when
expr
end
syntax
The
first
form
of
attributes
is
attached
with
a
postfix
notation
on
algebraic
categories
begin
syntax
attribute
attr
id
attr
payload
expr
expr
attribute
typexpr
typexpr
attribute
pattern
pattern
attribute
module
expr
module
expr
attribute
module
type
module
type
attribute
class
expr
class
expr
attribute
class
type
class
type
attribute
end
syntax
This
form
of
attributes
can
also
be
inserted
after
the
tag
name
in
polymorphic
variant
type
expressions
tag
spec
first
tag
spec
tag
spec
full
or
after
the
method
name
in
method
type
The
same
syntactic
form
is
also
used
to
attach
attributes
to
labels
and
constructors
in
type
declarations
begin
syntax
field
decl
mutable
field
name
poly
typexpr
attribute
constr
decl
constr
name
of
constr
args
attribute
end
syntax
Note
when
a
label
declaration
is
followed
by
a
semi
colon
attributes
can
also
be
put
after
the
semi
colon
in
which
case
they
are
merged
to
those
specified
before
The
second
form
of
attributes
are
attached
to
blocks
such
as
type
declarations
class
fields
etc
begin
syntax
item
attribute
attr
id
attr
payload
typedef
typedef
item
attribute
exception
definition
exception
constr
decl
exception
constr
name
constr
module
items
definition
expr
item
attribute
definition
expr
item
attribute
class
binding
class
binding
item
attribute
class
spec
class
spec
item
attribute
classtype
def
classtype
def
item
attribute
let
binding
let
binding
item
attribute
definition
let
rec
let
binding
and
let
binding
external
value
name
typexpr
external
declaration
item
attribute
type
definition
exception
definition
item
attribute
class
definition
classtype
definition
module
module
name
module
name
module
type
module
type
module
expr
item
attribute
module
type
modtype
name
module
type
item
attribute
open
module
path
item
attribute
include
module
expr
item
attribute
module
rec
module
name
module
type
module
expr
item
attribute
and
module
name
module
type
module
expr
item
attribute
specification
val
value
name
typexpr
item
attribute
external
value
name
typexpr
external
declaration
item
attribute
type
definition
exception
constr
decl
item
attribute
class
specification
classtype
definition
module
module
name
module
type
item
attribute
module
module
name
module
name
module
type
module
type
item
attribute
module
type
modtype
name
item
attribute
module
type
modtype
name
module
type
item
attribute
open
module
path
item
attribute
include
module
type
item
attribute
class
field
spec
class
field
spec
item
attribute
class
field
class
field
item
attribute
end
syntax
A
third
form
of
attributes
appears
as
stand
alone
structure
or
signature
items
in
the
module
or
class
sub
languages
They
are
not
attached
to
any
specific
node
in
the
syntax
tree
begin
syntax
floating
attribute
attr
id
attr
payload
definition
floating
attribute
specification
floating
attribute
class
field
spec
floating
attribute
class
field
floating
attribute
end
syntax
Note
contrary
to
what
the
grammar
above
describes
item
attributes
cannot
be
attached
to
these
floating
attributes
in
class
field
spec
and
class
field
It
is
also
possible
to
specify
attributes
using
an
infix
syntax
For
instance
begin
verbatim
let
foo
x
2
in
x
1
let
x
2
foo
in
x
1
begin
foo
bar
x
end
begin
end
foo
bar
x
module
foo
M
module
M
foo
type
foo
t
T
type
t
T
foo
method
foo
m
method
m
foo
end
verbatim
For
let
the
attributes
are
applied
to
each
bindings
begin
verbatim
let
foo
x
2
and
y
3
in
x
y
let
x
2
foo
and
y
3
in
x
y
let
foo
x
2
and
bar
y
3
in
x
y
let
x
2
foo
and
y
3
bar
in
x
y
end
verbatim
subsection
ss
builtin
attributes
Built
in
attributes
Some
attributes
are
understood
by
the
compiler
begin
itemize
item
ocaml
warning
or
warning
with
a
string
literal
payload
This
can
be
used
as
floating
attributes
in
a
signature
structure
object
type
The
string
is
parsed
and
has
the
same
effect
as
the
w
command
line
option
in
the
scope
between
the
attribute
and
the
end
of
the
current
signature
structure
object
type
The
attribute
can
also
be
attached
to
any
kind
of
syntactic
item
which
support
attributes
such
as
an
expression
or
a
type
expression
in
which
case
its
scope
is
limited
to
that
item
Note
that
it
is
not
well
defined
which
scope
is
used
for
a
specific
warning
This
is
implementation
dependent
and
can
change
between
versions
Some
warnings
are
even
completely
outside
the
control
of
ocaml
warning
for
instance
warnings
1
2
14
29
and
50
item
ocaml
warnerror
or
warnerror
with
a
string
literal
payload
Same
as
ocaml
warning
for
the
warn
error
command
line
option
item
ocaml
alert
or
alert
see
section
ref
s
alerts
item
ocaml
deprecated
or
deprecated
alias
for
the
deprecated
alert
see
section
ref
s
alerts
item
ocaml
deprecated
mutable
or
deprecated
mutable
Can
be
applied
to
a
mutable
record
label
If
the
label
is
later
used
to
modify
the
field
with
expr
l
expr
the
deprecated
alert
will
be
triggered
If
the
payload
of
the
attribute
is
a
string
literal
the
alert
message
includes
this
text
item
ocaml
ppwarning
or
ppwarning
in
any
context
with
a
string
literal
payload
The
text
is
reported
as
warning
22
by
the
compiler
currently
the
warning
location
is
the
location
of
the
string
payload
This
is
mostly
useful
for
preprocessors
which
need
to
communicate
warnings
to
the
user
This
could
also
be
used
to
mark
explicitly
some
code
location
for
further
inspection
item
ocaml
warn
on
literal
pattern
or
warn
on
literal
pattern
annotate
constructors
in
type
definition
A
warning
52
is
then
emitted
when
this
constructor
is
pattern
matched
with
a
constant
literal
as
argument
This
attribute
denotes
constructors
whose
argument
is
purely
informative
and
may
change
in
the
future
Therefore
pattern
matching
on
this
argument
with
a
constant
literal
is
unreliable
For
instance
all
built
in
exception
constructors
are
marked
as
warn
on
literal
pattern
Note
that
due
to
an
implementation
limitation
this
warning
52
is
only
triggered
for
single
argument
constructor
item
ocaml
tailcall
or
tailcall
can
be
applied
to
function
application
in
order
to
check
that
the
call
is
tailcall
optimized
If
it
it
not
the
case
a
warning
51
is
emitted
item
ocaml
inline
or
inline
take
either
never
always
or
nothing
as
payload
on
a
function
or
functor
definition
If
no
payload
is
provided
the
default
value
is
always
This
payload
controls
when
applications
of
the
annotated
functions
should
be
inlined
item
ocaml
inlined
or
inlined
can
be
applied
to
any
function
or
functor
application
to
check
that
the
call
is
inlined
by
the
compiler
If
the
call
is
not
inlined
a
warning
55
is
emitted
item
ocaml
noalloc
ocaml
unboxed
and
ocaml
untagged
or
noalloc
unboxed
and
untagged
can
be
used
on
external
definitions
to
obtain
finer
control
over
the
C
to
OCaml
interface
See
ref
s
C
cheaper
call
for
more
details
item
ocaml
immediate
or
immediate
applied
on
an
abstract
type
mark
the
type
as
having
a
non
pointer
implementation
e
g
int
bool
char
or
enumerated
types
Mutation
of
these
immediate
types
does
not
activate
the
garbage
collector
s
write
barrier
which
can
significantly
boost
performance
in
programs
relying
heavily
on
mutable
state
item
ocaml
immediate64
or
immediate64
applied
on
an
abstract
type
mark
the
type
as
having
a
non
pointer
implementation
on
64
bit
platforms
No
assumption
is
made
on
other
platforms
In
order
to
produce
a
type
with
the
immediate64
attribute
one
must
use
Sys
Immediate64
Make
functor
item
ocaml
unboxed
or
unboxed
can
be
used
on
a
type
definition
if
the
type
is
a
single
field
record
or
a
concrete
type
with
a
single
constructor
that
has
a
single
argument
It
tells
the
compiler
to
optimize
the
representation
of
the
type
by
removing
the
block
that
represents
the
record
or
the
constructor
i
e
a
value
of
this
type
is
physically
equal
to
its
argument
In
the
case
of
GADTs
an
additional
restriction
applies
the
argument
must
not
be
an
existential
variable
represented
by
an
existential
type
variable
or
an
abstract
type
constructor
applied
to
an
existential
type
variable
item
ocaml
boxed
or
boxed
can
be
used
on
type
definitions
to
mean
the
opposite
of
ocaml
unboxed
keep
the
unoptimized
representation
of
the
type
When
there
is
no
annotation
the
default
is
currently
boxed
but
it
may
change
in
the
future
item
ocaml
local
or
local
take
either
never
always
maybe
or
nothing
as
payload
on
a
function
definition
If
no
payload
is
provided
the
default
is
always
The
attribute
controls
an
optimization
which
consists
in
compiling
a
function
into
a
static
continuation
Contrary
to
inlining
this
optimization
does
not
duplicate
the
function
s
body
This
is
possible
when
all
references
to
the
function
are
full
applications
all
sharing
the
same
continuation
for
instance
the
returned
value
of
several
branches
of
a
pattern
matching
never
disables
the
optimization
always
asserts
that
the
optimization
applies
otherwise
a
warning
55
is
emitted
and
maybe
lets
the
optimization
apply
when
possible
this
is
the
default
behavior
when
the
attribute
is
not
specified
The
optimization
is
implicitly
disabled
when
using
the
bytecode
compiler
in
debug
mode
g
and
for
functions
marked
with
an
ocaml
inline
always
or
ocaml
unrolled
attribute
which
supersede
ocaml
local
item
ocaml
poll
or
poll
with
an
error
payload
on
a
function
definition
emits
an
error
whenever
the
compiler
inserts
a
runtime
polling
point
in
the
body
of
the
annotated
function
item
ocaml
remove
aliases
or
remove
aliases
defined
on
either
a
module
type
of
signature
expression
or
with
module
constraint
instructs
the
typechecker
to
drop
module
aliases
in
the
resulting
signature
item
ocaml
atomic
or
atomic
on
a
record
field
definition
marks
this
record
field
as
atomic
See
ref
s
atomic
record
fields
for
more
details
end
itemize
begin
caml
example
verbatim
module
X
struct
warning
9
locally
enable
warning
9
in
this
structure
ellipsis
end
deprecated
Please
use
module
Y
instead
let
x
begin
warning
9
ellipsis
end
type
t
A
B
deprecated
Please
use
type
s
instead
end
caml
example
begin
caml
example
verbatim
warning
22
let
fires
warning
22
x
assert
x
0
ppwarning
TODO
remove
this
later
end
caml
example
begin
caml
example
verbatim
warning
51
let
rec
is
a
tail
call
function
q
is
a
tail
call
tailcall
q
let
rec
not
a
tail
call
function
x
q
x
not
a
tail
call
tailcall
q
end
caml
example
begin
caml
example
verbatim
let
f
x
x
inline
let
f
inlined
end
caml
example
begin
caml
example
verbatim
type
fragile
Int
of
int
warn
on
literal
pattern
String
of
string
warn
on
literal
pattern
end
caml
example
begin
caml
example
verbatim
warning
52
let
fragile
match
1
function
Int
0
end
caml
example
begin
caml
example
verbatim
warning
52
let
fragile
match
2
function
String
constant
end
caml
example
begin
caml
example
verbatim
module
Immediate
sig
type
t
immediate
val
x
t
ref
end
struct
type
t
A
B
let
x
ref
A
end
end
caml
example
begin
caml
example
verbatim
module
Int
or
int64
sig
type
t
immediate64
val
zero
t
val
one
t
val
add
t
t
t
end
struct
include
Sys
Immediate64
Make
Int
Int64
module
type
S
sig
val
zero
t
val
one
t
val
add
t
t
t
end
let
impl
module
S
match
repr
with
Immediate
module
Int
S
Non
immediate
module
Int64
S
include
val
impl
S
end
end
caml
example
section
s
recursive
modules
Recursive
modules
HEVEA
cutname
recursivemodules
html
ikwd
module
texttt
module
ikwd
and
texttt
and
Introduced
in
Objective
Caml
3
07
TODO
relaxed
syntax
begin
syntax
definition
module
rec
module
name
module
type
module
expr
and
module
name
module
type
module
expr
specification
module
rec
module
name
module
type
and
module
name
module
type
end
syntax
Recursive
module
definitions
introduced
by
the
module
rec
ldots
and
ldots
construction
generalize
regular
module
definitions
module
module
name
module
expr
and
module
specifications
module
module
name
module
type
by
allowing
the
defining
module
expr
and
the
module
type
to
refer
recursively
to
the
module
identifiers
being
defined
A
typical
example
of
a
recursive
module
definition
is
begin
caml
example
verbatim
module
rec
A
sig
type
t
Leaf
of
string
Node
of
ASet
t
val
compare
t
t
int
end
struct
type
t
Leaf
of
string
Node
of
ASet
t
let
compare
t1
t2
match
t1
t2
with
Leaf
s1
Leaf
s2
Stdlib
compare
s1
s2
Leaf
Node
1
Node
Leaf
1
Node
n1
Node
n2
ASet
compare
n1
n2
end
and
ASet
Set
S
with
type
elt
A
t
Set
Make
A
end
caml
example
It
can
be
given
the
following
specification
begin
caml
example
signature
module
rec
A
sig
type
t
Leaf
of
string
Node
of
ASet
t
val
compare
t
t
int
end
and
ASet
Set
S
with
type
elt
A
t
end
caml
example
This
is
an
experimental
extension
of
OCaml
the
class
of
recursive
definitions
accepted
as
well
as
its
dynamic
semantics
are
not
final
and
subject
to
change
in
future
releases
Currently
the
compiler
requires
that
all
dependency
cycles
between
the
recursively
defined
module
identifiers
go
through
at
least
one
safe
module
A
module
is
safe
if
all
value
definitions
that
it
contains
have
function
types
typexpr
1
typexpr
2
Evaluation
of
a
recursive
module
definition
proceeds
by
building
initial
values
for
the
safe
modules
involved
binding
all
functional
values
to
fun
raise
Undefined
recursive
module
The
defining
module
expressions
are
then
evaluated
and
the
initial
values
for
the
safe
modules
are
replaced
by
the
values
thus
computed
If
a
function
component
of
a
safe
module
is
applied
during
this
computation
which
corresponds
to
an
ill
founded
recursive
definition
the
Undefined
recursive
module
exception
is
raised
at
runtime
begin
caml
example
verbatim
module
rec
M
sig
val
f
unit
int
end
struct
let
f
N
x
end
and
N
sig
val
x
int
end
struct
let
x
M
f
end
end
caml
example
If
there
are
no
safe
modules
along
a
dependency
cycle
an
error
is
raised
begin
caml
example
verbatim
error
module
rec
M
sig
val
x
int
end
struct
let
x
N
y
end
and
N
sig
val
x
int
val
y
int
end
struct
let
x
M
x
let
y
0
end
end
caml
example
Note
that
in
the
specification
case
the
module
type
s
must
be
parenthesized
if
they
use
the
with
mod
constraint
construct
section
s
gadts
Generalized
algebraic
datatypes
HEVEA
cutname
gadts
html
ikwd
type
texttt
type
ikwd
match
texttt
match
Generalized
algebraic
datatypes
or
GADTs
extend
usual
sum
types
in
two
ways
constraints
on
type
parameters
may
change
depending
on
the
value
constructor
and
some
type
variables
may
be
existentially
quantified
They
are
described
in
chapter
ref
c
gadts
tutorial
Introduced
in
OCaml
4
00
begin
syntax
constr
decl
constr
name
constr
args
typexpr
type
param
variance
end
syntax
Refutation
cases
Introduced
in
OCaml
4
03
begin
syntax
matching
case
pattern
when
expr
expr
pattern
end
syntax
Explicit
naming
of
existentials
Introduced
in
OCaml
4
13
0
begin
syntax
pattern
constr
type
typeconstr
name
pattern
end
syntax
section
s
binding
operators
Binding
operators
HEVEA
cutname
bindingops
html
Introduced
in
4
08
0
begin
syntax
let
operator
let
core
operator
char
dot
operator
char
and
operator
and
core
operator
char
dot
operator
char
operator
name
let
operator
and
operator
letop
binding
pattern
expr
value
name
expr
let
operator
letop
binding
and
operator
letop
binding
in
expr
end
syntax
Binding
operators
offer
syntactic
sugar
to
expose
library
functions
under
a
variant
of
the
familiar
syntax
of
standard
keywords
Currently
supported
binding
operators
are
let
op
and
and
op
where
op
is
an
operator
symbol
for
example
and
Binding
operators
were
introduced
to
offer
convenient
syntax
for
working
with
monads
and
applicative
functors
for
those
we
propose
conventions
using
operators
and
respectively
They
may
be
used
for
other
purposes
but
one
should
keep
in
mind
that
each
new
unfamiliar
notation
introduced
makes
programs
harder
to
understand
for
non
experts
We
expect
that
new
conventions
will
be
developed
over
time
on
other
families
of
operator
subsection
ss
letop
examples
Examples
Users
can
define
em
let
operators
begin
caml
example
verbatim
let
let
o
f
match
o
with
None
None
Some
x
f
x
let
return
x
Some
x
end
caml
example
and
then
apply
them
using
this
convenient
syntax
begin
caml
example
verbatim
let
find
and
sum
tbl
k1
k2
let
x1
Hashtbl
find
opt
tbl
k1
in
let
x2
Hashtbl
find
opt
tbl
k2
in
return
x1
x2
end
caml
example
which
is
equivalent
to
this
expanded
form
begin
caml
example
verbatim
let
find
and
sum
tbl
k1
k2
let
Hashtbl
find
opt
tbl
k1
fun
x1
let
Hashtbl
find
opt
tbl
k2
fun
x2
return
x1
x2
end
caml
example
Users
can
also
define
em
and
operators
begin
caml
example
verbatim
module
ZipSeq
struct
type
a
t
a
Seq
t
open
Seq
let
rec
return
x
fun
Cons
x
return
x
let
rec
prod
a
b
fun
match
a
b
with
Nil
Nil
Nil
Cons
x
a
Cons
y
b
Cons
x
y
prod
a
b
let
let
f
s
map
s
f
let
and
a
b
prod
a
b
end
end
caml
example
to
support
the
syntax
begin
caml
example
verbatim
open
ZipSeq
let
sum3
z1
z2
z3
let
x1
z1
and
x2
z2
and
x3
z3
in
x1
x2
x3
end
caml
example
which
is
equivalent
to
this
expanded
form
begin
caml
example
verbatim
open
ZipSeq
let
sum3
z1
z2
z3
let
and
and
z1
z2
z3
fun
x1
x2
x3
x1
x2
x3
end
caml
example
subsection
ss
letops
conventions
Conventions
An
applicative
functor
should
provide
a
module
implementing
the
following
interface
begin
caml
example
verbatim
module
type
Applicative
syntax
sig
type
a
t
val
let
a
t
a
b
b
t
val
and
a
t
b
t
a
b
t
end
end
caml
example
where
let
is
bound
to
the
map
operation
and
and
is
bound
to
the
monoidal
product
operation
A
monad
should
provide
a
module
implementing
the
following
interface
begin
caml
example
verbatim
module
type
Monad
syntax
sig
include
Applicative
syntax
val
let
a
t
a
b
t
b
t
val
and
a
t
b
t
a
b
t
end
end
caml
example
where
let
is
bound
to
the
bind
operation
and
and
is
also
bound
to
the
monoidal
product
operation
subsection
ss
letop
rules
General
desugaring
rules
The
form
begin
verbatim
let
op0
x1
e1
and
op1
x2
e2
and
op2
x3
e3
in
e
end
verbatim
desugars
into
begin
verbatim
let
op0
and
op2
and
op1
e1
e2
e3
fun
x1
x2
x3
e
end
verbatim
This
of
course
works
for
any
number
of
nested
and
operators
One
can
express
the
general
rule
by
repeating
the
following
simplification
steps
begin
itemize
item
The
first
and
operator
in
begin
center
let
op0
x1
e1
and
op1
x2
e2
and
in
e
end
center
can
be
desugared
into
a
function
application
begin
center
let
op0
x1
x2
and
op1
e1
e2
and
in
e
end
center
item
Once
all
and
operators
have
been
simplified
away
the
let
operator
in
begin
center
let
op
x1
e1
in
e
end
center
can
be
desugared
into
an
application
begin
center
let
op
e1
fun
x1
e
end
center
end
itemize
Note
that
the
grammar
allows
mixing
different
operator
symbols
in
the
same
binding
op0
op1
op2
may
be
distinct
but
we
strongly
recommend
APIs
where
let
operators
and
and
operators
working
together
use
the
same
symbol
subsection
ss
letops
punning
Short
notation
for
variable
bindings
let
punning
Introduced
in
4
13
0
When
the
expression
being
bound
is
a
variable
it
can
be
convenient
to
use
the
shorthand
notation
let
x
in
which
expands
to
let
x
x
in
This
notation
also
known
as
let
punning
allows
the
sum3
function
above
can
be
written
more
concisely
as
begin
caml
example
verbatim
open
ZipSeq
let
sum3
z1
z2
z3
let
z1
and
z2
and
z3
in
z1
z2
z3
end
caml
example
This
notation
is
also
supported
for
extension
nodes
expanding
let
foo
x
in
to
let
foo
x
x
in
However
to
avoid
confusion
this
notation
is
not
supported
for
plain
let
bindings
section
s
index
operators
Extended
indexing
operators
HEVEA
cutname
indexops
html
Introduced
in
4
06
begin
syntax
dot
ext
dot
operator
char
operator
char
dot
operator
char
core
operator
char
expr
expr
module
path
dot
ext
expr
expr
expr
expr
operator
name
dot
ext
end
syntax
This
extension
provides
syntactic
sugar
for
getting
and
setting
elements
for
user
defined
indexed
types
For
instance
we
can
define
python
like
dictionaries
with
begin
caml
example
verbatim
module
Dict
struct
include
Hashtbl
let
tabl
index
find
tabl
index
let
tabl
index
value
add
tabl
index
value
end
let
dict
let
dict
Dict
create
10
in
let
dict
Dict
one
1
let
open
Dict
in
dict
two
2
in
dict
end
caml
example
begin
caml
example
toplevel
dict
Dict
one
let
open
Dict
in
dict
two
end
caml
example
subsection
ss
multiindexing
Multi
index
notation
begin
syntax
expr
expr
module
path
dot
ext
expr
expr
expr
expr
module
path
dot
ext
expr
expr
expr
expr
module
path
dot
ext
expr
expr
expr
operator
name
dot
ext
end
syntax
Multi
index
are
also
supported
through
a
second
variant
of
indexing
operators
begin
caml
example
verbatim
let
Bigarray
Genarray
get
let
Bigarray
Genarray
get
let
Bigarray
Genarray
get
end
caml
example
which
is
called
when
an
index
literals
contain
a
semicolon
separated
list
of
expressions
with
two
and
more
elements
begin
caml
example
verbatim
let
sum
x
y
x
1
2
3
y
1
2
is
equivalent
to
let
sum
x
y
x
1
2
3
y
1
2
end
caml
example
In
particular
this
multi
index
notation
makes
it
possible
to
uniformly
handle
indexing
Genarray
and
other
implementations
of
multidimensional
arrays
begin
caml
example
verbatim
module
A
Bigarray
Genarray
let
A
get
let
A
set
let
a
k
A
get
a
k
let
a
k
x
A
set
a
k
x
let
syntax
compare
vec
mat
t3
t4
vec
0
A
get
vec
0
mat
0
0
A
get
mat
0
0
t3
0
0
0
A
get
t3
0
0
0
t4
0
0
0
0
t4
0
0
0
0
end
caml
example
Beware
that
the
differentiation
between
the
multi
index
and
single
index
operators
is
purely
syntactic
multi
index
operators
are
restricted
to
index
expressions
that
contain
one
or
more
semicolons
For
instance
begin
caml
example
verbatim
let
pair
vec
mat
vec
0
mat
0
0
end
caml
example
is
equivalent
to
begin
caml
example
verbatim
let
pair
vec
mat
vec
0
mat
0
0
end
caml
example
Notice
that
in
the
vec
case
we
are
calling
the
single
index
operator
and
not
the
multi
index
variant
For
this
reason
it
is
expected
that
most
users
of
multi
index
operators
will
need
to
define
conjointly
a
single
index
variant
begin
caml
example
verbatim
let
A
get
let
a
k
A
get
a
k
end
caml
example
to
handle
both
cases
uniformly
section
s
module
alias
Type
level
module
aliases
HEVEA
cutname
modulealias
html
ikwd
module
texttt
module
Introduced
in
OCaml
4
02
begin
syntax
specification
module
module
name
module
path
end
syntax
The
above
specification
inside
a
signature
only
matches
a
module
definition
equal
to
module
path
Conversely
a
type
level
module
alias
can
be
matched
by
itself
or
by
any
supertype
of
the
type
of
the
module
it
references
There
are
several
restrictions
on
module
path
begin
enumerate
item
it
should
be
of
the
form
M
0
M
1
M
n
em
i
e
without
functor
applications
item
inside
the
body
of
a
functor
M
0
should
not
be
one
of
the
functor
parameters
item
inside
a
recursive
module
definition
M
0
should
not
be
one
of
the
recursively
defined
modules
end
enumerate
Such
specifications
are
also
inferred
Namely
when
P
is
a
path
satisfying
the
above
constraints
begin
caml
eval
module
P
struct
end
end
caml
eval
begin
caml
example
verbatim
module
N
P
end
caml
example
has
type
begin
caml
example
signature
module
N
P
end
caml
example
Type
level
module
aliases
are
used
when
checking
module
path
equalities
That
is
in
a
context
where
module
name
N
is
known
to
be
an
alias
for
P
not
only
these
two
module
paths
check
as
equal
but
F
N
and
F
P
are
also
recognized
as
equal
In
the
default
compilation
mode
this
is
the
only
difference
with
the
previous
approach
of
module
aliases
having
just
the
same
module
type
as
the
module
they
reference
When
the
compiler
flag
no
alias
deps
is
enabled
type
level
module
aliases
are
also
exploited
to
avoid
introducing
dependencies
between
compilation
units
Namely
a
module
alias
referring
to
a
module
inside
another
compilation
unit
does
not
introduce
a
link
time
dependency
on
that
compilation
unit
as
long
as
it
is
not
dereferenced
it
still
introduces
a
compile
time
dependency
if
the
interface
needs
to
be
read
em
i
e
if
the
module
is
a
submodule
of
the
compilation
unit
or
if
some
type
components
are
referred
to
Additionally
accessing
a
module
alias
introduces
a
link
time
dependency
on
the
compilation
unit
containing
the
module
referenced
by
the
alias
rather
than
the
compilation
unit
containing
the
alias
Note
that
these
differences
in
link
time
behavior
may
be
incompatible
with
the
previous
behavior
as
some
compilation
units
might
not
be
extracted
from
libraries
and
their
side
effects
ignored
These
weakened
dependencies
make
possible
to
use
module
aliases
in
place
of
the
pack
mechanism
Suppose
that
you
have
a
library
Mylib
composed
of
modules
A
and
B
Using
pack
one
would
issue
the
command
line
begin
verbatim
ocamlc
pack
a
cmo
b
cmo
o
mylib
cmo
end
verbatim
and
as
a
result
obtain
a
Mylib
compilation
unit
containing
physically
A
and
B
as
submodules
and
with
no
dependencies
on
their
respective
compilation
units
Here
is
a
concrete
example
of
a
possible
alternative
approach
begin
enumerate
item
Rename
the
files
containing
A
and
B
to
Mylib
A
and
Mylib
B
item
Create
a
packing
interface
Mylib
ml
containing
the
following
lines
begin
verbatim
module
A
Mylib
A
module
B
Mylib
B
end
verbatim
item
Compile
Mylib
ml
using
no
alias
deps
and
the
other
files
using
no
alias
deps
and
open
Mylib
the
last
one
is
equivalent
to
adding
the
line
open
Mylib
at
the
top
of
each
file
begin
verbatim
ocamlc
c
no
alias
deps
Mylib
ml
ocamlc
c
no
alias
deps
open
Mylib
Mylib
mli
Mylib
ml
end
verbatim
item
Finally
create
a
library
containing
all
the
compilation
units
and
export
all
the
compiled
interfaces
begin
verbatim
ocamlc
a
Mylib
cmo
o
Mylib
cma
end
verbatim
end
enumerate
This
approach
lets
you
access
A
and
B
directly
inside
the
library
and
as
Mylib
A
and
Mylib
B
from
outside
It
also
has
the
advantage
that
Mylib
is
no
longer
monolithic
if
you
use
Mylib
A
only
Mylib
A
will
be
linked
in
not
Mylib
B
Note
that
in
the
above
Mylib
cmo
is
actually
empty
and
one
could
name
the
interface
Mylib
mli
but
this
would
require
that
all
clients
are
compiled
with
the
no
alias
deps
flag
Note
the
use
of
double
underscores
in
Mylib
A
and
Mylib
B
These
were
chosen
on
purpose
the
compiler
uses
the
following
heuristic
when
printing
paths
given
a
path
Lib
fooBar
if
Lib
FooBar
exists
and
is
an
alias
for
Lib
fooBar
then
the
compiler
will
always
display
Lib
FooBar
instead
of
Lib
fooBar
This
way
the
long
Mylib
names
stay
hidden
and
all
the
user
sees
is
the
nicer
dot
names
This
is
how
the
OCaml
standard
library
is
compiled
section
s
alerts
Alerts
HEVEA
cutname
alerts
html
Introduced
in
4
08
Since
OCaml
4
08
it
is
possible
to
mark
components
such
as
value
or
type
declarations
in
signatures
with
alerts
that
will
be
reported
when
those
components
are
referenced
This
generalizes
the
notion
of
deprecated
components
which
were
previously
reported
as
warning
3
Those
alerts
can
be
used
for
instance
to
report
usage
of
unsafe
features
or
of
features
which
are
only
available
on
some
platforms
etc
Alert
categories
are
identified
by
a
symbolic
identifier
a
lowercase
identifier
following
the
usual
lexical
rules
and
an
optional
message
The
identifier
is
used
to
control
which
alerts
are
enabled
and
which
ones
are
turned
into
fatal
errors
The
message
is
reported
to
the
user
when
the
alert
is
triggered
i
e
when
the
marked
component
is
referenced
The
ocaml
alert
or
alert
attribute
serves
two
purposes
i
to
mark
component
with
an
alert
to
be
triggered
when
the
component
is
referenced
and
ii
to
control
which
alerts
are
enabled
subsection
ss
alert
marking
Marking
a
component
When
marking
a
component
the
attribute
takes
an
identifier
possibly
followed
by
a
message
Here
is
an
example
of
a
value
declaration
marked
with
an
alert
begin
caml
example
signature
module
U
sig
val
fork
unit
bool
alert
unix
This
function
is
only
available
under
Unix
end
end
caml
example
Here
unix
is
the
identifier
for
the
alert
If
this
alert
category
is
enabled
any
reference
to
U
fork
will
produce
a
message
at
compile
time
which
can
be
turned
or
not
into
a
fatal
error
For
other
structure
or
signature
components
the
syntax
is
as
follows
begin
caml
example
verbatim
module
type
Sig
sig
val
v
int
alert
name
end
let
v
alert
name
1
let
A
v
alert
name
A
1
external
e
int
int
c
function
alert
name
type
t1
A
B
alert
name
N
B
this
only
alerts
on
use
of
t1
not
uses
of
the
constructors
A
and
B
So
let
x
A
wouldn
t
alert
so
long
as
you
don
t
write
down
its
type
type
t2
A
B
alert
name
Alerts
on
use
of
B
but
not
A
nor
t2
Note
the
single
type
t3
a
int
b
int
alert
name
Alerts
on
use
of
b
but
not
a
nor
t3
Note
the
single
exception
E
of
int
alert
name
Alerts
on
use
of
E
Note
the
single
module
M
struct
end
alert
name
module
type
S
sig
end
alert
name
class
c1
object
end
alert
name
class
type
c2
object
end
alert
name
end
caml
example
When
the
typer
coerces
a
signature
with
alerts
to
a
signature
with
different
alerts
begin
caml
example
verbatim
module
M
sig
val
x
int
val
y
int
alert
name
end
struct
let
x
alert
name
0
let
y
1
end
end
caml
example
any
alert
that
isn
t
passed
through
i
e
the
alert
on
x
here
gets
triggered
Finally
to
alert
when
the
module
corresponding
to
a
file
is
referenced
a
floating
attribute
can
be
written
at
the
top
of
the
mli
file
i
e
before
any
other
non
attribute
item
or
the
top
of
the
ml
file
if
there
is
no
mli
file
begin
caml
example
verbatim
alert
unsafe
This
module
is
unsafe
end
caml
example
subsection
ss
control
Controlling
which
alerts
are
enabled
Controlling
which
alerts
are
enabled
and
whether
they
are
turned
into
fatal
errors
is
done
either
through
the
compiler
s
command
line
option
alert
spec
or
locally
in
the
code
through
the
alert
or
ocaml
alert
attribute
taking
a
single
string
payload
spec
In
both
cases
the
syntax
for
spec
is
a
concatenation
of
items
of
the
form
begin
itemize
item
id
enables
alert
id
item
id
disables
alert
id
item
id
turns
alert
id
into
a
fatal
error
item
id
turns
alert
id
into
non
fatal
mode
item
id
equivalent
to
id
id
enables
id
and
turns
it
into
a
fatal
error
end
itemize
As
a
special
case
if
id
is
all
it
stands
for
all
alerts
Here
are
some
examples
begin
verbatim
Disable
all
alerts
reenables
just
unix
as
a
soft
alert
and
window
as
a
fatal
error
for
the
rest
of
the
current
structure
alert
all
all
unix
window
let
x
Locally
disable
the
window
alert
begin
alert
window
end
end
verbatim
subsection
ss
alert
deprecated
Shorthand
syntax
for
deprecation
Before
OCaml
4
08
there
was
support
for
a
single
kind
of
deprecation
alert
It
is
now
known
as
the
deprecated
alert
but
legacy
attributes
to
trigger
it
and
the
legacy
ways
to
control
it
as
warning
3
are
still
supported
For
instance
passing
w
3
on
the
command
line
is
equivalent
to
alert
deprecated
and
begin
caml
example
signature
val
x
int
ocaml
deprecated
Please
do
something
else
end
caml
example
is
equivalent
to
begin
caml
example
signature
val
x
int
ocaml
alert
deprecated
Please
do
something
else
end
caml
example
section
s
bigarray
access
Syntax
for
Bigarray
access
HEVEA
cutname
bigarray
html
Introduced
in
Objective
Caml
3
00
begin
syntax
expr
expr
expr
expr
expr
expr
expr
expr
end
syntax
This
extension
provides
syntactic
sugar
for
getting
and
setting
elements
in
the
arrays
provided
by
the
stdmoduleref
Bigarray
module
The
short
expressions
are
translated
into
calls
to
functions
of
the
Bigarray
module
as
described
in
the
following
table
begin
tableau
l
l
expression
translation
entree
expr
0
expr
1
Bigarray
Array1
get
expr
0
expr
1
entree
expr
0
expr
1
expr
Bigarray
Array1
set
expr
0
expr
1
expr
entree
expr
0
expr
1
expr
2
Bigarray
Array2
get
expr
0
expr
1
expr
2
entree
expr
0
expr
1
expr
2
expr
Bigarray
Array2
set
expr
0
expr
1
expr
2
expr
entree
expr
0
expr
1
expr
2
expr
3
Bigarray
Array3
get
expr
0
expr
1
expr
2
expr
3
entree
expr
0
expr
1
expr
2
expr
3
expr
Bigarray
Array3
set
expr
0
expr
1
expr
2
expr
3
expr
entree
expr
0
expr
1
ldots
expr
n
Bigarray
Genarray
get
expr
0
expr
1
ldots
expr
n
entree
expr
0
expr
1
ldots
expr
n
expr
Bigarray
Genarray
set
expr
0
expr
1
ldots
expr
n
expr
end
tableau
The
last
two
entries
are
valid
for
any
n
3
section
s
signature
substitution
Substituting
inside
a
signature
HEVEA
cutname
signaturesubstitution
html
ikwd
with
texttt
with
ikwd
module
texttt
module
ikwd
type
texttt
type
subsection
ss
destructive
substitution
Destructive
substitutions
Introduced
in
OCaml
3
12
generalized
in
4
06
begin
syntax
mod
constraint
type
type
params
typeconstr
name
typexpr
module
module
path
extended
module
path
end
syntax
A
destructive
substitution
with
behaves
essentially
like
normal
signature
constraints
with
but
it
additionally
removes
the
redefined
type
or
module
from
the
signature
Prior
to
OCaml
4
06
there
were
a
number
of
restrictions
one
could
only
remove
types
and
modules
at
the
outermost
level
not
inside
submodules
and
in
the
case
of
with
type
the
definition
had
to
be
another
type
constructor
with
the
same
type
parameters
A
natural
application
of
destructive
substitution
is
merging
two
signatures
sharing
a
type
name
begin
caml
example
verbatim
module
type
Printable
sig
type
t
val
print
Format
formatter
t
unit
end
module
type
Comparable
sig
type
t
val
compare
t
t
int
end
module
type
PrintableComparable
sig
include
Printable
include
Comparable
with
type
t
t
end
end
caml
example
One
can
also
use
this
to
completely
remove
a
field
begin
caml
example
verbatim
module
type
S
Comparable
with
type
t
int
end
caml
example
or
to
rename
one
begin
caml
example
verbatim
module
type
S
sig
type
u
include
Comparable
with
type
t
u
end
end
caml
example
Note
that
you
can
also
remove
manifest
types
by
substituting
with
the
same
type
begin
caml
example
verbatim
module
type
ComparableInt
Comparable
with
type
t
int
module
type
CompareInt
ComparableInt
with
type
t
int
end
caml
example
subsection
ss
local
substitution
Local
substitution
declarations
Introduced
in
OCaml
4
08
module
type
substitution
introduced
in
4
13
begin
syntax
specification
type
type
subst
and
type
subst
module
module
name
extended
module
path
module
type
module
name
module
type
type
subst
type
params
typeconstr
name
typexpr
type
constraint
end
syntax
Local
substitutions
behave
like
destructive
substitutions
with
but
instead
of
being
applied
to
a
whole
signature
after
the
fact
they
are
introduced
during
the
specification
of
the
signature
and
will
apply
to
all
the
items
that
follow
This
provides
a
convenient
way
to
introduce
local
names
for
types
and
modules
when
defining
a
signature
begin
caml
example
verbatim
module
type
S
sig
type
t
module
Sub
sig
type
outer
t
type
t
val
to
outer
t
outer
end
end
end
caml
example
Note
that
unlike
type
declarations
type
substitution
declarations
are
not
recursive
so
substitutions
like
the
following
are
rejected
begin
caml
example
toplevel
module
type
S
sig
type
a
poly
list
Cons
of
a
a
poly
list
Nil
end
expect
error
end
caml
example
Local
substitutions
can
also
be
used
to
give
a
local
name
to
a
type
or
a
module
type
introduced
by
a
functor
application
begin
caml
example
toplevel
module
type
F
sig
type
set
Set
Make
Int
t
module
type
Type
sig
type
t
end
module
Nest
Type
sig
module
type
T
Type
end
module
type
T
Nest
Int
T
val
set
set
val
m
module
T
end
end
caml
example
Local
module
type
substitutions
are
subject
to
the
same
limitations
as
module
type
substitutions
see
section
ref
ss
module
type
substitution
subsection
ss
module
type
substitution
Module
type
substitutions
Introduced
in
OCaml
4
13
begin
syntax
mod
constraint
module
type
modtype
path
module
type
module
type
modtype
path
module
type
end
syntax
Module
type
substitution
essentially
behaves
like
type
substitutions
They
are
useful
to
refine
an
abstract
module
type
in
a
signature
into
a
concrete
module
type
begin
caml
example
toplevel
module
type
ENDO
sig
module
type
T
module
F
T
T
end
module
Endo
X
sig
module
type
T
end
ENDO
with
module
type
T
X
T
struct
module
type
T
X
T
module
F
X
T
X
end
end
caml
example
It
is
also
possible
to
substitute
a
concrete
module
type
with
an
equivalent
module
types
begin
caml
example
verbatim
module
type
A
sig
type
x
module
type
R
sig
type
a
A
of
x
type
b
end
end
module
type
S
sig
type
a
A
of
int
type
b
end
module
type
B
A
with
type
x
int
and
module
type
R
S
end
caml
example
However
such
substitutions
are
never
necessary
Destructive
module
type
substitution
removes
the
module
type
substitution
from
the
signature
begin
caml
example
toplevel
module
type
ENDO
ENDO
with
module
type
T
ENDO
end
caml
example
subsubsection
ss
module
type
substitution
limitations
Limitations
If
the
right
hand
side
of
a
module
type
substitution
or
a
local
module
type
substitution
is
not
a
modtype
path
then
the
destructive
substitution
is
only
valid
if
the
left
hand
side
of
the
substitution
is
never
used
as
the
type
of
a
first
class
module
in
the
original
module
type
begin
caml
example
verbatim
error
module
type
T
sig
module
type
S
val
x
module
S
end
module
type
Error
T
with
module
type
S
sig
end
end
caml
example
begin
caml
example
verbatim
error
module
type
T
sig
module
type
S
sig
end
val
x
module
S
end
end
caml
example
section
s
generative
functors
Generative
functors
HEVEA
cutname
generativefunctors
html
Introduced
in
OCaml
4
02
begin
syntax
module
expr
functor
module
expr
module
expr
definition
module
module
name
module
name
module
type
module
type
module
expr
module
type
functor
module
type
specification
module
module
name
module
name
module
type
module
type
end
syntax
A
generative
functor
takes
a
unit
argument
In
order
to
use
it
one
must
necessarily
apply
it
to
this
unit
argument
ensuring
that
all
type
components
in
the
result
of
the
functor
behave
in
a
generative
way
em
i
e
they
are
different
from
types
obtained
by
other
applications
of
the
same
functor
This
is
equivalent
to
taking
an
argument
of
signature
sig
end
and
always
applying
to
struct
end
but
not
to
some
defined
module
in
the
latter
case
applying
twice
to
the
same
module
would
return
identical
types
As
a
side
effect
of
this
generativity
one
is
allowed
to
unpack
first
class
modules
in
the
body
of
generative
functors
section
s
locally
abstract
Locally
abstract
types
HEVEA
cutname
locallyabstract
html
ikwd
type
texttt
type
ikwd
fun
texttt
fun
Introduced
in
OCaml
3
12
short
syntax
added
in
4
03
begin
syntax
parameter
type
typeconstr
name
end
syntax
The
expression
fun
type
typeconstr
name
expr
introduces
a
type
constructor
named
typeconstr
name
which
is
considered
abstract
in
the
scope
of
the
sub
expression
but
then
replaced
by
a
fresh
type
variable
Note
that
contrary
to
what
the
syntax
could
suggest
the
expression
fun
type
typeconstr
name
expr
itself
does
not
suspend
the
evaluation
of
expr
as
a
regular
abstraction
would
The
syntax
has
been
chosen
to
fit
nicely
in
the
context
of
function
declarations
where
it
is
generally
used
It
is
possible
to
freely
mix
regular
function
parameters
with
pseudo
type
parameters
as
in
begin
caml
example
verbatim
let
f
fun
type
t
foo
t
list
assert
false
ellipsis
end
caml
example
and
even
use
the
alternative
syntax
for
declaring
functions
begin
caml
example
verbatim
let
f
type
t
foo
t
list
assert
false
ellipsis
end
caml
example
If
several
locally
abstract
types
need
to
be
introduced
it
is
possible
to
use
the
syntax
fun
type
typeconstr
name
1
ldots
typeconstr
name
n
expr
as
syntactic
sugar
for
fun
type
typeconstr
name
1
ldots
fun
type
typeconstr
name
n
expr
For
instance
begin
caml
example
verbatim
let
f
fun
type
t
u
v
fun
foo
t
u
v
list
assert
false
ellipsis
let
f
type
t
u
v
foo
t
u
v
list
assert
false
ellipsis
end
caml
example
This
construction
is
useful
because
the
type
constructors
it
introduces
can
be
used
in
places
where
a
type
variable
is
not
allowed
For
instance
one
can
use
it
to
define
an
exception
in
a
local
module
within
a
polymorphic
function
begin
caml
example
verbatim
let
f
type
t
let
module
M
struct
exception
E
of
t
end
in
fun
x
M
E
x
function
M
E
x
Some
x
None
end
caml
example
Here
is
another
example
begin
caml
example
verbatim
let
sort
uniq
type
s
cmp
s
s
int
let
module
S
Set
Make
struct
type
t
s
let
compare
cmp
end
in
fun
l
S
elements
List
fold
right
S
add
l
S
empty
end
caml
example
It
is
also
extremely
useful
for
first
class
modules
see
section
ref
s
first
class
modules
and
generalized
algebraic
datatypes
GADTs
see
section
ref
s
gadts
lparagraph
p
polymorpic
locally
abstract
Polymorphic
syntax
Introduced
in
OCaml
4
00
begin
syntax
let
binding
value
name
type
typeconstr
name
typexpr
expr
class
field
method
private
method
name
type
typeconstr
name
typexpr
expr
method
private
method
name
type
typeconstr
name
typexpr
expr
end
syntax
The
type
typeconstr
name
syntax
construction
by
itself
does
not
make
polymorphic
the
type
variable
it
introduces
but
it
can
be
combined
with
explicit
polymorphic
annotations
where
needed
The
above
rule
is
provided
as
syntactic
sugar
to
make
this
easier
begin
caml
example
verbatim
let
rec
f
type
t1
t2
t1
t2
list
t1
assert
false
ellipsis
end
caml
example
noindent
is
automatically
expanded
into
begin
caml
example
verbatim
let
rec
f
t1
t2
t1
t2
list
t1
fun
type
t1
type
t2
assert
false
ellipsis
t1
t2
list
t1
end
caml
example
This
syntax
can
be
very
useful
when
defining
recursive
functions
involving
GADTs
see
the
section
ref
s
gadts
for
a
more
detailed
explanation
The
same
feature
is
provided
for
method
definitions
section
s
extension
syntax
Extension
only
syntax
HEVEA
cutname
extensionsyntax
html
Introduced
in
OCaml
4
02
2
extended
in
4
03
Some
syntactic
constructions
are
accepted
during
parsing
and
rejected
during
type
checking
These
syntactic
constructions
can
therefore
not
be
used
directly
in
vanilla
OCaml
However
ppx
rewriters
and
other
external
tools
can
exploit
this
parser
leniency
to
extend
the
language
with
these
new
syntactic
constructions
by
rewriting
them
to
vanilla
constructions
subsection
ss
extension
operators
Extension
operators
label
s
ext
ops
Introduced
in
OCaml
4
02
2
extended
to
unary
operators
in
OCaml
4
12
0
begin
syntax
infix
symbol
operator
char
operator
char
prefix
symbol
operator
char
operator
char
end
syntax
There
are
two
classes
of
operators
available
for
extensions
infix
operators
with
a
name
starting
with
a
character
and
containing
more
than
one
character
and
unary
operators
with
a
name
starting
with
a
or
character
containing
at
least
one
character
For
instance
begin
caml
example
toplevel
error
let
infix
x
y
x
y
let
prefix
x
x
end
caml
example
Note
that
both
and
must
be
eliminated
by
a
ppx
rewriter
to
make
this
example
valid
subsection
ss
extension
literals
Extension
literals
Introduced
in
OCaml
4
03
begin
syntax
float
literal
0
ldots
9
0
ldots
9
0
ldots
9
e
E
0
ldots
9
0
ldots
9
g
ldots
z
G
ldots
Z
0x
0X
0
ldots
9
A
ldots
F
a
ldots
f
0
ldots
9
A
ldots
F
a
ldots
f
0
ldots
9
A
ldots
F
a
ldots
f
p
P
0
ldots
9
0
ldots
9
g
ldots
z
G
ldots
Z
int
literal
0
ldots
9
0
ldots
9
g
ldots
z
G
ldots
Z
0x
0X
0
ldots
9
A
ldots
F
a
ldots
f
0
ldots
9
A
ldots
F
a
ldots
f
g
ldots
z
G
ldots
Z
0o
0O
0
ldots
7
0
ldots
7
g
ldots
z
G
ldots
Z
0b
0B
0
ldots
1
0
ldots
1
g
ldots
z
G
ldots
Z
end
syntax
Int
and
float
literals
followed
by
an
one
letter
identifier
in
the
range
g
z
G
Z
are
extension
only
literals
section
s
effect
handlers
Effect
handlers
HEVEA
cutname
effects
html
Introduced
in
5
0
The
syntax
support
for
deep
handlers
was
introduced
in
5
3
begin
syntax
pattern
effect
pattern
value
name
end
syntax
Effect
handlers
are
a
mechanism
for
modular
programming
with
user
defined
effects
Effect
handlers
allow
the
programmers
to
describe
textit
computations
that
textit
perform
effectful
textit
operations
whose
meaning
is
described
by
textit
handlers
that
enclose
the
computations
Effect
handlers
are
a
generalization
of
exception
handlers
and
enable
non
local
control
flow
mechanisms
such
as
resumable
exceptions
lightweight
threads
coroutines
generators
and
asynchronous
I
O
to
be
composably
expressed
In
this
tutorial
we
shall
see
how
some
of
these
mechanisms
can
be
built
using
effect
handlers
subsection
s
effects
basics
Basics
To
understand
the
basics
let
us
define
an
effect
that
is
an
operation
that
takes
an
integer
argument
and
returns
an
integer
result
We
name
this
effect
Xchg
begin
caml
example
verbatim
open
Effect
open
Effect
Deep
type
Effect
t
Xchg
int
int
t
let
comp1
perform
Xchg
0
perform
Xchg
1
end
caml
example
We
declare
the
exchange
effect
Xchg
by
extending
the
pre
defined
extensible
variant
type
Effect
t
with
a
new
constructor
Xchg
int
int
t
The
declaration
may
be
intuitively
read
as
the
Xchg
effect
takes
an
integer
parameter
and
when
this
effect
is
performed
it
returns
an
integer
The
computation
comp1
performs
the
effect
twice
using
the
perform
primitive
and
returns
their
sum
We
can
handle
the
Xchg
effect
by
implementing
a
handler
that
always
returns
the
successor
of
the
offered
value
begin
caml
example
verbatim
try
comp1
with
effect
Xchg
n
k
continue
k
n
1
end
caml
example
We
run
the
computation
comp1
under
an
effect
handler
that
handles
the
Xchg
effect
with
a
continuation
bound
to
k
Here
effect
is
a
keyword
which
signifies
that
the
Xchg
n
pattern
matches
effects
and
not
exceptions
As
mentioned
earlier
effect
handlers
are
a
generalization
of
exception
handlers
Similar
to
exception
handlers
when
the
computation
performs
the
Xchg
effect
the
control
jumps
to
the
corresponding
handler
and
unhandled
effects
are
forwarded
to
the
outer
handler
However
unlike
exception
handlers
the
handler
is
also
provided
with
the
delimited
continuation
k
which
represents
the
suspended
computation
between
the
point
of
perform
and
this
handler
The
handler
uses
the
continue
primitive
to
resume
the
suspended
computation
with
the
successor
of
the
offered
value
In
this
example
the
computation
comp1
performs
Xchg
0
and
Xchg
1
and
receives
the
values
1
and
2
from
the
handler
respectively
Hence
the
whole
expression
evaluates
to
3
In
this
example
we
use
the
emph
deep
version
of
the
effect
handlers
here
as
opposed
to
the
emph
shallow
version
A
deep
handler
monitors
a
computation
until
the
computation
terminates
either
normally
or
via
an
exception
and
handles
all
of
the
effects
performed
in
sequence
by
the
computation
In
contrast
a
shallow
handler
monitors
a
computation
until
either
the
computation
terminates
or
the
computation
performs
one
effect
and
it
handles
this
single
effect
only
In
situations
where
they
are
applicable
deep
handlers
are
usually
preferred
An
example
that
utilises
shallow
handlers
is
discussed
later
in
ref
s
effects
shallow
subsection
s
effects
concurrency
Concurrency
The
expressive
power
of
effect
handlers
comes
from
the
delimited
continuation
While
the
previous
example
immediately
resumed
the
computation
the
computation
may
be
resumed
later
running
some
other
computation
in
the
interim
Let
us
extend
the
previous
example
and
implement
message
passing
concurrency
between
two
concurrent
computations
using
the
Xchg
effect
We
call
these
concurrent
computations
textit
tasks
A
task
either
is
in
a
suspended
state
or
is
completed
We
represent
the
task
status
as
follows
begin
caml
example
verbatim
type
a
status
Complete
of
a
Suspended
of
msg
int
cont
int
a
status
continuation
end
caml
example
A
task
either
is
complete
with
a
result
of
type
a
or
is
suspended
with
the
message
msg
to
send
and
the
continuation
cont
The
type
int
a
status
continuation
says
that
the
suspended
delimited
computation
expects
an
int
value
to
resume
and
returns
a
value
of
type
a
status
when
resumed
Next
we
define
a
step
function
that
executes
one
step
of
computation
until
it
completes
or
suspends
begin
caml
example
verbatim
let
step
f
unit
a
a
status
match
f
with
v
Complete
v
effect
Xchg
msg
cont
Suspended
msg
cont
end
caml
example
The
argument
to
the
step
function
f
is
a
computation
that
can
perform
an
Xchg
effect
and
returns
a
result
of
type
a
The
step
function
itself
returns
a
value
of
type
a
status
Similar
to
exception
patterns
in
a
match
with
expression
ref
sss
exception
match
OCaml
also
supports
effect
patterns
Here
we
pattern
match
the
result
of
running
the
computation
f
If
the
computation
returns
with
a
value
v
we
return
Complete
v
Instead
if
the
computation
performs
the
effect
Xchg
msg
with
the
continuation
cont
then
we
return
Suspended
msg
cont
In
this
case
the
continuation
cont
is
not
immediately
invoked
by
the
handler
instead
it
is
stored
in
a
data
structure
for
later
use
Since
the
step
function
handles
the
Xchg
effect
step
f
is
a
computation
that
does
not
perform
the
Xchg
effect
It
may
however
perform
other
effects
Moreover
since
we
are
using
deep
handlers
the
continuation
cont
stored
in
the
status
does
not
perform
the
Xchg
effect
We
can
now
write
a
simple
scheduler
that
runs
a
pair
of
tasks
to
completion
begin
caml
example
verbatim
let
rec
run
both
a
b
match
a
b
with
Complete
va
Complete
vb
va
vb
Suspended
msg
m1
cont
k1
Suspended
msg
m2
cont
k2
run
both
fun
continue
k1
m2
fun
continue
k2
m1
failwith
Improper
synchronization
end
caml
example
Both
of
the
tasks
may
run
to
completion
or
both
may
offer
to
exchange
a
message
In
the
latter
case
each
computation
receives
the
value
offered
by
the
other
computation
The
situation
where
one
computation
offers
an
exchange
while
the
other
computation
terminates
is
regarded
as
a
programmer
error
and
causes
the
handler
to
raise
an
exception
We
can
now
define
a
second
computation
that
also
exchanges
two
messages
begin
caml
example
verbatim
let
comp2
perform
Xchg
21
perform
Xchg
21
end
caml
example
Finally
we
can
run
the
two
computations
together
begin
caml
example
verbatim
run
both
step
comp1
step
comp2
end
caml
example
The
computation
comp1
offers
the
values
0
and
1
and
in
exchange
receives
the
values
21
and
21
which
it
adds
producing
42
The
computation
comp2
offers
the
values
21
and
21
and
in
exchange
receives
the
values
0
and
1
which
it
multiplies
producing
0
The
communication
between
the
two
computations
is
programmed
entirely
inside
run
both
Indeed
the
definitions
of
comp1
and
comp2
alone
do
not
assign
any
meaning
to
the
Xchg
effect
subsection
s
effects
user
threads
User
level
threads
Let
us
extend
the
previous
example
for
an
arbitrary
number
of
tasks
Many
languages
such
as
GHC
Haskell
and
Go
provide
user
level
threads
as
a
primitive
feature
implemented
in
the
runtime
system
With
effect
handlers
user
level
threads
and
their
schedulers
can
be
implemented
in
OCaml
itself
Typically
user
level
threading
systems
provide
a
fork
primitive
to
spawn
off
a
new
concurrent
task
and
a
yield
primitive
to
yield
control
to
some
other
task
Correspondingly
we
shall
declare
two
effects
as
follows
begin
caml
example
verbatim
type
Effect
t
Fork
unit
unit
unit
t
Yield
unit
t
end
caml
example
The
Fork
effect
takes
a
thunk
a
suspended
computation
represented
as
a
function
of
type
unit
unit
and
returns
a
unit
to
the
performer
The
Yield
effect
is
unparameterized
and
returns
a
unit
when
performed
Let
us
consider
that
a
task
performing
an
Xchg
effect
may
match
with
any
other
task
also
offering
to
exchange
a
value
We
shall
also
define
helper
functions
that
simply
perform
these
effects
begin
caml
example
verbatim
let
fork
f
perform
Fork
f
let
yield
perform
Yield
let
xchg
v
perform
Xchg
v
end
caml
example
A
top
level
run
function
defines
the
scheduler
begin
caml
example
verbatim
A
concurrent
round
robin
scheduler
let
run
main
unit
unit
unit
let
exchanger
int
int
unit
continuation
option
ref
ref
None
waiting
exchanger
in
let
run
q
Queue
create
in
scheduler
queue
let
enqueue
k
v
let
task
continue
k
v
in
Queue
push
task
run
q
in
let
dequeue
if
Queue
is
empty
run
q
then
done
else
begin
let
task
Queue
pop
run
q
in
task
end
in
let
rec
spawn
f
unit
unit
unit
match
f
with
dequeue
exception
e
print
endline
Printexc
to
string
e
dequeue
effect
Yield
k
enqueue
k
dequeue
effect
Fork
f
k
enqueue
k
spawn
f
effect
Xchg
n
k
begin
match
exchanger
with
Some
n
k
exchanger
None
enqueue
k
n
continue
k
n
None
exchanger
Some
n
k
dequeue
end
in
spawn
main
end
caml
example
We
use
a
mutable
queue
run
q
to
hold
the
scheduler
queue
The
FIFO
queue
enables
round
robin
scheduling
of
tasks
in
the
scheduler
enqueue
inserts
tasks
into
the
queue
and
dequeue
extracts
tasks
from
the
queue
and
runs
them
The
reference
cell
exchanger
holds
a
suspended
task
offering
to
exchange
a
value
At
any
time
there
is
either
zero
or
one
suspended
task
that
is
offering
an
exchange
The
heavy
lifting
is
done
by
the
spawn
function
The
spawn
function
runs
the
given
computation
f
in
an
effect
handler
If
f
returns
with
unit
value
we
dequeue
and
run
the
next
task
from
the
scheduler
queue
If
the
computation
f
raises
any
exception
we
print
the
exception
to
the
standard
output
and
run
the
next
task
from
the
scheduler
The
computation
f
may
also
perform
effects
If
f
performs
the
Yield
effect
the
current
task
is
suspended
inserted
into
the
queue
of
ready
tasks
and
the
next
task
from
the
scheduler
queue
is
run
If
the
effect
is
Fork
f
then
the
current
task
is
suspended
and
the
new
task
f
is
executed
immediately
via
a
tail
call
to
spawn
f
Note
that
this
choice
to
run
the
new
task
first
is
arbitrary
We
could
very
well
have
chosen
instead
to
insert
the
task
for
f
into
the
ready
queue
and
resumed
k
immediately
If
the
effect
is
Xchg
then
we
first
check
whether
there
is
a
task
waiting
to
exchange
If
so
we
enqueue
the
waiting
task
with
the
current
value
being
offered
and
immediately
resume
the
current
task
with
the
value
being
offered
If
not
we
make
the
current
task
the
waiting
exchanger
and
run
the
next
task
from
the
scheduler
queue
Now
we
can
write
a
concurrent
program
that
utilises
the
newly
defined
operations
begin
caml
example
verbatim
open
Printf
let
run
fun
fork
fun
printf
t1
Sending
0
n
let
v
xchg
0
in
printf
t1
received
d
n
v
fork
fun
printf
t2
Sending
1
n
let
v
xchg
1
in
printf
t2
received
d
n
v
end
caml
example
Observe
that
the
messages
from
the
two
tasks
are
interleaved
Notice
also
that
the
snippet
above
makes
no
reference
to
the
effect
handlers
and
is
in
direct
style
no
monadic
operations
This
example
illustrates
that
with
effect
handlers
the
user
code
in
a
concurrent
program
can
remain
in
simple
direct
style
and
the
use
of
effect
handlers
can
be
fully
contained
within
the
concurrency
library
implementation
subsubsection
s
effects
discontinue
Resuming
with
an
exception
In
addition
to
resuming
a
continuation
with
a
value
effect
handlers
also
permit
resuming
by
raising
an
effect
at
the
point
of
perform
This
is
done
with
the
help
of
the
discontinue
primitive
The
discontinue
primitive
helps
ensure
that
resources
are
always
eventually
deallocated
even
in
the
presence
of
effects
For
example
consider
the
dequeue
operation
in
the
previous
example
reproduced
below
begin
caml
example
verbatim
let
ellipsis
run
q
Queue
create
let
dequeue
if
Queue
is
empty
run
q
then
done
else
Queue
pop
run
q
end
caml
example
If
the
scheduler
queue
is
empty
dequeue
considers
that
the
scheduler
is
done
and
returns
to
the
caller
However
there
may
still
be
a
task
waiting
to
exchange
a
value
stored
in
the
reference
cell
exchanger
which
remains
blocked
forever
If
the
blocked
task
holds
onto
resources
these
resources
are
leaked
For
example
consider
the
following
task
begin
caml
example
verbatim
let
leaky
task
fork
fun
let
oc
open
out
secret
txt
in
Fun
protect
finally
fun
close
out
oc
fun
output
value
oc
xchg
0
end
caml
example
The
task
writes
the
received
message
to
the
file
secret
txt
It
uses
Fun
protect
to
ensure
that
the
output
channel
oc
is
closed
on
both
normal
and
exceptional
return
cases
Unfortunately
this
is
not
sufficient
If
the
exchange
effect
xchg
0
cannot
be
matched
with
an
exchange
effect
performed
by
some
other
thread
then
this
task
remains
blocked
forever
Thus
the
output
channel
oc
is
never
closed
To
avoid
this
problem
one
must
adhere
to
a
simple
discipline
emph
textbf
every
continuation
must
be
eventually
either
continued
or
discontinued
Here
we
use
discontinue
to
ensure
that
the
blocked
task
does
not
remain
blocked
forever
By
discontinuing
this
task
we
force
it
to
terminate
with
an
exception
begin
caml
begin
camlinput
exception
Improper
synchronization
let
dequeue
if
Queue
is
empty
run
q
then
begin
match
exchanger
with
None
done
Some
n
k
exchanger
None
discontinue
k
Improper
synchronization
end
else
Queue
pop
run
q
end
camlinput
end
caml
When
the
scheduler
queue
is
empty
and
there
is
a
blocked
exchanger
thread
the
dequeue
function
discontinues
the
blocked
thread
with
an
Improper
synchronization
exception
This
exception
is
raised
at
the
blocked
xchg
function
call
which
causes
the
finally
block
to
be
run
and
closes
the
output
channel
oc
From
the
point
of
view
of
the
user
it
seems
as
though
the
function
call
xchg
0
raises
the
exception
Improper
synchronization
subsection
s
effects
sequence
Control
inversion
When
it
comes
to
performing
traversals
on
a
data
structure
there
are
two
fundamental
ways
depending
on
whether
the
producer
or
the
consumer
has
the
control
over
the
traversal
For
example
in
List
iter
f
l
the
producer
List
iter
has
the
control
and
pushes
the
element
to
the
consumer
f
who
processes
them
On
the
other
hand
the
stdmoduleref
Seq
module
provides
a
mechanism
similar
to
delayed
lists
where
the
consumer
controls
the
traversal
For
example
Seq
forever
Random
bool
returns
an
infinite
sequence
of
random
bits
where
every
bit
is
produced
on
demand
when
queried
by
the
consumer
Naturally
producers
such
as
List
iter
are
easier
to
write
in
the
former
style
The
latter
style
is
ergonomically
better
for
the
consumer
since
it
is
preferable
and
more
natural
to
be
in
control
To
have
the
best
of
both
worlds
we
would
like
to
write
a
producer
in
the
former
style
and
automatically
convert
it
to
the
latter
style
The
conversion
can
be
written
emph
once
and
for
all
as
a
library
function
thanks
to
effect
handlers
Let
us
name
this
function
invert
We
will
first
look
at
how
to
use
the
invert
function
before
looking
at
its
implementation
details
The
type
of
this
function
is
given
below
begin
caml
example
signature
val
invert
iter
a
unit
unit
a
Seq
t
end
caml
example
begin
caml
eval
let
invert
type
a
iter
a
unit
unit
a
Seq
t
let
module
M
struct
type
Effect
t
Yield
a
unit
t
end
in
let
yield
v
perform
M
Yield
v
in
fun
match
iter
yield
with
Seq
Nil
effect
M
Yield
v
k
Seq
Cons
v
continue
k
end
caml
eval
The
invert
function
takes
an
iter
function
a
producer
that
pushes
elements
to
the
consumer
and
returns
a
sequence
where
the
consumer
has
the
control
For
example
begin
caml
example
verbatim
let
lst
iter
Fun
flip
List
iter
1
2
3
end
caml
example
is
an
iter
function
with
type
int
unit
unit
The
expression
lst
iter
f
pushes
the
elements
1
2
and
3
to
the
consumer
f
For
example
begin
caml
example
verbatim
lst
iter
fun
i
Printf
printf
d
n
i
end
caml
example
The
expression
invert
lst
iter
returns
a
sequence
that
allows
the
consumer
to
traverse
the
list
on
demand
For
example
begin
caml
example
verbatim
let
s
invert
iter
lst
iter
let
next
Seq
to
dispenser
s
next
next
next
next
end
caml
example
We
can
use
the
same
invert
function
on
any
iter
function
For
example
begin
caml
example
verbatim
let
s
invert
iter
Fun
flip
String
iter
OCaml
let
next
Seq
to
dispenser
s
next
next
next
next
next
next
end
caml
example
subsubsection
s
effects
sequence
implementation
Implementing
control
inversion
The
implementation
of
the
invert
function
is
given
below
begin
caml
example
verbatim
let
invert
type
a
iter
a
unit
unit
a
Seq
t
let
module
M
struct
type
Effect
t
Yield
a
unit
t
end
in
let
yield
v
perform
M
Yield
v
in
fun
match
iter
yield
with
Seq
Nil
effect
M
Yield
v
k
Seq
Cons
v
continue
k
end
caml
example
The
invert
function
declares
an
effect
Yield
that
takes
the
element
to
be
yielded
as
a
parameter
The
yield
function
performs
the
Yield
effect
The
lambda
abstraction
fun
delays
all
action
until
the
first
element
of
the
sequence
is
demanded
Once
this
happens
the
computation
iter
yield
is
executed
under
an
effect
handler
Every
time
the
iter
function
pushes
an
element
to
the
yield
function
the
computation
is
interrupted
by
the
Yield
effect
The
Yield
effect
is
handled
by
returning
the
value
Seq
Cons
v
continue
k
to
the
consumer
The
consumer
gets
the
element
v
as
well
as
the
suspended
computation
which
in
the
consumer
s
eyes
is
just
the
tail
of
sequence
When
the
consumer
demands
the
next
element
from
the
sequence
by
applying
it
to
the
continuation
k
is
resumed
This
allows
the
computation
iter
yield
to
make
progress
until
it
either
yields
another
element
or
terminates
normally
In
the
latter
case
the
value
Seq
Nil
is
returned
indicating
to
the
consumer
that
the
iteration
is
over
It
is
important
to
note
that
the
sequence
returned
by
the
invert
function
is
emph
ephemeral
as
defined
by
the
stdmoduleref
Seq
module
i
e
the
sequence
must
be
used
at
most
once
Additionally
the
sequence
must
be
fully
consumed
i
e
used
at
least
once
so
as
to
ensure
that
the
captured
continuation
is
used
linearly
subsection
s
effects
semantics
Semantics
In
this
section
we
shall
see
the
semantics
of
effect
handlers
with
the
help
of
examples
subsubsection
s
effects
nesting
Nesting
handlers
Like
exception
handlers
effect
handlers
can
be
nested
begin
caml
example
verbatim
type
Effect
t
E
int
t
F
string
t
let
foo
perform
F
let
bar
try
foo
with
effect
E
k
failwith
impossible
let
baz
try
bar
with
effect
F
k
continue
k
Hello
world
end
caml
example
In
this
example
the
computation
foo
performs
F
the
inner
handler
handles
only
E
and
the
outer
handler
handles
F
The
call
to
baz
returns
Hello
world
begin
caml
example
verbatim
baz
end
caml
example
subsubsection
s
effects
fibers
Fibers
It
is
useful
to
know
a
little
bit
about
the
implementation
of
effect
handlers
to
appreciate
the
design
choices
and
their
performance
characteristics
Effect
handlers
are
implemented
with
the
help
of
runtime
managed
dynamically
growing
segments
of
stack
called
textit
fibers
The
program
stack
in
OCaml
is
a
linked
list
of
such
fibers
A
new
fiber
is
allocated
for
evaluating
the
computation
enclosed
by
an
effect
handler
The
fiber
is
freed
when
the
computation
returns
to
the
caller
either
normally
by
returning
a
value
or
by
raising
an
exception
At
the
point
of
perform
in
foo
in
the
previous
example
the
program
stack
looks
like
this
begin
caml
begin
camlinput
baz
bar
foo
stack
pointer
end
camlinput
end
caml
The
two
links
correspond
to
the
two
effect
handlers
in
the
program
When
the
effect
F
is
handled
in
baz
the
program
state
looks
as
follows
begin
caml
begin
camlinput
baz
bar
foo
k
stack
pointer
end
camlinput
end
caml
The
delimited
continuation
k
is
an
object
on
the
heap
that
refers
to
the
segment
of
the
stack
that
corresponds
to
the
suspended
computation
Capturing
a
continuation
does
not
involve
copying
stack
frames
When
the
continuation
is
resumed
the
stack
is
restored
to
the
previous
state
by
linking
together
the
segment
pointed
to
by
k
to
the
current
stack
Since
neither
continuation
capture
nor
resumption
requires
copying
stack
frames
suspending
the
execution
using
perform
and
resuming
it
using
either
continue
or
discontinue
are
fast
subsubsection
s
effects
unhandled
Unhandled
effects
Unlike
languages
such
as
Eff
and
Koka
effect
handlers
in
OCaml
do
not
provide
textit
effect
safety
the
compiler
does
not
statically
ensure
that
all
the
effects
performed
by
the
program
are
handled
If
effects
do
not
have
a
matching
handler
then
an
Effect
Unhandled
exception
is
raised
at
the
point
of
the
corresponding
perform
For
example
in
the
previous
example
bar
does
not
handle
the
effect
F
Hence
we
will
get
an
Effect
Unhandled
F
exception
when
we
run
bar
begin
caml
example
verbatim
try
bar
with
Effect
Unhandled
F
Saw
Effect
Unhandled
exception
end
caml
example
subsubsection
s
effects
linearity
Linear
continuations
As
discussed
earlier
ref
s
effects
discontinue
the
delimited
continuations
in
OCaml
must
be
used
linearly
emph
textbf
every
captured
continuation
must
be
resumed
either
with
a
continue
or
discontinue
exactly
once
Attempting
to
use
a
continuation
more
than
once
raises
a
Continuation
already
resumed
exception
For
example
begin
caml
example
verbatim
try
perform
Xchg
0
with
effect
Xchg
n
k
continue
k
21
continue
k
21
end
caml
example
The
primary
motivation
for
adding
effect
handlers
to
OCaml
is
to
enable
concurrent
programming
One
shot
continuations
are
sufficient
for
almost
all
concurrent
programming
needs
They
are
also
much
cheaper
to
implement
compared
to
multi
shot
continuations
since
they
do
not
require
stack
frames
to
be
copied
Moreover
OCaml
programs
may
also
manipulate
linear
resources
such
as
sockets
and
file
descriptors
The
linearity
discipline
is
easily
broken
if
the
continuations
are
allowed
to
resume
more
than
once
It
would
be
quite
hard
to
debug
such
linearity
violations
on
resources
due
to
the
lack
of
static
checks
for
linearity
and
the
non
local
nature
of
control
flow
Hence
OCaml
does
not
support
multi
shot
continuations
While
the
at
most
once
resumption
property
of
continuations
is
ensured
with
a
dynamic
check
there
is
no
check
to
ensure
that
the
continuations
are
resumed
at
least
once
It
is
left
to
the
user
to
ensure
that
the
captured
continuations
are
resumed
at
least
once
Not
resuming
continuations
will
leak
the
memory
allocated
for
the
fibers
as
well
as
any
resources
that
the
suspended
computation
may
hold
One
may
install
a
finaliser
on
the
captured
continuation
to
ensure
that
the
resources
are
freed
begin
caml
begin
camlinput
exception
Unwind
Gc
finalise
fun
k
try
ignore
discontinue
k
Unwind
with
k
end
camlinput
end
caml
In
this
case
if
k
becomes
unreachable
then
the
finaliser
ensures
that
the
continuation
stack
is
unwound
by
discontinuing
with
an
Unwind
exception
allowing
the
computation
to
free
up
resources
However
the
runtime
cost
of
finalisers
is
much
more
than
the
cost
of
capturing
a
continuation
Hence
it
is
recommended
that
the
user
take
care
of
resuming
the
continuation
exactly
once
rather
than
relying
on
the
finaliser
subsubsection
s
effects
limitations
Limitations
OCaml
s
effects
are
emph
synchronous
It
is
not
possible
to
perform
an
effect
asynchronously
from
a
signal
handler
a
finaliser
a
memprof
callback
or
a
GC
alarm
and
catch
it
from
the
main
part
of
the
code
Instead
this
would
result
in
an
Effect
Unhandled
exception
ref
s
effects
unhandled
Similarly
effects
are
incompatible
with
the
use
of
callbacks
from
C
to
OCaml
section
ref
s
c
callback
It
is
not
possible
for
an
effect
to
cross
a
call
to
caml
callback
this
would
instead
result
in
an
Effect
Unhandled
exception
In
particular
care
must
be
taken
when
mixing
libraries
that
use
callbacks
from
C
to
OCaml
and
libraries
that
use
effects
subsection
s
effects
shallow
Shallow
handlers
The
examples
that
we
have
seen
so
far
have
used
textit
deep
handlers
A
deep
handler
handles
all
the
effects
performed
in
sequence
by
the
computation
Whenever
a
continuation
is
captured
in
a
deep
handler
the
captured
continuation
also
includes
the
handler
This
means
that
when
the
continuation
is
resumed
the
effect
handler
is
automatically
re
installed
and
will
handle
the
effect
s
that
the
computation
may
perform
in
the
future
OCaml
also
provides
textit
shallow
handlers
Compared
to
deep
handlers
a
shallow
handler
handles
only
the
first
effect
performed
by
the
computation
The
continuation
captured
in
a
shallow
handler
does
not
include
the
handler
This
means
that
when
the
continuation
is
resumed
the
handler
is
no
longer
present
For
this
reason
when
the
continuation
is
resumed
the
user
is
expected
to
provide
a
new
effect
handler
possibly
a
different
one
to
handle
the
next
effect
that
the
computation
may
perform
Shallow
handlers
make
it
easier
to
express
certain
kinds
of
programs
Let
us
implement
a
shallow
handler
that
enforces
a
particular
sequence
of
effects
a
protocol
on
a
computation
For
this
example
let
us
consider
that
the
computation
may
perform
the
following
effects
begin
caml
example
verbatim
type
Effect
t
Send
int
unit
Effect
t
Recv
int
Effect
t
end
caml
example
Let
us
assume
that
we
want
to
enforce
a
protocol
that
only
permits
an
alternating
sequence
of
Send
and
Recv
effects
that
conform
to
the
regular
expression
Send
Recv
Send
Hence
the
sequence
of
effects
the
empty
sequence
Send
Send
Recv
Send
Recv
Send
etc
are
allowed
but
not
Recv
Send
Send
Send
Recv
Recv
etc
The
key
observation
here
is
that
the
set
of
effects
handled
evolves
over
time
We
can
enforce
this
protocol
quite
naturally
using
shallow
handlers
as
shown
below
begin
caml
example
verbatim
open
Effect
Shallow
let
run
comp
unit
unit
unit
let
rec
loop
send
type
a
a
unit
continuation
a
unit
fun
k
v
continue
with
k
v
retc
Fun
id
exnc
raise
effc
fun
type
b
eff
b
Effect
t
match
eff
with
Send
n
Some
fun
k
b
continuation
loop
recv
n
k
Recv
failwith
protocol
violation
None
and
loop
recv
type
a
int
a
unit
continuation
a
unit
fun
n
k
v
continue
with
k
v
retc
Fun
id
exnc
raise
effc
fun
type
b
eff
b
Effect
t
match
eff
with
Recv
Some
fun
k
b
continuation
loop
send
k
n
Send
v
failwith
protocol
violation
None
in
loop
send
fiber
comp
end
caml
example
The
run
function
executes
the
computation
comp
ensuring
that
it
can
only
perform
an
alternating
sequence
of
Send
and
Recv
effects
The
shallow
handler
uses
a
different
set
of
primitives
compared
to
the
deep
handler
The
primitive
fiber
on
the
last
line
takes
an
a
b
function
and
returns
a
a
b
Effect
Shallow
continuation
Unlike
deep
handlers
OCaml
does
not
provide
syntax
support
for
shallow
handlers
The
expression
continue
with
k
v
h
resumes
the
continuation
k
with
value
v
under
the
handler
h
The
handler
here
is
a
record
with
three
fields
for
the
value
case
retc
the
exceptional
case
exnc
and
the
effect
case
effc
The
mutually
recursive
functions
loop
send
and
loop
recv
resume
the
given
continuation
k
with
value
v
under
different
handlers
The
loop
send
function
handles
the
Send
effect
and
tail
calls
the
loop
recv
function
If
the
computation
performs
the
Recv
effect
then
loop
send
aborts
the
computation
by
raising
an
exception
Similarly
the
loop
recv
function
handles
the
Recv
effect
and
tail
calls
the
loop
send
function
If
the
computation
performs
the
Send
effect
then
loop
recv
aborts
the
computation
Given
that
the
continuation
captured
in
the
shallow
handler
do
not
include
the
handler
there
is
only
ever
one
handler
installed
in
the
dynamic
scope
of
the
computation
comp
Note
that
unlike
deep
handlers
with
syntax
support
explicit
type
annotations
are
necessary
for
the
shallow
handler
We
must
use
a
locally
abstract
type
type
b
in
the
effect
handler
effc
and
explicitly
type
annotate
the
effect
argument
eff
and
the
continuation
k
in
each
of
the
effect
cases
Another
point
to
note
is
that
the
catch
all
effect
case

None
is
necessary
This
case
may
be
intuitively
read
as
forward
the
unhandled
effects
to
the
outer
handler
The
standard
library
module
stdmoduleref
Effect
also
provides
a
non
syntactic
version
of
deep
handlers
where
similar
annotations
are
necessary
The
computation
is
initially
executed
by
the
loop
send
function
see
last
line
in
the
code
above
which
ensures
that
the
first
effect
that
the
computation
is
allowed
to
perform
is
the
Send
effect
Note
that
the
computation
is
free
to
perform
effects
other
than
Send
and
Recv
which
may
be
handled
by
an
outer
handler
We
can
see
that
the
run
function
will
permit
a
computation
that
follows
the
protocol
begin
caml
example
verbatim
run
fun
printf
Send
42
n
perform
Send
42
printf
Recv
d
n
perform
Recv
printf
Send
43
n
perform
Send
43
printf
Recv
d
n
perform
Recv
end
caml
example
and
aborts
those
that
do
not
begin
caml
example
verbatim
run
fun
Printf
printf
Send
0
n
perform
Send
0
Printf
printf
Send
1
n
perform
Send
1
protocol
violation
end
caml
example
We
may
implement
the
same
example
using
deep
handlers
using
reference
cells
easy
but
unsatisfying
or
without
them
harder
We
leave
this
as
an
exercise
to
the
reader
section
s
labeled
tuples
Labeled
tuples
HEVEA
cutname
labeledtuples
html
Introduced
in
OCaml
5
4
begin
syntax
typexpr
label
name
typexpr
label
name
typexpr
expr
label
name
expr
label
name
expr
pattern
label
name
pattern
label
name
pattern
end
syntax
Since
OCaml
5
4
tuple
fields
are
optionally
labeled
This
feature
is
conceptually
dual
to
labeled
function
arguments
allowing
you
to
give
a
helpful
name
to
constructed
values
where
labeled
function
arguments
permit
giving
a
helpful
name
to
parameters
Here
is
a
motivating
example
where
we
want
to
compute
two
values
from
a
list
and
be
careful
not
to
mix
them
up
begin
caml
example
verbatim
let
sum
and
product
ints
let
init
sum
0
product
1
in
List
fold
left
fun
sum
product
elem
let
sum
elem
sum
in
let
product
elem
product
in
sum
product
init
ints
end
caml
example
This
example
shows
the
use
of
labeled
tuples
in
types
and
patterns
They
may
be
punned
like
record
elements
or
function
arguments
In
types
tuple
labels
are
written
similarly
to
function
argument
labels
For
example
the
function
argument
to
fold
left
in
the
previous
example
has
the
type
begin
verbatim
sum
int
product
int
int
sum
int
product
int
end
verbatim
Labeled
tuples
can
be
useful
anytime
you
want
to
use
names
to
explain
or
disambiguate
the
elements
of
a
tuple
but
declaring
a
new
record
feels
too
heavy
Tuples
may
be
partially
labeled
which
can
be
useful
when
some
elements
of
the
tuple
share
a
type
and
need
disambiguation
but
others
dont
For
example
begin
caml
example
verbatim
type
min
max
avg
min
int
max
int
float
end
caml
example
subsubsection
sss
labledtuples
reordering
Reordering
and
partial
patterns
Like
records
labeled
tuple
patterns
may
be
reordered
or
partial
The
compiler
only
supports
reordering
partial
matching
when
it
knows
the
type
of
the
pattern
from
its
context
So
for
example
we
can
write
begin
caml
example
verbatim
let
lt
x
0
y
42
let
twice
y
let
y
lt
in
y
2
end
caml
example
When
the
type
is
not
known
in
the
same
sense
that
we
require
a
type
to
be
known
to
disambiguate
among
constructors
the
compiler
will
reject
a
partial
pattern
For
example
this
program
begin
caml
example
verbatim
error
let
get
y
t
let
y
t
in
y
end
caml
example
This
example
could
be
fixed
by
adding
a
type
annotation
to
the
functions
parameter
Labels
may
not
be
repeated
in
a
tuple
However
unlabeled
elements
can
be
thought
of
as
all
sharing
the
same
unique
label
When
matching
on
such
a
tuple
the
first
unlabeled
element
in
the
pattern
is
bound
to
the
first
unlabeled
element
in
the
value
and
so
on
As
a
result
its
also
possible
to
partially
match
on
an
unlabeled
tuple
to
retrieve
the
first
few
elements
subsubsection
sss
labledtuples
limitations
Limitations
Parentheses
are
necessary
to
disambiguate
functions
types
with
labeled
arguments
from
function
types
with
labeled
tuple
arguments
when
the
first
element
of
the
tuple
has
a
label
Unlike
records
reordering
is
not
supported
in
labeled
tuple
expressions
even
when
the
type
is
known
This
is
similar
to
the
way
the
function
definition
for
a
function
with
labeled
arguments
must
bind
the
arguments
in
the
same
order
as
the
type
Labeled
tuples
do
not
support
projection
extracting
an
element
of
the
tuple
by
label
subsubsection
sss
labledtuples
smlrelation
Relationship
to
flexible
records
Labeled
tuples
are
similar
in
spirit
to
SML
s
flexible
records
The
primary
difference
is
that
SML
records
are
canonically
ordered
based
on
label
name
while
labeled
tuples
are
not
So
for
example
x
int
y
bool
and
y
bool
x
int
are
different
types
in
OCaml
corresponding
to
two
different
orderings
of
the
fields
in
the
runtime
block
In
SML
the
corresponding
record
types
are
considered
equal
and
the
runtime
block
is
always
ordered
with
the
x
field
first
section
s
inline
records
Inline
records
HEVEA
cutname
inlinerecords
html
Introduced
in
OCaml
4
03
begin
syntax
constr
args
record
decl
end
syntax
The
arguments
of
sum
type
constructors
can
now
be
defined
using
the
same
syntax
as
records
Mutable
and
polymorphic
fields
are
allowed
GADT
syntax
is
supported
Attributes
can
be
specified
on
individual
fields
Syntactically
building
or
matching
constructors
with
such
an
inline
record
argument
is
similar
to
working
with
a
unary
constructor
whose
unique
argument
is
a
declared
record
type
A
pattern
can
bind
the
inline
record
as
a
pseudo
value
but
the
record
cannot
escape
the
scope
of
the
binding
and
can
only
be
used
with
the
dot
notation
to
extract
or
modify
fields
or
to
build
new
constructor
values
begin
caml
example
verbatim
type
t
Point
of
width
int
mutable
x
float
mutable
y
float
Other
let
v
Point
width
10
x
0
y
0
let
scale
l
function
Point
p
Point
p
with
x
l
p
x
y
l
p
y
Other
Other
let
print
function
Point
x
y
Printf
printf
f
f
x
y
Other
let
reset
function
Point
p
p
x
0
p
y
0
Other
end
caml
example
begin
caml
example
verbatim
error
let
invalid
function
Point
p
p
end
caml
example
section
s
doc
comments
Documentation
comments
HEVEA
cutname
doccomments
html
Introduced
in
OCaml
4
03
Comments
which
start
with
are
treated
specially
by
the
compiler
They
are
automatically
converted
during
parsing
into
attributes
see
ref
s
attributes
to
allow
tools
to
process
them
as
documentation
Such
comments
can
take
three
forms
em
floating
comments
em
item
comments
and
em
label
comments
Any
comment
starting
with
which
does
not
match
one
of
these
forms
will
cause
the
compiler
to
emit
warning
50
Comments
which
start
with
are
also
used
by
the
ocamldoc
documentation
generator
see
ref
c
ocamldoc
The
three
comment
forms
recognised
by
the
compiler
are
a
subset
of
the
forms
accepted
by
ocamldoc
see
ref
s
ocamldoc
comments
subsection
ss
floating
comments
Floating
comments
Comments
surrounded
by
blank
lines
that
appear
within
structures
signatures
classes
or
class
types
are
converted
into
floating
attribute
s
For
example
begin
caml
example
verbatim
type
t
T
Now
some
definitions
for
t
let
mkT
T
end
caml
example
will
be
converted
to
begin
caml
example
verbatim
type
t
T
ocaml
text
Now
some
definitions
for
t
let
mkT
T
end
caml
example
subsection
ss
item
comments
Item
comments
Comments
which
appear
em
immediately
before
or
em
immediately
after
a
structure
item
signature
item
class
item
or
class
type
item
are
converted
into
item
attribute
s
Immediately
before
or
immediately
after
means
that
there
must
be
no
blank
lines
or
other
documentation
comments
between
them
For
example
begin
caml
example
verbatim
type
t
T
A
description
of
t
end
caml
example
or
begin
caml
example
verbatim
A
description
of
t
type
t
T
end
caml
example
will
be
converted
to
begin
caml
example
verbatim
type
t
T
ocaml
doc
A
description
of
t
end
caml
example
Note
that
if
a
comment
appears
immediately
next
to
multiple
items
as
in
begin
caml
example
verbatim
type
t
T
An
ambiguous
comment
type
s
S
end
caml
example
then
it
will
be
attached
to
both
items
begin
caml
example
verbatim
type
t
T
ocaml
doc
An
ambiguous
comment
type
s
S
ocaml
doc
An
ambiguous
comment
end
caml
example
and
the
compiler
will
emit
warning
50
subsection
ss
label
comments
Label
comments
Comments
which
appear
em
immediately
after
a
labelled
argument
record
field
variant
constructor
object
method
or
polymorphic
variant
constructor
are
are
converted
into
attribute
s
Immediately
after
means
that
there
must
be
no
blank
lines
or
other
documentation
comments
between
them
For
example
begin
caml
example
verbatim
type
t1
lbl
int
Labelled
argument
unit
type
t2
fld
int
Record
field
fld2
float
type
t3
Cstr
of
string
Variant
constructor
Cstr2
of
string
type
t4
meth
int
int
Object
method
type
t5
PCstr
Polymorphic
variant
constructor
end
caml
example
will
be
converted
to
begin
caml
example
verbatim
type
t1
lbl
int
ocaml
doc
Labelled
argument
unit
type
t2
fld
int
ocaml
doc
Record
field
fld2
float
type
t3
Cstr
of
string
ocaml
doc
Variant
constructor
Cstr2
of
string
type
t4
meth
int
int
ocaml
doc
Object
method
type
t5
PCstr
ocaml
doc
Polymorphic
variant
constructor
end
caml
example
Note
that
label
comments
take
precedence
over
item
comments
so
begin
caml
example
verbatim
type
t
T
of
string
Attaches
to
T
not
t
end
caml
example
will
be
converted
to
begin
caml
example
verbatim
type
t
T
of
string
ocaml
doc
Attaches
to
T
not
t
end
caml
example
whilst
begin
caml
example
verbatim
type
t
T
of
string
Attaches
to
T
not
t
Attaches
to
t
end
caml
example
will
be
converted
to
begin
caml
example
verbatim
type
t
T
of
string
ocaml
doc
Attaches
to
T
not
t
ocaml
doc
Attaches
to
t
end
caml
example
In
the
absence
of
meaningful
comment
on
the
last
constructor
of
a
type
an
empty
comment
can
be
used
instead
begin
caml
example
verbatim
type
t
T
of
string
Attaches
to
t
end
caml
example
will
be
converted
directly
to
begin
caml
example
verbatim
type
t
T
of
string
ocaml
doc
Attaches
to
t
end
caml
example
section
s
extensible
variants
Extensible
variant
types
HEVEA
cutname
extensiblevariants
html
Introduced
in
OCaml
4
02
begin
syntax
type
representation
specification
type
type
params
typeconstr
type
extension
spec
definition
type
type
params
typeconstr
type
extension
def
type
extension
spec
private
constr
decl
constr
decl
type
extension
def
private
constr
def
constr
def
constr
def
constr
decl
constr
name
constr
end
syntax
Extensible
variant
types
are
variant
types
which
can
be
extended
with
new
variant
constructors
Extensible
variant
types
are
defined
using
New
variant
constructors
are
added
using
begin
caml
example
verbatim
module
Expr
struct
type
attr
type
attr
Str
of
string
type
attr
Int
of
int
Float
of
float
end
end
caml
example
Pattern
matching
on
an
extensible
variant
type
requires
a
default
case
to
handle
unknown
variant
constructors
begin
caml
example
verbatim
let
to
string
function
Expr
Str
s
s
Expr
Int
i
Int
to
string
i
Expr
Float
f
string
of
float
f
end
caml
example
A
preexisting
example
of
an
extensible
variant
type
is
the
built
in
exn
type
used
for
exceptions
Indeed
exception
constructors
can
be
declared
using
the
type
extension
syntax
begin
caml
example
verbatim
type
exn
Exc
of
int
end
caml
example
Extensible
variant
constructors
can
be
rebound
to
a
different
name
This
allows
exporting
variants
from
another
module
begin
caml
example
toplevel
error
let
not
in
scope
Str
Foo
end
caml
example
begin
caml
example
verbatim
type
Expr
attr
Str
Expr
Str
end
caml
example
begin
caml
example
toplevel
let
now
works
Str
foo
end
caml
example
Extensible
variant
constructors
can
be
declared
private
As
with
regular
variants
this
prevents
them
from
being
constructed
directly
by
constructor
application
while
still
allowing
them
to
be
de
structured
in
pattern
matching
begin
caml
example
verbatim
module
B
sig
type
Expr
attr
private
Bool
of
int
val
bool
bool
Expr
attr
end
struct
type
Expr
attr
Bool
of
int
let
bool
p
if
p
then
Bool
1
else
Bool
0
end
end
caml
example
begin
caml
example
toplevel
let
inspection
works
function
B
Bool
p
p
1
true
end
caml
example
begin
caml
example
toplevel
error
let
construction
is
forbidden
B
Bool
1
end
caml
example
subsection
ss
private
extensible
Private
extensible
variant
types
Introduced
in
OCaml
4
06
begin
syntax
type
representation
private
end
syntax
Extensible
variant
types
can
be
declared
private
This
prevents
new
constructors
from
being
declared
directly
but
allows
extension
constructors
to
be
referred
to
in
interfaces
begin
caml
example
verbatim
module
Msg
sig
type
t
private
module
MkConstr
X
sig
type
t
end
sig
type
t
C
of
X
t
end
end
struct
type
t
module
MkConstr
X
sig
type
t
end
struct
type
t
C
of
X
t
end
end
end
caml
example
section
s
array
literals
Type
directed
disambiguation
of
array
literals
HEVEA
cutname
arrayliterals
html
Introduced
in
OCaml
5
4
Since
OCaml
5
4
array
literal
syntax
e1
e2
eN
can
be
used
to
denote
values
of
type
floatarray
as
well
as
a
array
both
in
expression
and
pattern
positions
This
syntax
is
also
used
to
display
floatarray
values
in
the
toplevel
The
compiler
matches
the
expected
type
of
the
expression
or
pattern
with
the
type
of
the
literal
in
a
manner
analogous
to
the
disambiguation
of
constructors
and
record
fields
see
ref
ss
record
and
variant
disambiguation
In
the
absence
of
an
expected
type
array
literals
are
assumed
to
be
of
type
a
array
In
the
following
examples
the
array
literals
are
assigned
type
floatarray
begin
caml
example
verbatim
let
floatarray
42
let
42
floatarray
let
Float
Array
length
42
end
caml
example
The
same
disambiguation
mechanism
is
used
for
array
literals
appearing
in
patterns
begin
caml
example
verbatim
let
f
floatarray
function
42
It
s
a
floatarray
containing
one
element
Also
a
floatarray
end
caml
example
In
the
example
below
x
is
assigned
type
float
array
begin
caml
example
verbatim
let
x
42
end
caml
example
However
the
following
does
not
work
begin
caml
example
verbatim
let
f
a
match
a
with
Float
Array
length
a
42
expect
error
let
f
b
a
floatarray
if
b
then
42
else
a
expect
error
end
caml
example
Here
the
information
learned
from
the
use
of
a
as
a
floatarray
cannot
be
propagated
back
to
the
array
literal
In
general
expected
type
information
cannot
be
propagated
backwards
In
the
following
example
type
disambiguation
works
because
the
type
information
learned
in
the
then
branch
of
the
conditional
is
propagated
to
the
else
branch
which
occurs
later
begin
caml
example
verbatim
let
f
b
a
floatarray
if
b
then
a
else
42
end
caml
example
Such
cases
trigger
warning
18
not
principal
if
enabled
section
s
generalized
open
Generalized
open
statements
HEVEA
cutname
generalizedopens
html
Introduced
in
4
08
begin
syntax
definition
open
module
expr
open
module
expr
specification
open
extended
module
path
open
extended
module
path
expr
let
open
module
expr
in
expr
let
open
module
expr
in
expr
end
syntax
This
extension
makes
it
possible
to
open
any
module
expression
in
module
structures
and
expressions
A
similar
mechanism
is
also
available
inside
module
types
but
only
for
extended
module
paths
e
g
F
X
G
Y
For
instance
a
module
can
be
constrained
when
opened
with
begin
caml
example
verbatim
error
module
M
struct
let
x
0
let
hidden
1
end
open
M
sig
val
x
int
end
let
y
hidden
end
caml
example
Another
possibility
is
to
immediately
open
the
result
of
a
functor
application
begin
caml
example
verbatim
let
sort
type
x
x
x
list
let
open
Set
Make
struct
type
t
x
let
compare
compare
end
in
elements
of
list
x
end
caml
example
Going
further
this
construction
can
introduce
local
components
inside
a
structure
begin
caml
example
verbatim
module
M
struct
let
x
0
open
struct
let
x
0
let
y
1
end
let
w
x
y
end
end
caml
example
One
important
restriction
is
that
types
introduced
by
open
struct
end
cannot
appear
in
the
signature
of
the
enclosing
structure
unless
they
are
defined
equal
to
some
non
local
type
So
begin
caml
example
verbatim
module
M
struct
open
struct
type
a
t
a
option
None
Some
of
a
end
let
x
int
t
Some
1
end
end
caml
example
is
OK
but
begin
caml
example
verbatim
error
module
M
struct
open
struct
type
t
A
end
let
x
A
end
end
caml
example
is
not
because
x
cannot
be
given
any
type
other
than
t
which
only
exists
locally
Although
the
above
would
be
OK
if
x
too
was
local
begin
caml
example
verbatim
module
M
sig
end
struct
open
struct
type
t
A
end
ellipsis
open
struct
let
x
A
end
ellipsis
end
end
caml
example
Inside
signatures
extended
opens
are
limited
to
extended
module
paths
begin
caml
example
verbatim
module
type
S
sig
module
F
sig
end
sig
type
t
end
module
X
sig
end
open
F
X
val
f
t
end
end
caml
example
and
not
begin
verbatim
open
struct
type
t
int
end
end
verbatim
In
those
situations
local
substitutions
see
ref
ss
local
substitution
can
be
used
instead
Beware
that
this
extension
is
not
available
inside
class
definitions
begin
verbatim
class
c
let
open
Set
Make
Int
in
end
verbatim
section
s
values
Values
HEVEA
cutname
values
html
This
section
describes
the
kinds
of
values
that
are
manipulated
by
OCaml
programs
subsection
ss
values
base
Base
values
subsubsection
sss
values
integer
Integer
numbers
Integer
values
are
integer
numbers
from
2
30
to
2
30
1
that
is
1073741824
to
1073741823
The
implementation
may
support
a
wider
range
of
integer
values
on
64
bit
platforms
the
current
implementation
supports
integers
ranging
from
2
62
to
2
62
1
subsubsection
sss
values
float
Floating
point
numbers
Floating
point
values
are
numbers
in
floating
point
representation
The
current
implementation
uses
double
precision
floating
point
numbers
conforming
to
the
IEEE
754
standard
with
53
bits
of
mantissa
and
an
exponent
ranging
from
1022
to
1023
subsubsection
sss
values
char
Characters
Character
values
are
represented
as
8
bit
integers
between
0
and
255
Character
codes
between
0
and
127
are
interpreted
following
the
ASCII
standard
The
current
implementation
interprets
character
codes
between
128
and
255
following
the
ISO
8859
1
standard
subsubsection
sss
values
string
Character
strings
String
values
are
finite
sequences
of
characters
The
current
implementation
supports
strings
containing
up
to
2
24
5
characters
16777211
characters
on
64
bit
platforms
the
limit
is
2
57
9
subsection
ss
values
tuple
Tuples
Tuples
of
values
are
written
v
1
ldots
v
n
standing
for
the
n
tuple
of
values
v
1
to
v
n
The
current
implementation
supports
tuple
of
up
to
2
22
1
elements
4194303
elements
subsection
ss
values
records
Records
Record
values
are
labeled
tuples
of
values
The
record
value
written
field
1
v
1
ldots
field
n
v
n
associates
the
value
v
i
to
the
record
field
field
i
for
i
1
ldots
n
The
current
implementation
supports
records
with
up
to
2
22
1
fields
4194303
fields
subsection
ss
values
array
Arrays
Arrays
are
finite
variable
sized
sequences
of
values
of
the
same
type
The
current
implementation
supports
arrays
containing
up
to
2
22
1
elements
4194303
elements
unless
the
elements
are
floating
point
numbers
2097151
elements
in
this
case
on
64
bit
platforms
the
limit
is
2
54
1
for
all
arrays
subsection
ss
values
variant
Variant
values
Variant
values
are
either
a
constant
constructor
or
a
non
constant
constructor
applied
to
a
number
of
values
The
former
case
is
written
constr
the
latter
case
is
written
constr
v
1
v
n
where
the
v
i
are
said
to
be
the
arguments
of
the
non
constant
constructor
constr
The
parentheses
may
be
omitted
if
there
is
only
one
argument
The
following
constants
are
treated
like
built
in
constant
constructors
begin
tableau
l
l
Constant
Constructor
entree
false
the
boolean
false
entree
true
the
boolean
true
entree
the
unit
value
entree
the
empty
list
end
tableau
The
current
implementation
limits
each
variant
type
to
have
at
most
246
non
constant
constructors
and
2
30
1
constant
constructors
subsection
ss
values
polyvars
Polymorphic
variants
Polymorphic
variants
are
an
alternate
form
of
variant
values
not
belonging
explicitly
to
a
predefined
variant
type
and
following
specific
typing
rules
They
can
be
either
constant
written
tag
name
or
non
constant
written
tag
name
v
subsection
ss
values
fun
Functions
Functional
values
are
mappings
from
values
to
values
subsection
ss
values
obj
Objects
Objects
are
composed
of
a
hidden
internal
state
which
is
a
record
of
instance
variables
and
a
set
of
methods
for
accessing
and
modifying
these
variables
The
structure
of
an
object
is
described
by
the
toplevel
class
that
created
it
chapter
Language
extensions
label
c
extensions
HEVEA
cutname
extn
html
This
chapter
describes
language
extensions
and
convenience
features
that
are
implemented
in
OCaml
but
not
described
in
chapter
ref
c
refman
HEVEA
cutdef
section
input
letrecvalues
tex
input
recursivemodules
tex
input
privatetypes
tex
input
locallyabstract
tex
input
firstclassmodules
tex
input
moduletypeof
tex
input
signaturesubstitution
tex
input
modulealias
tex
input
overridingopen
tex
input
gadts
tex
input
bigarray
tex
input
attributes
tex
input
extensionnodes
tex
input
extensiblevariants
tex
input
generativefunctors
tex
input
extensionsyntax
tex
input
inlinerecords
tex
input
doccomments
tex
input
indexops
tex
input
emptyvariants
tex
input
alerts
tex
input
generalizedopens
tex
input
bindingops
tex
input
effects
tex
input
arrayliterals
tex
input
labeledtuples
tex
HEVEA
cutend
chapter
The
OCaml
language
label
c
refman
HEVEA
cutname
language
html
better
html
output
that
way
sniff
HEVEA
subsection
ss
foreword
Foreword
BEGIN
LATEX
section
s
foreword
Foreword
END
LATEX
This
document
is
intended
as
a
reference
manual
for
the
OCaml
language
It
lists
the
language
constructs
and
gives
their
precise
syntax
and
informal
semantics
It
is
by
no
means
a
tutorial
introduction
to
the
language
A
good
working
knowledge
of
OCaml
is
assumed
No
attempt
has
been
made
at
mathematical
rigor
words
are
employed
with
their
intuitive
meaning
without
further
definition
As
a
consequence
the
typing
rules
have
been
left
out
by
lack
of
the
mathematical
framework
required
to
express
them
while
they
are
definitely
part
of
a
full
formal
definition
of
the
language
subsection
ss
notations
Notations
The
syntax
of
the
language
is
given
in
BNF
like
notation
Terminal
symbols
are
set
in
typewriter
font
like
this
Non
terminal
symbols
are
set
in
italic
font
like
that
Square
brackets
ldots
denote
optional
components
Curly
brackets
ldots
denotes
zero
one
or
several
repetitions
of
the
enclosed
components
Curly
brackets
with
a
trailing
plus
sign
ldots
denote
one
or
several
repetitions
of
the
enclosed
components
Parentheses
ldots
denote
grouping
HEVEA
cutdef
section
input
lex
input
values
input
names
input
types
input
const
input
patterns
input
expr
input
typedecl
input
classes
input
modtypes
input
modules
input
compunit
HEVEA
cutend
section
s
module
expr
Module
expressions
module
implementations
HEVEA
cutname
modules
html
Module
expressions
are
the
module
level
equivalent
of
value
expressions
they
evaluate
to
modules
thus
providing
implementations
for
the
specifications
expressed
in
module
types
ikwd
struct
texttt
struct
ikwd
end
texttt
end
ikwd
functor
texttt
functor
ikwd
let
texttt
let
ikwd
and
texttt
and
ikwd
external
texttt
external
ikwd
type
texttt
type
ikwd
exception
texttt
exception
ikwd
class
texttt
class
ikwd
module
texttt
module
ikwd
open
texttt
open
ikwd
include
texttt
include
begin
syntax
module
expr
module
path
struct
module
items
end
functor
module
name
module
type
module
expr
module
expr
module
expr
module
expr
module
expr
module
type
module
items
definition
expr
definition
expr
end
syntax
begin
syntax
definition
let
rec
let
binding
and
let
binding
external
value
name
typexpr
external
declaration
type
definition
exception
definition
class
definition
classtype
definition
module
module
name
module
name
module
type
module
type
module
expr
module
type
modtype
name
module
type
open
module
path
include
module
expr
end
syntax
See
also
the
following
language
extensions
hyperref
s
recursive
modules
recursive
modules
hyperref
s
first
class
modules
first
class
modules
hyperref
s
explicit
overriding
open
overriding
in
open
statements
hyperref
s
attributes
attributes
hyperref
s
extension
nodes
extension
nodes
and
hyperref
s
generative
functors
generative
functors
subsection
ss
mexpr
simple
Simple
module
expressions
The
expression
module
path
evaluates
to
the
module
bound
to
the
name
module
path
The
expression
module
expr
evaluates
to
the
same
module
as
module
expr
The
expression
module
expr
module
type
checks
that
the
type
of
module
expr
is
a
subtype
of
module
type
that
is
that
all
components
specified
in
module
type
are
implemented
in
module
expr
and
their
implementation
meets
the
requirements
given
in
module
type
In
other
terms
it
checks
that
the
implementation
module
expr
meets
the
type
specification
module
type
The
whole
expression
evaluates
to
the
same
module
as
module
expr
except
that
all
components
not
specified
in
module
type
are
hidden
and
can
no
longer
be
accessed
subsection
ss
mexpr
structures
Structures
ikwd
struct
texttt
struct
ikwd
end
texttt
end
Structures
struct
ldots
end
are
collections
of
definitions
for
value
names
type
names
exceptions
module
names
and
module
type
names
The
definitions
are
evaluated
in
the
order
in
which
they
appear
in
the
structure
The
scopes
of
the
bindings
performed
by
the
definitions
extend
to
the
end
of
the
structure
As
a
consequence
a
definition
may
refer
to
names
bound
by
earlier
definitions
in
the
same
structure
For
compatibility
with
toplevel
phrases
chapter
ref
c
camllight
optional
are
allowed
after
and
before
each
definition
in
a
structure
These
have
no
semantic
meanings
Similarly
an
expr
preceded
by
is
allowed
as
a
component
of
a
structure
It
is
equivalent
to
let
expr
i
e
expr
is
evaluated
for
its
side
effects
but
is
not
bound
to
any
identifier
If
expr
is
the
first
component
of
a
structure
the
preceding
can
be
omitted
subsubsection
sss
mexpr
value
defs
Value
definitions
ikwd
let
texttt
let
A
value
definition
let
rec
let
binding
and
let
binding
bind
value
names
in
the
same
way
as
a
let
ldots
in
ldots
expression
see
section
ref
sss
expr
localdef
The
value
names
appearing
in
the
left
hand
sides
of
the
bindings
are
bound
to
the
corresponding
values
in
the
right
hand
sides
ikwd
external
texttt
external
A
value
definition
external
value
name
typexpr
external
declaration
implements
value
name
as
the
external
function
specified
in
external
declaration
see
chapter
ref
c
intf
c
subsubsection
sss
mexpr
type
defs
Type
definitions
ikwd
type
texttt
type
A
definition
of
one
or
several
type
components
is
written
type
typedef
and
typedef
and
consists
of
a
sequence
of
mutually
recursive
definitions
of
type
names
subsubsection
sss
mexpr
exn
defs
Exception
definitions
ikwd
exception
texttt
exception
Exceptions
are
defined
with
the
syntax
exception
constr
decl
or
exception
constr
name
constr
subsubsection
sss
mexpr
class
defs
Class
definitions
ikwd
class
texttt
class
A
definition
of
one
or
several
classes
is
written
class
class
binding
and
class
binding
and
consists
of
a
sequence
of
mutually
recursive
definitions
of
class
names
Class
definitions
are
described
more
precisely
in
section
ref
ss
class
def
subsubsection
sss
mexpr
classtype
defs
Class
type
definitions
ikwd
class
texttt
class
ikwd
type
texttt
type
A
definition
of
one
or
several
classes
is
written
class
type
classtype
def
and
classtype
def
and
consists
of
a
sequence
of
mutually
recursive
definitions
of
class
type
names
Class
type
definitions
are
described
more
precisely
in
section
ref
ss
classtype
subsubsection
sss
mexpr
module
defs
Module
definitions
ikwd
module
texttt
module
The
basic
form
for
defining
a
module
component
is
module
module
name
module
expr
which
evaluates
module
expr
and
binds
the
result
to
the
name
module
name
One
can
write
begin
center
module
module
name
module
type
module
expr
end
center
instead
of
begin
center
module
module
name
module
expr
module
type
end
center
Another
derived
form
is
begin
center
module
module
name
name
1
module
type
1
ldots
name
n
module
type
n
module
expr
end
center
which
is
equivalent
to
begin
center
module
module
name
functor
name
1
module
type
1
ldots
module
expr
end
center
subsubsection
sss
mexpr
modtype
defs
Module
type
definitions
ikwd
type
texttt
type
ikwd
module
texttt
module
A
definition
for
a
module
type
is
written
module
type
modtype
name
module
type
It
binds
the
name
modtype
name
to
the
module
type
denoted
by
the
expression
module
type
subsubsection
sss
mexpr
open
Opening
a
module
path
ikwd
open
texttt
open
The
expression
open
module
path
in
a
structure
does
not
define
any
components
nor
perform
any
bindings
It
simply
affects
the
parsing
of
the
following
items
of
the
structure
allowing
components
of
the
module
denoted
by
module
path
to
be
referred
to
by
their
simple
names
name
instead
of
path
accesses
module
path
name
The
scope
of
the
open
stops
at
the
end
of
the
structure
expression
subsubsection
sss
mexpr
include
Including
the
components
of
another
structure
ikwd
include
texttt
include
The
expression
include
module
expr
in
a
structure
re
exports
in
the
current
structure
all
definitions
of
the
structure
denoted
by
module
expr
For
instance
if
you
define
a
module
S
as
below
begin
caml
example
verbatim
module
S
struct
type
t
int
let
x
2
end
end
caml
example
defining
the
module
B
as
begin
caml
example
verbatim
module
B
struct
include
S
let
y
x
1
t
end
end
caml
example
is
equivalent
to
defining
it
as
begin
caml
example
verbatim
module
B
struct
type
t
S
t
let
x
S
x
let
y
x
1
t
end
end
caml
example
The
difference
between
open
and
include
is
that
open
simply
provides
short
names
for
the
components
of
the
opened
structure
without
defining
any
components
of
the
current
structure
while
include
also
adds
definitions
for
the
components
of
the
included
structure
subsection
ss
mexpr
functors
Functors
subsubsection
sss
mexpr
functor
defs
Functor
definition
ikwd
functor
texttt
functor
The
expression
functor
module
name
module
type
module
expr
evaluates
to
a
functor
that
takes
as
argument
modules
of
the
type
module
type
1
binds
module
name
to
these
modules
evaluates
module
expr
in
the
extended
environment
and
returns
the
resulting
modules
as
results
No
restrictions
are
placed
on
the
type
of
the
functor
argument
in
particular
a
functor
may
take
another
functor
as
argument
higher
order
functor
When
the
result
module
expression
is
itself
a
functor
begin
center
functor
name
1
module
type
1
ldots
functor
name
n
module
type
n
module
expr
end
center
one
may
use
the
abbreviated
form
begin
center
functor
name
1
module
type
1
ldots
name
n
module
type
n
module
expr
end
center
subsubsection
sss
mexpr
functor
app
Functor
application
The
expression
module
expr
1
module
expr
2
evaluates
module
expr
1
to
a
functor
and
module
expr
2
to
a
module
and
applies
the
former
to
the
latter
The
type
of
module
expr
2
must
match
the
type
expected
for
the
arguments
of
the
functor
module
expr
1
section
s
typexpr
Type
expressions
HEVEA
cutname
types
html
ikwd
as
texttt
as
begin
syntax
typexpr
ident
typexpr
label
name
typexpr
typexpr
typexpr
typexpr
typeconstr
typexpr
typeconstr
typexpr
typexpr
typeconstr
typexpr
as
ident
polymorphic
variant
type
method
type
method
type
classtype
path
typexpr
class
path
typexpr
typexpr
class
path
poly
typexpr
typexpr
ident
typexpr
method
type
method
name
poly
typexpr
end
syntax
See
also
the
following
language
extensions
hyperref
s
first
class
modules
first
class
modules
hyperref
s
attributes
attributes
hyperref
s
extension
nodes
extension
nodes
and
hyperref
s
labeled
tuples
labeled
tuples
The
table
below
shows
the
relative
precedences
and
associativity
of
operators
and
non
closed
type
constructions
The
constructions
with
higher
precedences
come
first
ikwd
as
texttt
as
begin
tableau
l
l
Operator
Associativity
entree
Type
constructor
application
entree
entree
entree
right
entree
as
end
tableau
Type
expressions
denote
types
in
definitions
of
data
types
as
well
as
in
type
constraints
over
patterns
and
expressions
subsubsection
sss
typexpr
variables
Type
variables
The
type
expression
ident
stands
for
the
type
variable
named
ident
The
type
expression
stands
for
either
an
anonymous
type
variable
or
anonymous
type
parameters
In
data
type
definitions
type
variables
are
names
for
the
data
type
parameters
In
type
constraints
they
represent
unspecified
types
that
can
be
instantiated
by
any
type
to
satisfy
the
type
constraint
In
general
the
scope
of
a
named
type
variable
is
the
whole
top
level
phrase
where
it
appears
and
it
can
only
be
generalized
when
leaving
this
scope
Anonymous
variables
have
no
such
restriction
In
the
following
cases
the
scope
of
named
type
variables
is
restricted
to
the
type
expression
where
they
appear
1
for
universal
explicitly
polymorphic
type
variables
2
for
type
variables
that
only
appear
in
public
method
specifications
as
those
variables
will
be
made
universal
as
described
in
section
ref
sss
clty
meth
3
for
variables
used
as
aliases
when
the
type
they
are
aliased
to
would
be
invalid
in
the
scope
of
the
enclosing
definition
it
i
e
when
it
contains
free
universal
type
variables
or
locally
defined
types
subsubsection
sss
typexr
parenthesized
Parenthesized
types
The
type
expression
typexpr
denotes
the
same
type
as
typexpr
subsubsection
sss
typexr
fun
Function
types
The
type
expression
typexpr
1
typexpr
2
denotes
the
type
of
functions
mapping
arguments
of
type
typexpr
1
to
results
of
type
typexpr
2
label
name
typexpr
1
typexpr
2
denotes
the
same
function
type
but
the
argument
is
labeled
label
label
name
typexpr
1
typexpr
2
denotes
the
type
of
functions
mapping
an
optional
labeled
argument
of
type
typexpr
1
to
results
of
type
typexpr
2
That
is
the
physical
type
of
the
function
will
be
typexpr
1
option
typexpr
2
subsubsection
sss
typexpr
tuple
Tuple
types
The
type
expression
typexpr
1
ldots
typexpr
n
denotes
the
type
of
tuples
whose
elements
belong
to
types
typexpr
1
ldots
typexpr
n
respectively
subsubsection
sss
typexpr
constructed
Constructed
types
Type
constructors
with
no
parameter
as
in
typeconstr
are
type
expressions
The
type
expression
typexpr
typeconstr
where
typeconstr
is
a
type
constructor
with
one
parameter
denotes
the
application
of
the
unary
type
constructor
typeconstr
to
the
type
typexpr
The
type
expression
typexpr
1
ldots
typexpr
n
typeconstr
where
typeconstr
is
a
type
constructor
with
n
parameters
denotes
the
application
of
the
n
ary
type
constructor
typeconstr
to
the
types
typexpr
1
through
typexpr
n
In
the
type
expression
typeconstr
the
anonymous
type
expression
stands
in
for
anonymous
type
parameters
and
is
equivalent
to
ldots
with
as
many
repetitions
of
as
the
arity
of
typeconstr
subsubsection
sss
typexpr
aliased
recursive
Aliased
and
recursive
types
ikwd
as
texttt
as
The
type
expression
typexpr
as
ident
denotes
the
same
type
as
typexpr
and
also
binds
the
type
variable
ident
to
type
typexpr
both
in
typexpr
and
in
other
types
In
general
the
scope
of
an
alias
is
the
same
as
for
a
named
type
variable
and
covers
the
whole
enclosing
definition
If
the
type
variable
ident
actually
occurs
in
typexpr
a
recursive
type
is
created
Recursive
types
for
which
there
exists
a
recursive
path
that
does
not
contain
an
object
or
polymorphic
variant
type
constructor
are
rejected
except
when
the
rectypes
mode
is
selected
If
ident
denotes
an
explicit
polymorphic
variable
and
typexpr
denotes
either
an
object
or
polymorphic
variant
type
the
row
variable
of
typexpr
is
captured
by
ident
and
quantified
upon
subsubsection
sss
typexpr
polyvar
Polymorphic
variant
types
ikwd
of
texttt
of
begin
syntax
polymorphic
variant
type
tag
spec
first
tag
spec
tag
spec
tag
spec
tag
spec
full
tag
spec
full
tag
name
end
syntax
begin
syntax
tag
spec
first
tag
name
of
typexpr
typexpr
tag
spec
tag
spec
tag
name
of
typexpr
typexpr
tag
spec
full
tag
name
of
typexpr
typexpr
typexpr
end
syntax
Polymorphic
variant
types
describe
the
values
a
polymorphic
variant
may
take
The
first
case
is
an
exact
variant
type
all
possible
tags
are
known
with
their
associated
types
and
they
can
all
be
present
Its
structure
is
fully
known
The
second
case
is
an
open
variant
type
describing
a
polymorphic
variant
value
it
gives
the
list
of
all
tags
the
value
could
take
with
their
associated
types
This
type
is
still
compatible
with
a
variant
type
containing
more
tags
A
special
case
is
the
unknown
type
which
does
not
define
any
tag
and
is
compatible
with
any
variant
type
The
third
case
is
a
closed
variant
type
It
gives
information
about
all
the
possible
tags
and
their
associated
types
and
which
tags
are
known
to
potentially
appear
in
values
The
exact
variant
type
first
case
is
just
an
abbreviation
for
a
closed
variant
type
where
all
possible
tags
are
also
potentially
present
In
all
three
cases
tags
may
be
either
specified
directly
in
the
tag
name
of
typexpr
form
or
indirectly
through
a
type
expression
which
must
expand
to
an
exact
variant
type
whose
tag
specifications
are
inserted
in
its
place
Full
specifications
of
variant
tags
are
only
used
for
non
exact
closed
types
They
can
be
understood
as
a
conjunctive
type
for
the
argument
it
is
intended
to
have
all
the
types
enumerated
in
the
specification
Such
conjunctive
constraints
may
be
unsatisfiable
In
such
a
case
the
corresponding
tag
may
not
be
used
in
a
value
of
this
type
This
does
not
mean
that
the
whole
type
is
not
valid
one
can
still
use
other
available
tags
Conjunctive
constraints
are
mainly
intended
as
output
from
the
type
checker
When
they
are
used
in
source
programs
unsolvable
constraints
may
cause
early
failures
subsubsection
sss
typexpr
obj
Object
types
An
object
type
method
type
method
type
is
a
record
of
method
types
Each
method
may
have
an
explicit
polymorphic
type
ident
typexpr
Explicit
polymorphic
variables
have
a
local
scope
and
an
explicit
polymorphic
type
can
only
be
unified
to
an
equivalent
one
where
only
the
order
and
names
of
polymorphic
variables
may
change
The
type
method
type
is
the
type
of
an
object
whose
method
names
and
types
are
described
by
method
type
1
ldots
method
type
n
and
possibly
some
other
methods
represented
by
the
ellipsis
This
ellipsis
actually
is
a
special
kind
of
type
variable
called
em
row
variable
in
the
literature
that
stands
for
any
number
of
extra
method
types
subsubsection
sss
typexpr
sharp
types
types
The
type
classtype
path
is
a
special
kind
of
abbreviation
This
abbreviation
unifies
with
the
type
of
any
object
belonging
to
a
subclass
of
the
class
type
classtype
path
It
is
handled
in
a
special
way
as
it
usually
hides
a
type
variable
an
ellipsis
representing
the
methods
that
may
be
added
in
a
subclass
In
particular
it
vanishes
when
the
ellipsis
gets
instantiated
Each
type
expression
classtype
path
defines
a
new
type
variable
so
type
classtype
path
classtype
path
is
usually
not
the
same
as
type
classtype
path
as
ident
ident
subsubsection
sss
typexpr
variant
record
Variant
and
record
types
There
are
no
type
expressions
describing
defined
variant
types
nor
record
types
since
those
are
always
named
i
e
defined
before
use
and
referred
to
by
name
Type
definitions
are
described
in
section
ref
ss
typedefs
section
s
compilation
units
Compilation
units
HEVEA
cutname
compunit
html
begin
syntax
unit
interface
specification
unit
implementation
module
items
end
syntax
Compilation
units
bridge
the
module
system
and
the
separate
compilation
system
A
compilation
unit
is
composed
of
two
parts
an
interface
and
an
implementation
The
interface
contains
a
sequence
of
specifications
just
as
the
inside
of
a
sig
ldots
end
signature
expression
The
implementation
contains
a
sequence
of
definitions
and
expressions
just
as
the
inside
of
a
struct
ldots
end
module
expression
A
compilation
unit
also
has
a
name
unit
name
derived
from
the
names
of
the
files
containing
the
interface
and
the
implementation
see
chapter
ref
c
camlc
for
more
details
A
compilation
unit
behaves
roughly
as
the
module
definition
begin
center
module
unit
name
sig
unit
interface
end
struct
unit
implementation
end
end
center
A
compilation
unit
can
refer
to
other
compilation
units
by
their
names
as
if
they
were
regular
modules
For
instance
if
U
is
a
compilation
unit
that
defines
a
type
t
other
compilation
units
can
refer
to
that
type
under
the
name
U
t
they
can
also
refer
to
U
as
a
whole
structure
Except
for
names
of
other
compilation
units
a
unit
interface
or
unit
implementation
must
not
have
any
other
free
variables
In
other
terms
the
type
checking
and
compilation
of
an
interface
or
implementation
proceeds
in
the
initial
environment
begin
center
name
1
sig
specification
1
end
ldots
name
n
sig
specification
n
end
end
center
where
name
1
ldots
name
n
are
the
names
of
the
other
compilation
units
available
in
the
search
path
see
chapter
ref
c
camlc
for
more
details
and
specification
1
ldots
specification
n
are
their
respective
interfaces
section
s
names
Names
HEVEA
cutname
names
html
Identifiers
are
used
to
give
names
to
several
classes
of
language
objects
and
refer
to
these
objects
by
name
later
begin
itemize
item
value
names
syntactic
class
value
name
item
value
constructors
and
exception
constructors
class
constr
name
item
labels
label
name
defined
in
section
ref
sss
labelname
item
polymorphic
variant
tags
tag
name
item
type
constructors
typeconstr
name
item
record
fields
field
name
item
class
names
class
name
item
method
names
method
name
item
instance
variable
names
inst
var
name
item
module
names
module
name
item
module
type
names
modtype
name
end
itemize
These
eleven
name
spaces
are
distinguished
both
by
the
context
and
by
the
capitalization
of
the
identifier
whether
the
first
letter
of
the
identifier
is
in
lowercase
written
lowercase
ident
below
or
in
uppercase
written
capitalized
ident
Underscore
is
considered
a
lowercase
letter
for
this
purpose
subsubsection
sss
naming
objects
Naming
objects
ikwd
mod
texttt
mod
ikwd
land
texttt
land
ikwd
lor
texttt
lor
ikwd
lxor
texttt
lxor
ikwd
lsl
texttt
lsl
ikwd
lsr
texttt
lsr
ikwd
asr
texttt
asr
begin
syntax
value
name
lowercase
ident
operator
name
operator
name
prefix
symbol
infix
op
infix
op
infix
symbol
or
mod
land
lor
lxor
lsl
lsr
asr
constr
name
capitalized
ident
tag
name
capitalized
ident
typeconstr
name
lowercase
ident
field
name
lowercase
ident
module
name
capitalized
ident
modtype
name
ident
class
name
lowercase
ident
inst
var
name
lowercase
ident
method
name
lowercase
ident
end
syntax
See
also
the
following
language
extension
hyperref
s
index
operators
extended
indexing
operators
As
shown
above
prefix
and
infix
symbols
as
well
as
some
keywords
can
be
used
as
value
names
provided
they
are
written
between
parentheses
The
capitalization
rules
are
summarized
in
the
table
below
begin
tableau
l
l
Name
space
Case
of
first
letter
entree
Values
lowercase
entree
Constructors
uppercase
entree
Labels
lowercase
entree
Polymorphic
variant
tags
uppercase
entree
Exceptions
uppercase
entree
Type
constructors
lowercase
entree
Record
fields
lowercase
entree
Classes
lowercase
entree
Instance
variables
lowercase
entree
Methods
lowercase
entree
Modules
uppercase
entree
Module
types
any
end
tableau
it
Note
on
polymorphic
variant
tags
the
current
implementation
accepts
lowercase
variant
tags
in
addition
to
capitalized
variant
tags
but
we
suggest
you
avoid
lowercase
variant
tags
for
portability
and
compatibility
with
future
OCaml
versions
subsubsection
sss
refer
named
Referring
to
named
objects
begin
syntax
value
path
module
path
value
name
constr
module
path
constr
name
typeconstr
extended
module
path
typeconstr
name
field
module
path
field
name
modtype
path
extended
module
path
modtype
name
class
path
module
path
class
name
classtype
path
extended
module
path
class
name
module
path
module
name
module
name
extended
module
path
extended
module
name
extended
module
name
extended
module
name
module
name
extended
module
path
end
syntax
A
named
object
can
be
referred
to
either
by
its
name
following
the
usual
static
scoping
rules
for
names
or
by
an
access
path
prefix
name
where
prefix
designates
a
module
and
name
is
the
name
of
an
object
defined
in
that
module
The
first
component
of
the
path
prefix
is
either
a
simple
module
name
or
an
access
path
name
1
name
2
ldots
in
case
the
defining
module
is
itself
nested
inside
other
modules
For
referring
to
type
constructors
module
types
or
class
types
the
prefix
can
also
contain
simple
functor
applications
as
in
the
syntactic
class
extended
module
path
above
in
case
the
defining
module
is
the
result
of
a
functor
application
Label
names
tag
names
method
names
and
instance
variable
names
need
not
be
qualified
the
former
three
are
global
labels
while
the
latter
are
local
to
a
class
section
s
const
Constants
HEVEA
cutname
const
html
ikwd
false
texttt
false
ikwd
true
texttt
true
ikwd
begin
texttt
begin
ikwd
end
texttt
end
begin
syntax
constant
integer
literal
int32
literal
int64
literal
nativeint
literal
float
literal
char
literal
string
literal
constr
false
true
begin
end
tag
name
end
syntax
See
also
the
following
language
extension
hyperref
ss
extension
literals
extension
literals
The
syntactic
class
of
constants
comprises
literals
from
the
four
base
types
integers
floating
point
numbers
characters
character
strings
the
integer
variants
and
constant
constructors
from
both
normal
and
polymorphic
variants
as
well
as
the
special
constants
false
true
and
which
behave
like
constant
constructors
and
begin
end
which
is
equivalent
to
makeindex
jobname
makeindex
jobname
kwd
setlength
emergencystretch
50pt
pour
que
TeX
resolve
les
overfull
hbox
lui
meme
begin
document
thispagestyle
empty
begin
maintitle
vfill
Huge
The
OCaml
system
release
ocamlversion
1cm
Large
Documentation
and
user
s
manual
1cm
large
Xavier
Leroy
Damien
Doligez
Alain
Frisch
Jacques
Garrigue
Didier
Rmy
KC
Sivaramakrishnan
and
Jrme
Vouillon
1cm
today
vfill
normalsize
Copyright
copyright
number
year
Institut
National
de
Recherche
en
Informatique
et
en
Automatique
end
maintitle
cleardoublepage
setcounter
page
1
begin
htmlonly
begin
maintitle
vspace
2ex
This
manual
is
also
available
in
ahref
https
ocaml
org
releases
ocamlversion
ocaml
ocamlversion
refman
pdf
PDF
ahref
https
ocaml
org
releases
ocamlversion
ocaml
ocamlversion
refman
txt
plain
text
as
a
ahref
https
ocaml
org
releases
ocamlversion
ocaml
ocamlversion
refman
html
tar
gz
bundle
of
HTML
files
and
as
a
ahref
https
ocaml
org
releases
ocamlversion
ocaml
ocamlversion
refman
info
tar
gz
bundle
of
Emacs
Info
files
end
maintitle
end
htmlonly
tableofcontents
input
foreword
tex
part
An
introduction
to
OCaml
label
p
tutorials
input
coreexamples
tex
input
moduleexamples
tex
input
objectexamples
tex
input
lablexamples
tex
input
polyvariant
tex
input
polymorphism
tex
input
gadtexamples
tex
input
advexamples
tex
input
parallelism
tex
input
memorymodel
tex
part
The
OCaml
language
label
p
refman
input
refman
tex
input
exten
tex
part
The
OCaml
tools
label
p
commands
input
comp
tex
input
top
tex
input
runtime
tex
input
native
tex
input
lexyacc
tex
input
ocamldep
tex
input
ocamldoc
tex
input
debugger
tex
input
native
debugger
tex
input
profil
tex
input
intf
c
tex
input
flambda
tex
input
afl
fuzz
tex
input
runtime
tracing
tex
input
tail
mod
cons
tex
input
tsan
tex
part
The
OCaml
library
label
p
library
input
core
tex
input
stdlib
blurb
tex
input
compilerlibs
tex
input
libunix
tex
input
libstr
tex
input
libruntime
events
tex
input
libthreads
tex
input
libdynlink
tex
input
old
tex
part
Indexes
label
p
indexes
ifouthtml
begin
links
item
ahref
libref
index
modules
html
Index
of
modules
item
ahref
libref
index
module
types
html
Index
of
module
types
item
ahref
libref
index
types
html
Index
of
types
item
ahref
libref
index
exceptions
html
Index
of
exceptions
item
ahref
libref
index
values
html
Index
of
values
end
links
else
printindex
jobname
Index
to
the
library
fi
printindex
jobname
kwd
Index
of
keywords
end
document
chapter
Objects
in
OCaml
label
c
objectexamples
HEVEA
cutname
objectexamples
html
it
Chapter
written
by
Jrme
Vouillon
Didier
Rmy
and
Jacques
Garrigue
bigskip
noindent
This
chapter
gives
an
overview
of
the
object
oriented
features
of
OCaml
Note
that
the
relationship
between
object
class
and
type
in
OCaml
is
different
than
in
mainstream
object
oriented
languages
such
as
Java
and
C
so
you
shouldn
t
assume
that
similar
keywords
mean
the
same
thing
Object
oriented
features
are
used
much
less
frequently
in
OCaml
than
in
those
languages
OCaml
has
alternatives
that
are
often
more
appropriate
such
as
modules
and
functors
Indeed
many
OCaml
programs
do
not
use
objects
at
all
section
s
classes
and
objects
Classes
and
objects
The
class
point
below
defines
one
instance
variable
x
and
two
methods
get
x
and
move
The
initial
value
of
the
instance
variable
is
0
The
variable
x
is
declared
mutable
so
the
method
move
can
change
its
value
begin
caml
example
toplevel
class
point
object
val
mutable
x
0
method
get
x
x
method
move
d
x
x
d
end
end
caml
example
We
now
create
a
new
point
p
instance
of
the
point
class
begin
caml
example
toplevel
let
p
new
point
end
caml
example
Note
that
the
type
of
p
is
point
This
is
an
abbreviation
automatically
defined
by
the
class
definition
above
It
stands
for
the
object
type
get
x
int
move
int
unit
listing
the
methods
of
class
point
along
with
their
types
We
now
invoke
some
methods
of
p
begin
caml
example
toplevel
p
get
x
p
move
3
p
get
x
end
caml
example
The
evaluation
of
the
body
of
a
class
only
takes
place
at
object
creation
time
Therefore
in
the
following
example
the
instance
variable
x
is
initialized
to
different
values
for
two
different
objects
begin
caml
example
toplevel
let
x0
ref
0
class
point
object
val
mutable
x
incr
x0
x0
method
get
x
x
method
move
d
x
x
d
end
new
point
get
x
new
point
get
x
end
caml
example
The
class
point
can
also
be
abstracted
over
the
initial
values
of
the
x
coordinate
begin
caml
example
toplevel
class
point
fun
x
init
object
val
mutable
x
x
init
method
get
x
x
method
move
d
x
x
d
end
end
caml
example
Like
in
function
definitions
the
definition
above
can
be
abbreviated
as
begin
caml
example
toplevel
class
point
x
init
object
val
mutable
x
x
init
method
get
x
x
method
move
d
x
x
d
end
end
caml
example
An
instance
of
the
class
point
is
now
a
function
that
expects
an
initial
parameter
to
create
a
point
object
begin
caml
example
toplevel
new
point
let
p
new
point
7
end
caml
example
The
parameter
x
init
is
of
course
visible
in
the
whole
body
of
the
definition
including
methods
For
instance
the
method
get
offset
in
the
class
below
returns
the
position
of
the
object
relative
to
its
initial
position
begin
caml
example
toplevel
class
point
x
init
object
val
mutable
x
x
init
method
get
x
x
method
get
offset
x
x
init
method
move
d
x
x
d
end
end
caml
example
Instance
variables
can
only
be
used
inside
methods
For
instance
it
would
not
be
possible
to
define
begin
caml
example
toplevel
class
point
x
init
object
val
mutable
x
x
init
val
origin
x
method
get
offset
x
origin
method
move
d
x
x
d
end
end
caml
example
Expressions
can
be
evaluated
and
bound
before
defining
the
object
body
of
the
class
This
is
useful
to
enforce
invariants
For
instance
points
can
be
automatically
adjusted
to
the
nearest
point
on
a
grid
as
follows
begin
caml
example
toplevel
class
adjusted
point
x
init
let
origin
x
init
10
10
in
object
val
mutable
x
origin
method
get
x
x
method
get
offset
x
origin
method
move
d
x
x
d
end
end
caml
example
One
could
also
raise
an
exception
if
the
x
init
coordinate
is
not
on
the
grid
In
fact
the
same
effect
could
be
obtained
here
by
calling
the
definition
of
class
point
with
the
value
of
the
origin
begin
caml
example
toplevel
class
adjusted
point
x
init
point
x
init
10
10
end
caml
example
An
alternate
solution
would
have
been
to
define
the
adjustment
in
a
special
allocation
function
begin
caml
example
toplevel
let
new
adjusted
point
x
init
new
point
x
init
10
10
end
caml
example
However
the
former
pattern
is
generally
more
appropriate
since
the
code
for
adjustment
is
part
of
the
definition
of
the
class
and
will
be
inherited
This
ability
provides
class
constructors
as
can
be
found
in
other
languages
Several
constructors
can
be
defined
this
way
to
build
objects
of
the
same
class
but
with
different
initialization
patterns
an
alternative
is
to
use
initializers
as
described
below
in
section
ref
s
initializers
section
s
immediate
objects
Immediate
objects
There
is
another
more
direct
way
to
create
an
object
create
it
without
going
through
a
class
The
syntax
is
exactly
the
same
as
for
class
expressions
but
the
result
is
a
single
object
rather
than
a
class
All
the
constructs
described
in
the
rest
of
this
section
also
apply
to
immediate
objects
begin
caml
example
toplevel
let
p
object
val
mutable
x
0
method
get
x
x
method
move
d
x
x
d
end
p
get
x
p
move
3
p
get
x
end
caml
example
Unlike
classes
which
cannot
be
defined
inside
an
expression
immediate
objects
can
appear
anywhere
using
variables
from
their
environment
begin
caml
example
toplevel
let
minmax
x
y
if
x
y
then
object
method
min
x
method
max
y
end
else
object
method
min
y
method
max
x
end
end
caml
example
Immediate
objects
have
two
weaknesses
compared
to
classes
their
types
are
not
abbreviated
and
you
cannot
inherit
from
them
But
these
two
weaknesses
can
be
advantages
in
some
situations
as
we
will
see
in
sections
ref
s
reference
to
self
and
ref
s
parameterized
classes
section
s
reference
to
self
Reference
to
self
A
method
or
an
initializer
can
invoke
methods
on
self
that
is
the
current
object
For
that
self
must
be
explicitly
bound
here
to
the
variable
s
s
could
be
any
identifier
even
though
we
will
often
choose
the
name
self
begin
caml
example
toplevel
class
printable
point
x
init
object
s
val
mutable
x
x
init
method
get
x
x
method
move
d
x
x
d
method
print
print
int
s
get
x
end
let
p
new
printable
point
7
p
print
end
caml
example
Dynamically
the
variable
s
is
bound
at
the
invocation
of
a
method
In
particular
when
the
class
printable
point
is
inherited
the
variable
s
will
be
correctly
bound
to
the
object
of
the
subclass
A
common
problem
with
self
is
that
as
its
type
may
be
extended
in
subclasses
you
cannot
fix
it
in
advance
Here
is
a
simple
example
begin
caml
example
toplevel
let
ints
ref
class
my
int
object
self
method
n
1
method
register
ints
self
ints
end
expect
error
end
caml
example
You
can
ignore
the
first
two
lines
of
the
error
message
What
matters
is
the
last
one
putting
self
into
an
external
reference
would
make
it
impossible
to
extend
it
through
inheritance
We
will
see
in
section
ref
s
using
coercions
a
workaround
to
this
problem
Note
however
that
since
immediate
objects
are
not
extensible
the
problem
does
not
occur
with
them
begin
caml
example
toplevel
let
my
int
object
self
method
n
1
method
register
ints
self
ints
end
end
caml
example
section
s
initializers
Initializers
Let
bindings
within
class
definitions
are
evaluated
before
the
object
is
constructed
It
is
also
possible
to
evaluate
an
expression
immediately
after
the
object
has
been
built
Such
code
is
written
as
an
anonymous
hidden
method
called
an
initializer
Therefore
it
can
access
self
and
the
instance
variables
begin
caml
example
toplevel
class
printable
point
x
init
let
origin
x
init
10
10
in
object
self
val
mutable
x
origin
method
get
x
x
method
move
d
x
x
d
method
print
print
int
self
get
x
initializer
print
string
new
point
at
self
print
print
newline
end
let
p
new
printable
point
17
end
caml
example
Initializers
cannot
be
overridden
On
the
contrary
all
initializers
are
evaluated
sequentially
Initializers
are
particularly
useful
to
enforce
invariants
Another
example
can
be
seen
in
section
ref
s
extended
bank
accounts
section
s
virtual
methods
Virtual
methods
It
is
possible
to
declare
a
method
without
actually
defining
it
using
the
keyword
virtual
This
method
will
be
provided
later
in
subclasses
A
class
containing
virtual
methods
must
be
flagged
virtual
and
cannot
be
instantiated
that
is
no
object
of
this
class
can
be
created
It
still
defines
type
abbreviations
treating
virtual
methods
as
other
methods
begin
caml
example
toplevel
class
virtual
abstract
point
x
init
object
self
method
virtual
get
x
int
method
get
offset
self
get
x
x
init
method
virtual
move
int
unit
end
class
point
x
init
object
inherit
abstract
point
x
init
val
mutable
x
x
init
method
get
x
x
method
move
d
x
x
d
end
end
caml
example
Instance
variables
can
also
be
declared
as
virtual
with
the
same
effect
as
with
methods
begin
caml
example
toplevel
class
virtual
abstract
point2
object
val
mutable
virtual
x
int
method
move
d
x
x
d
end
class
point2
x
init
object
inherit
abstract
point2
val
mutable
x
x
init
method
get
offset
x
x
init
end
end
caml
example
section
s
private
methods
Private
methods
Private
methods
are
methods
that
do
not
appear
in
object
interfaces
They
can
only
be
invoked
from
other
methods
of
the
same
object
begin
caml
example
toplevel
class
restricted
point
x
init
object
self
val
mutable
x
x
init
method
get
x
x
method
private
move
d
x
x
d
method
bump
self
move
1
end
let
p
new
restricted
point
0
p
move
10
expect
error
p
bump
end
caml
example
Note
that
this
is
not
the
same
thing
as
private
and
protected
methods
in
Java
or
C
which
can
be
called
from
other
objects
of
the
same
class
This
is
a
direct
consequence
of
the
independence
between
types
and
classes
in
OCaml
two
unrelated
classes
may
produce
objects
of
the
same
type
and
there
is
no
way
at
the
type
level
to
ensure
that
an
object
comes
from
a
specific
class
However
a
possible
encoding
of
friend
methods
is
given
in
section
ref
s
friends
Private
methods
are
inherited
they
are
by
default
visible
in
subclasses
unless
they
are
hidden
by
signature
matching
as
described
below
Private
methods
can
be
made
public
in
a
subclass
begin
caml
example
toplevel
class
point
again
x
object
self
inherit
restricted
point
x
method
virtual
move
end
end
caml
example
The
annotation
virtual
here
is
only
used
to
mention
a
method
without
providing
its
definition
Since
we
didn
t
add
the
private
annotation
this
makes
the
method
public
keeping
the
original
definition
An
alternative
definition
is
begin
caml
example
toplevel
class
point
again
x
object
self
move
inherit
restricted
point
x
end
end
caml
example
The
constraint
on
self
s
type
is
requiring
a
public
move
method
and
this
is
sufficient
to
override
private
One
could
think
that
a
private
method
should
remain
private
in
a
subclass
However
since
the
method
is
visible
in
a
subclass
it
is
always
possible
to
pick
its
code
and
define
a
method
of
the
same
name
that
runs
that
code
so
yet
another
heavier
solution
would
be
begin
caml
example
toplevel
class
point
again
x
object
inherit
restricted
point
x
as
super
method
move
super
move
end
end
caml
example
Of
course
private
methods
can
also
be
virtual
Then
the
keywords
must
appear
in
this
order
method
private
virtual
section
s
class
interfaces
Class
interfaces
XXX
Differentiate
class
type
and
class
interface
Class
interfaces
are
inferred
from
class
definitions
They
may
also
be
defined
directly
and
used
to
restrict
the
type
of
a
class
Like
class
declarations
they
also
define
a
new
type
abbreviation
begin
caml
example
toplevel
class
type
restricted
point
type
object
method
get
x
int
method
bump
unit
end
fun
x
restricted
point
type
x
end
caml
example
In
addition
to
program
documentation
class
interfaces
can
be
used
to
constrain
the
type
of
a
class
Both
concrete
instance
variables
and
concrete
private
methods
can
be
hidden
by
a
class
type
constraint
Public
methods
and
virtual
members
however
cannot
begin
caml
example
toplevel
class
restricted
point
x
restricted
point
x
restricted
point
type
end
caml
example
Or
equivalently
begin
caml
example
toplevel
class
restricted
point
restricted
point
int
restricted
point
type
end
caml
example
The
interface
of
a
class
can
also
be
specified
in
a
module
signature
and
used
to
restrict
the
inferred
signature
of
a
module
begin
caml
example
toplevel
module
type
POINT
sig
class
restricted
point
int
object
method
get
x
int
method
bump
unit
end
end
module
Point
POINT
struct
class
restricted
point
restricted
point
end
end
caml
example
section
s
inheritance
Inheritance
We
illustrate
inheritance
by
defining
a
class
of
colored
points
that
inherits
from
the
class
of
points
This
class
has
all
instance
variables
and
all
methods
of
class
point
plus
a
new
instance
variable
c
and
a
new
method
color
begin
caml
example
toplevel
class
colored
point
x
c
string
object
inherit
point
x
val
c
c
method
color
c
end
let
p
new
colored
point
5
red
p
get
x
p
color
end
caml
example
A
point
and
a
colored
point
have
incompatible
types
since
a
point
has
no
method
color
However
the
function
get
succ
x
below
is
a
generic
function
applying
method
get
x
to
any
object
p
that
has
this
method
and
possibly
some
others
which
are
represented
by
an
ellipsis
in
the
type
Thus
it
applies
to
both
points
and
colored
points
begin
caml
example
toplevel
let
get
succ
x
p
p
get
x
1
get
succ
x
p
get
succ
x
p
end
caml
example
Methods
need
not
be
declared
previously
as
shown
by
the
example
begin
caml
example
toplevel
let
set
x
p
p
set
x
let
incr
p
set
x
p
get
succ
x
p
end
caml
example
section
s
multiple
inheritance
Multiple
inheritance
Multiple
inheritance
is
allowed
Only
the
last
definition
of
a
method
is
kept
the
redefinition
in
a
subclass
of
a
method
that
was
visible
in
the
parent
class
overrides
the
definition
in
the
parent
class
Previous
definitions
of
a
method
can
be
reused
by
binding
the
related
ancestor
Below
super
is
bound
to
the
ancestor
printable
point
The
name
super
is
a
pseudo
value
identifier
that
can
only
be
used
to
invoke
a
super
class
method
as
in
super
print
begin
caml
example
toplevel
class
printable
colored
point
y
c
object
self
val
c
c
method
color
c
inherit
printable
point
y
as
super
method
print
print
string
super
print
print
string
print
string
self
color
print
string
end
let
p
new
printable
colored
point
17
red
p
print
end
caml
example
A
private
method
that
has
been
hidden
in
the
parent
class
is
no
longer
visible
and
is
thus
not
overridden
Since
initializers
are
treated
as
private
methods
all
initializers
along
the
class
hierarchy
are
evaluated
in
the
order
they
are
introduced
Note
that
for
clarity
s
sake
the
method
print
is
explicitly
marked
as
overriding
another
definition
by
annotating
the
method
keyword
with
an
exclamation
mark
If
the
method
print
were
not
overriding
the
print
method
of
printable
point
the
compiler
would
raise
an
error
begin
caml
example
toplevel
error
object
method
m
end
end
caml
example
This
explicit
overriding
annotation
also
works
for
val
and
inherit
begin
caml
example
toplevel
class
another
printable
colored
point
y
c
c
object
self
inherit
printable
point
y
inherit
printable
colored
point
y
c
val
c
c
end
end
caml
example
section
s
parameterized
classes
Parameterized
classes
Reference
cells
can
be
implemented
as
objects
The
naive
definition
fails
to
typecheck
begin
caml
example
toplevel
error
class
oref
x
init
object
val
mutable
x
x
init
method
get
x
method
set
y
x
y
end
end
caml
example
The
reason
is
that
at
least
one
of
the
methods
has
a
polymorphic
type
here
the
type
of
the
value
stored
in
the
reference
cell
thus
either
the
class
should
be
parametric
or
the
method
type
should
be
constrained
to
a
monomorphic
type
A
monomorphic
instance
of
the
class
could
be
defined
by
begin
caml
example
toplevel
class
oref
x
init
int
object
val
mutable
x
x
init
method
get
x
method
set
y
x
y
end
end
caml
example
Note
that
since
immediate
objects
do
not
define
a
class
type
they
have
no
such
restriction
begin
caml
example
toplevel
let
new
oref
x
init
object
val
mutable
x
x
init
method
get
x
method
set
y
x
y
end
end
caml
example
On
the
other
hand
a
class
for
polymorphic
references
must
explicitly
list
the
type
parameters
in
its
declaration
Class
type
parameters
are
listed
between
and
The
type
parameters
must
also
be
bound
somewhere
in
the
class
body
by
a
type
constraint
begin
caml
example
toplevel
class
a
oref
x
init
object
val
mutable
x
x
init
a
method
get
x
method
set
y
x
y
end
let
r
new
oref
1
in
r
set
2
r
get
end
caml
example
The
type
parameter
in
the
declaration
may
actually
be
constrained
in
the
body
of
the
class
definition
In
the
class
type
the
actual
value
of
the
type
parameter
is
displayed
in
the
constraint
clause
begin
caml
example
toplevel
class
a
oref
succ
x
init
a
object
val
mutable
x
x
init
1
method
get
x
method
set
y
x
y
end
end
caml
example
Let
us
consider
a
more
complex
example
define
a
circle
whose
center
may
be
any
kind
of
point
We
put
an
additional
type
constraint
in
method
move
since
no
free
variables
must
remain
unaccounted
for
by
the
class
type
parameters
begin
caml
example
toplevel
class
a
circle
c
a
object
val
mutable
center
c
method
center
center
method
set
center
c
center
c
method
move
center
move
int
unit
end
end
caml
example
An
alternate
definition
of
circle
using
a
constraint
clause
in
the
class
definition
is
shown
below
The
type
point
used
below
in
the
constraint
clause
is
an
abbreviation
produced
by
the
definition
of
class
point
This
abbreviation
unifies
with
the
type
of
any
object
belonging
to
a
subclass
of
class
point
It
actually
expands
to
get
x
int
move
int
unit
This
leads
to
the
following
alternate
definition
of
circle
which
has
slightly
stronger
constraints
on
its
argument
as
we
now
expect
center
to
have
a
method
get
x
begin
caml
example
toplevel
class
a
circle
c
a
object
constraint
a
point
val
mutable
center
c
method
center
center
method
set
center
c
center
c
method
move
center
move
end
end
caml
example
The
class
colored
circle
is
a
specialized
version
of
class
circle
that
requires
the
type
of
the
center
to
unify
with
colored
point
and
adds
a
method
color
Note
that
when
specializing
a
parameterized
class
the
instance
of
type
parameter
must
always
be
explicitly
given
It
is
again
written
between
and
begin
caml
example
toplevel
class
a
colored
circle
c
object
constraint
a
colored
point
inherit
a
circle
c
method
color
center
color
end
end
caml
example
section
s
polymorphic
methods
Polymorphic
methods
While
parameterized
classes
may
be
polymorphic
in
their
contents
they
are
not
enough
to
allow
polymorphism
of
method
use
A
classical
example
is
defining
an
iterator
begin
caml
example
toplevel
List
fold
left
class
a
intlist
l
int
list
object
method
empty
l
method
fold
f
accu
a
List
fold
left
f
accu
l
end
end
caml
example
At
first
look
we
seem
to
have
a
polymorphic
iterator
however
this
does
not
work
in
practice
begin
caml
example
toplevel
let
l
new
intlist
1
2
3
l
fold
fun
x
y
x
y
0
l
l
fold
fun
s
x
s
Int
to
string
x
expect
error
end
caml
example
Our
iterator
works
as
shows
its
first
use
for
summation
However
since
objects
themselves
are
not
polymorphic
only
their
constructors
are
using
the
fold
method
fixes
its
type
for
this
individual
object
Our
next
attempt
to
use
it
as
a
string
iterator
fails
The
problem
here
is
that
quantification
was
wrongly
located
it
is
not
the
class
we
want
to
be
polymorphic
but
the
fold
method
This
can
be
achieved
by
giving
an
explicitly
polymorphic
type
in
the
method
definition
begin
caml
example
toplevel
class
intlist
l
int
list
object
method
empty
l
method
fold
a
a
int
a
a
a
fun
f
accu
List
fold
left
f
accu
l
end
let
l
new
intlist
1
2
3
l
fold
fun
x
y
x
y
0
l
fold
fun
s
x
s
Int
to
string
x
end
caml
example
As
you
can
see
in
the
class
type
shown
by
the
compiler
while
polymorphic
method
types
must
be
fully
explicit
in
class
definitions
appearing
immediately
after
the
method
name
quantified
type
variables
can
be
left
implicit
in
class
descriptions
Why
require
types
to
be
explicit
The
problem
is
that
int
int
int
int
int
would
also
be
a
valid
type
for
fold
and
it
happens
to
be
incompatible
with
the
polymorphic
type
we
gave
automatic
instantiation
only
works
for
toplevel
types
variables
not
for
inner
quantifiers
where
it
becomes
an
undecidable
problem
So
the
compiler
cannot
choose
between
those
two
types
and
must
be
helped
However
the
type
can
be
completely
omitted
in
the
class
definition
if
it
is
already
known
through
inheritance
or
type
constraints
on
self
Here
is
an
example
of
method
overriding
begin
caml
example
toplevel
class
intlist
rev
l
object
inherit
intlist
l
method
fold
f
accu
List
fold
left
f
accu
List
rev
l
end
end
caml
example
The
following
idiom
separates
description
and
definition
begin
caml
example
toplevel
class
type
a
iterator
object
method
fold
b
a
b
b
b
end
class
intlist
l
object
self
int
iterator
method
empty
l
method
fold
f
accu
List
fold
left
f
accu
l
end
end
caml
example
Note
here
the
self
int
iterator
idiom
which
ensures
that
this
object
implements
the
interface
iterator
Polymorphic
methods
are
called
in
exactly
the
same
way
as
normal
methods
but
you
should
be
aware
of
some
limitations
of
type
inference
Namely
a
polymorphic
method
can
only
be
called
if
its
type
is
known
at
the
call
site
Otherwise
the
method
will
be
assumed
to
be
monomorphic
and
given
an
incompatible
type
begin
caml
example
toplevel
let
sum
lst
lst
fold
fun
x
y
x
y
0
sum
l
expect
error
end
caml
example
The
workaround
is
easy
you
should
put
a
type
constraint
on
the
parameter
begin
caml
example
toplevel
let
sum
lst
iterator
lst
fold
fun
x
y
x
y
0
end
caml
example
Of
course
the
constraint
may
also
be
an
explicit
method
type
Only
occurrences
of
quantified
variables
are
required
begin
caml
example
toplevel
let
sum
lst
lst
fold
a
a
a
a
a
fold
0
end
caml
example
Another
use
of
polymorphic
methods
is
to
allow
some
form
of
implicit
subtyping
in
method
arguments
We
have
already
seen
in
section
ref
s
inheritance
how
some
functions
may
be
polymorphic
in
the
class
of
their
argument
This
can
be
extended
to
methods
begin
caml
example
toplevel
class
type
point0
object
method
get
x
int
end
class
distance
point
x
object
inherit
point
x
method
distance
a
point0
as
a
int
fun
other
abs
other
get
x
x
end
let
p
new
distance
point
3
in
p
distance
new
point
8
p
distance
new
colored
point
1
blue
end
caml
example
Note
here
the
special
syntax
point0
as
a
we
have
to
use
to
quantify
the
extensible
part
of
point0
As
for
the
variable
binder
it
can
be
omitted
in
class
specifications
If
you
want
polymorphism
inside
object
field
it
must
be
quantified
independently
begin
caml
example
toplevel
class
multi
poly
object
method
m1
a
n1
b
b
b
as
a
fun
o
o
n1
true
o
n1
hello
method
m2
a
b
n2
b
bool
as
a
b
fun
o
x
o
n2
x
end
end
caml
example
In
method
m1
o
must
be
an
object
with
at
least
a
method
n1
itself
polymorphic
In
method
m2
the
argument
of
n2
and
x
must
have
the
same
type
which
is
quantified
at
the
same
level
as
a
section
s
using
coercions
Using
coercions
Subtyping
is
never
implicit
There
are
however
two
ways
to
perform
subtyping
The
most
general
construction
is
fully
explicit
both
the
domain
and
the
codomain
of
the
type
coercion
must
be
given
We
have
seen
that
points
and
colored
points
have
incompatible
types
For
instance
they
cannot
be
mixed
in
the
same
list
However
a
colored
point
can
be
coerced
to
a
point
hiding
its
color
method
begin
caml
example
toplevel
let
colored
point
to
point
cp
cp
colored
point
point
let
p
new
point
3
and
q
new
colored
point
4
blue
let
l
p
colored
point
to
point
q
end
caml
example
An
object
of
type
t
can
be
seen
as
an
object
of
type
t
only
if
t
is
a
subtype
of
t
For
instance
a
point
cannot
be
seen
as
a
colored
point
begin
caml
example
toplevel
error
p
point
colored
point
end
caml
example
Indeed
narrowing
coercions
without
runtime
checks
would
be
unsafe
Runtime
type
checks
might
raise
exceptions
and
they
would
require
the
presence
of
type
information
at
runtime
which
is
not
the
case
in
the
OCaml
system
For
these
reasons
there
is
no
such
operation
available
in
the
language
Be
aware
that
subtyping
and
inheritance
are
not
related
Inheritance
is
a
syntactic
relation
between
classes
while
subtyping
is
a
semantic
relation
between
types
For
instance
the
class
of
colored
points
could
have
been
defined
directly
without
inheriting
from
the
class
of
points
the
type
of
colored
points
would
remain
unchanged
and
thus
still
be
a
subtype
of
points
Conversely
the
class
int
comparable
inherits
from
class
comparable
but
type
int
comparable
is
not
a
subtype
of
comparable
begin
caml
example
toplevel
fun
x
x
int
comparable
comparable
end
caml
example
The
domain
of
a
coercion
can
often
be
omitted
For
instance
one
can
define
begin
caml
example
toplevel
let
to
point
cp
cp
point
end
caml
example
In
this
case
the
function
colored
point
to
point
is
an
instance
of
the
function
to
point
This
is
not
always
true
however
The
fully
explicit
coercion
is
more
precise
and
is
sometimes
unavoidable
Consider
for
example
the
following
class
begin
caml
example
toplevel
class
c0
object
method
m
method
n
0
end
end
caml
example
The
object
type
c0
is
an
abbreviation
for
m
a
n
int
as
a
Consider
now
the
type
declaration
begin
caml
example
toplevel
class
type
c1
object
method
m
c1
end
end
caml
example
The
object
type
c1
is
an
abbreviation
for
the
type
m
a
as
a
The
coercion
from
an
object
of
type
c0
to
an
object
of
type
c1
is
correct
begin
caml
example
toplevel
fun
x
c0
x
c0
c1
end
caml
example
FIXME
come
up
with
a
better
example
However
the
domain
of
the
coercion
cannot
be
omitted
here
begin
caml
example
toplevel
fun
x
c0
x
c1
end
caml
example
However
the
domain
of
the
coercion
cannot
always
be
omitted
In
that
case
the
solution
is
to
use
the
explicit
form
Sometimes
a
change
in
the
class
type
definition
can
also
solve
the
problem
begin
caml
example
toplevel
class
type
c2
object
a
method
m
a
end
fun
x
c0
x
c2
end
caml
example
While
class
types
c1
and
c2
are
different
both
object
types
c1
and
c2
expand
to
the
same
object
type
same
method
names
and
types
Yet
when
the
domain
of
a
coercion
is
left
implicit
and
its
co
domain
is
an
abbreviation
of
a
known
class
type
then
the
class
type
rather
than
the
object
type
is
used
to
derive
the
coercion
function
This
allows
leaving
the
domain
implicit
in
most
cases
when
coercing
from
a
subclass
to
its
superclass
The
type
of
a
coercion
can
always
be
seen
as
below
begin
caml
example
toplevel
let
to
c1
x
x
c1
let
to
c2
x
x
c2
end
caml
example
Note
the
difference
between
these
two
coercions
in
the
case
of
to
c2
the
type
c2
m
a
as
a
is
polymorphically
recursive
according
to
the
explicit
recursion
in
the
class
type
of
c2
hence
the
success
of
applying
this
coercion
to
an
object
of
class
c0
On
the
other
hand
in
the
first
case
c1
was
only
expanded
and
unrolled
twice
to
obtain
m
m
c1
remember
c1
m
c1
without
introducing
recursion
You
may
also
note
that
the
type
of
to
c2
is
c2
c2
while
the
type
of
to
c1
is
more
general
than
c1
c1
This
is
not
always
true
since
there
are
class
types
for
which
some
instances
of
c
are
not
subtypes
of
c
as
explained
in
section
ref
s
binary
methods
Yet
for
parameterless
classes
the
coercion
c
is
always
more
general
than
c
c
If
a
class
type
exposes
the
type
of
self
through
one
of
its
parameters
this
is
no
longer
true
Here
is
a
counter
example
begin
caml
example
toplevel
class
type
a
c
object
a
method
m
a
end
let
to
c
x
x
c
end
caml
example
A
common
problem
may
occur
when
one
tries
to
define
a
coercion
to
a
class
c
while
defining
class
c
The
problem
is
due
to
the
type
abbreviation
not
being
completely
defined
yet
and
so
its
subtypes
are
not
clearly
known
Then
a
coercion
c
or
c
c
is
taken
to
be
the
identity
function
as
in
begin
caml
example
toplevel
fun
x
x
a
end
caml
example
As
a
consequence
if
the
coercion
is
applied
to
self
as
in
the
following
example
the
type
of
self
is
unified
with
the
closed
type
c
a
closed
object
type
is
an
object
type
without
ellipsis
This
would
constrain
the
type
of
self
be
closed
and
is
thus
rejected
Indeed
the
type
of
self
cannot
be
closed
this
would
prevent
any
further
extension
of
the
class
Therefore
a
type
error
is
generated
when
the
unification
of
this
type
with
another
type
would
result
in
a
closed
object
type
begin
caml
example
toplevel
error
class
c
object
method
m
1
end
and
d
object
self
inherit
c
method
n
2
method
as
c
self
c
end
end
caml
example
However
the
most
common
instance
of
this
problem
coercing
self
to
its
current
class
is
detected
as
a
special
case
by
the
type
checker
and
properly
typed
begin
caml
example
toplevel
class
c
object
self
method
m
self
c
end
end
caml
example
This
allows
the
following
idiom
keeping
a
list
of
all
objects
belonging
to
a
class
or
its
subclasses
begin
caml
example
toplevel
let
all
c
ref
class
c
m
int
object
self
method
m
m
initializer
all
c
self
c
all
c
end
end
caml
example
This
idiom
can
in
turn
be
used
to
retrieve
an
object
whose
type
has
been
weakened
begin
caml
example
toplevel
let
rec
lookup
obj
obj
function
raise
Not
found
obj
l
if
obj
obj
then
obj
else
lookup
obj
obj
l
let
lookup
c
obj
lookup
obj
obj
all
c
end
caml
example
The
type
m
int
we
see
here
is
just
the
expansion
of
c
due
to
the
use
of
a
reference
we
have
succeeded
in
getting
back
an
object
of
type
c
medskip
The
previous
coercion
problem
can
often
be
avoided
by
first
defining
the
abbreviation
using
a
class
type
begin
caml
example
toplevel
class
type
c
object
method
m
int
end
class
c
c
object
method
m
1
end
and
d
object
self
inherit
c
method
n
2
method
as
c
self
c
end
end
caml
example
It
is
also
possible
to
use
a
virtual
class
Inheriting
from
this
class
simultaneously
forces
all
methods
of
c
to
have
the
same
type
as
the
methods
of
c
begin
caml
example
toplevel
class
virtual
c
object
method
virtual
m
int
end
class
c
object
self
inherit
c
method
m
1
end
end
caml
example
One
could
think
of
defining
the
type
abbreviation
directly
begin
caml
example
toplevel
type
c
m
int
end
caml
example
However
the
abbreviation
c
cannot
be
defined
directly
in
a
similar
way
It
can
only
be
defined
by
a
class
or
a
class
type
definition
This
is
because
a
abbreviation
carries
an
implicit
anonymous
variable
that
cannot
be
explicitly
named
The
closer
you
get
to
it
is
begin
caml
example
toplevel
type
a
c
class
a
constraint
a
m
int
end
caml
example
with
an
extra
type
variable
capturing
the
open
object
type
section
s
functional
objects
Functional
objects
It
is
possible
to
write
a
version
of
class
point
without
assignments
on
the
instance
variables
The
override
construct
returns
a
copy
of
self
that
is
the
current
object
possibly
changing
the
value
of
some
instance
variables
begin
caml
example
toplevel
class
functional
point
y
object
val
x
y
method
get
x
x
method
move
d
x
x
d
method
move
to
x
x
end
let
p
new
functional
point
7
p
get
x
p
move
3
get
x
p
move
to
15
get
x
p
get
x
end
caml
example
As
with
records
the
form
x
is
an
elided
version
of
x
x
which
avoids
the
repetition
of
the
instance
variable
name
Note
that
the
type
abbreviation
functional
point
is
recursive
which
can
be
seen
in
the
class
type
of
functional
point
the
type
of
self
is
a
and
a
appears
inside
the
type
of
the
method
move
The
above
definition
of
functional
point
is
not
equivalent
to
the
following
begin
caml
example
toplevel
class
bad
functional
point
y
object
val
x
y
method
get
x
x
method
move
d
new
bad
functional
point
x
d
method
move
to
x
new
bad
functional
point
x
end
end
caml
example
While
objects
of
either
class
will
behave
the
same
objects
of
their
subclasses
will
be
different
In
a
subclass
of
bad
functional
point
the
method
move
will
keep
returning
an
object
of
the
parent
class
On
the
contrary
in
a
subclass
of
functional
point
the
method
move
will
return
an
object
of
the
subclass
Functional
update
is
often
used
in
conjunction
with
binary
methods
as
illustrated
in
section
ref
ss
string
as
class
section
s
cloning
objects
Cloning
objects
Objects
can
also
be
cloned
whether
they
are
functional
or
imperative
The
library
function
Oo
copy
makes
a
shallow
copy
of
an
object
That
is
it
returns
a
new
object
that
has
the
same
methods
and
instance
variables
as
its
argument
The
instance
variables
are
copied
but
their
contents
are
shared
Assigning
a
new
value
to
an
instance
variable
of
the
copy
using
a
method
call
will
not
affect
instance
variables
of
the
original
and
conversely
A
deeper
assignment
for
example
if
the
instance
variable
is
a
reference
cell
will
of
course
affect
both
the
original
and
the
copy
The
type
of
Oo
copy
is
the
following
begin
caml
example
toplevel
Oo
copy
end
caml
example
The
keyword
as
in
that
type
binds
the
type
variable
a
to
the
object
type
Therefore
Oo
copy
takes
an
object
with
any
methods
represented
by
the
ellipsis
and
returns
an
object
of
the
same
type
The
type
of
Oo
copy
is
different
from
type
as
each
ellipsis
represents
a
different
set
of
methods
Ellipsis
actually
behaves
as
a
type
variable
begin
caml
example
toplevel
let
p
new
point
5
let
q
Oo
copy
p
q
move
7
p
get
x
q
get
x
end
caml
example
In
fact
Oo
copy
p
will
behave
as
p
copy
assuming
that
a
public
method
copy
with
body
has
been
defined
in
the
class
of
p
Objects
can
be
compared
using
the
generic
comparison
functions
and
Two
objects
are
equal
if
and
only
if
they
are
physically
equal
In
particular
an
object
and
its
copy
are
not
equal
begin
caml
example
toplevel
let
q
Oo
copy
p
p
q
p
p
end
caml
example
Other
generic
comparisons
such
as
can
also
be
used
on
objects
The
relation
defines
an
unspecified
but
strict
ordering
on
objects
The
ordering
relationship
between
two
objects
is
fixed
permanently
once
the
two
objects
have
been
created
and
it
is
not
affected
by
mutation
of
fields
Cloning
and
override
have
a
non
empty
intersection
They
are
interchangeable
when
used
within
an
object
and
without
overriding
any
field
begin
caml
example
toplevel
class
copy
object
method
copy
end
class
copy
object
self
method
copy
Oo
copy
self
end
end
caml
example
Only
the
override
can
be
used
to
actually
override
fields
and
only
the
Oo
copy
primitive
can
be
used
externally
Cloning
can
also
be
used
to
provide
facilities
for
saving
and
restoring
the
state
of
objects
begin
caml
example
toplevel
class
backup
object
self
mytype
val
mutable
copy
None
method
save
copy
Some
copy
None
method
restore
match
copy
with
Some
x
x
None
self
end
end
caml
example
The
above
definition
will
only
backup
one
level
The
backup
facility
can
be
added
to
any
class
by
using
multiple
inheritance
begin
caml
example
toplevel
class
a
backup
ref
x
object
inherit
a
oref
x
inherit
backup
end
let
rec
get
p
n
if
n
0
then
p
get
else
get
p
restore
n
1
let
p
new
backup
ref
0
in
p
save
p
set
1
p
save
p
set
2
get
p
0
get
p
1
get
p
2
get
p
3
get
p
4
end
caml
example
We
can
define
a
variant
of
backup
that
retains
all
copies
We
also
add
a
method
clear
to
manually
erase
all
copies
begin
caml
example
toplevel
class
backup
object
self
mytype
val
mutable
copy
None
method
save
copy
Some
method
restore
match
copy
with
Some
x
x
None
self
method
clear
copy
None
end
end
caml
example
begin
caml
example
toplevel
class
a
backup
ref
x
object
inherit
a
oref
x
inherit
backup
end
let
p
new
backup
ref
0
in
p
save
p
set
1
p
save
p
set
2
get
p
0
get
p
1
get
p
2
get
p
3
get
p
4
end
caml
example
section
s
recursive
classes
Recursive
classes
Recursive
classes
can
be
used
to
define
objects
whose
types
are
mutually
recursive
begin
caml
example
toplevel
class
window
object
val
mutable
top
widget
None
widget
option
method
top
widget
top
widget
end
and
widget
w
window
object
val
window
w
method
window
window
end
end
caml
example
Although
their
types
are
mutually
recursive
the
classes
widget
and
window
are
themselves
independent
section
s
binary
methods
Binary
methods
A
binary
method
is
a
method
which
takes
an
argument
of
the
same
type
as
self
The
class
comparable
below
is
a
template
for
classes
with
a
binary
method
leq
of
type
a
bool
where
the
type
variable
a
is
bound
to
the
type
of
self
Therefore
comparable
expands
to
leq
a
bool
as
a
We
see
here
that
the
binder
as
also
allows
writing
recursive
types
begin
caml
example
toplevel
class
virtual
comparable
object
a
method
virtual
leq
a
bool
end
end
caml
example
We
then
define
a
subclass
money
of
comparable
The
class
money
simply
wraps
floats
as
comparable
objects
footnote
floats
are
an
approximation
of
decimal
numbers
they
are
unsuitable
for
use
in
most
monetary
calculations
as
they
may
introduce
errors
We
will
extend
money
below
with
more
operations
We
have
to
use
a
type
constraint
on
the
class
parameter
x
because
the
primitive
is
a
polymorphic
function
in
OCaml
The
inherit
clause
ensures
that
the
type
of
objects
of
this
class
is
an
instance
of
comparable
begin
caml
example
toplevel
class
money
x
float
object
inherit
comparable
val
repr
x
method
value
repr
method
leq
p
repr
p
value
end
end
caml
example
not
explained
mutability
can
be
hidden
Note
that
the
type
money
is
not
a
subtype
of
type
comparable
as
the
self
type
appears
in
contravariant
position
in
the
type
of
method
leq
Indeed
an
object
m
of
class
money
has
a
method
leq
that
expects
an
argument
of
type
money
since
it
accesses
its
value
method
Considering
m
of
type
comparable
would
allow
a
call
to
method
leq
on
m
with
an
argument
that
does
not
have
a
method
value
which
would
be
an
error
Similarly
the
type
money2
below
is
not
a
subtype
of
type
money
begin
caml
example
toplevel
class
money2
x
object
inherit
money
x
method
times
k
repr
k
repr
end
end
caml
example
It
is
however
possible
to
define
functions
that
manipulate
objects
of
type
either
money
or
money2
the
function
min
will
return
the
minimum
of
any
two
objects
whose
type
unifies
with
comparable
The
type
of
min
is
not
the
same
as
comparable
comparable
comparable
as
the
abbreviation
comparable
hides
a
type
variable
an
ellipsis
Each
occurrence
of
this
abbreviation
generates
a
new
variable
begin
caml
example
toplevel
let
min
x
comparable
y
if
x
leq
y
then
x
else
y
end
caml
example
This
function
can
be
applied
to
objects
of
type
money
or
money2
begin
caml
example
toplevel
min
new
money
1
3
new
money
3
1
value
min
new
money2
5
0
new
money2
3
14
value
end
caml
example
More
examples
of
binary
methods
can
be
found
in
sections
ref
ss
string
as
class
and
ref
ss
set
as
class
Note
the
use
of
override
for
method
times
Writing
new
money2
k
repr
instead
of
repr
k
repr
would
not
behave
well
with
inheritance
in
a
subclass
money3
of
money2
the
times
method
would
return
an
object
of
class
money2
but
not
of
class
money3
as
would
be
expected
The
class
money
could
naturally
carry
another
binary
method
Here
is
a
direct
definition
begin
caml
example
toplevel
class
money
x
object
self
a
val
repr
x
method
value
repr
method
print
print
float
repr
method
times
k
repr
k
x
method
leq
p
a
repr
p
value
method
plus
p
a
repr
x
p
value
end
end
caml
example
section
s
friends
Friends
The
above
class
money
reveals
a
problem
that
often
occurs
with
binary
methods
In
order
to
interact
with
other
objects
of
the
same
class
the
representation
of
money
objects
must
be
revealed
using
a
method
such
as
value
If
we
remove
all
binary
methods
here
plus
and
leq
the
representation
can
easily
be
hidden
inside
objects
by
removing
the
method
value
as
well
However
this
is
not
possible
as
soon
as
some
binary
method
requires
access
to
the
representation
of
objects
of
the
same
class
other
than
self
begin
caml
example
toplevel
class
safe
money
x
object
self
a
val
repr
x
method
print
print
float
repr
method
times
k
repr
k
x
end
end
caml
example
Here
the
representation
of
the
object
is
known
only
to
a
particular
object
To
make
it
available
to
other
objects
of
the
same
class
we
are
forced
to
make
it
available
to
the
whole
world
However
we
can
easily
restrict
the
visibility
of
the
representation
using
the
module
system
begin
caml
example
toplevel
module
type
MONEY
sig
type
t
class
c
float
object
a
val
repr
t
method
value
t
method
print
unit
method
times
float
a
method
leq
a
bool
method
plus
a
a
end
end
module
Euro
MONEY
struct
type
t
float
class
c
x
object
self
a
val
repr
x
method
value
repr
method
print
print
float
repr
method
times
k
repr
k
x
method
leq
p
a
repr
p
value
method
plus
p
a
repr
x
p
value
end
end
end
caml
example
Another
example
of
friend
functions
may
be
found
in
section
ref
ss
set
as
class
These
examples
occur
when
a
group
of
objects
here
objects
of
the
same
class
and
functions
should
see
each
others
internal
representation
while
their
representation
should
be
hidden
from
the
outside
The
solution
is
always
to
define
all
friends
in
the
same
module
give
access
to
the
representation
and
use
a
signature
constraint
to
make
the
representation
abstract
outside
the
module
LocalWords
typecheck
monomorphic
uncaptured
Subtyping
subtyping
leq
repr
Oo
LocalWords
val
sig
bool
Euro
struct
OCaml
Vouillon
Didier
int
ref
incr
init
LocalWords
succ
mytype
rec
chapter
The
module
system
label
c
moduleexamples
HEVEA
cutname
moduleexamples
html
This
chapter
introduces
the
module
system
of
OCaml
section
s
module
structures
Structures
A
primary
motivation
for
modules
is
to
package
together
related
definitions
such
as
the
definitions
of
a
data
type
and
associated
operations
over
that
type
and
enforce
a
consistent
naming
scheme
for
these
definitions
This
avoids
running
out
of
names
or
accidentally
confusing
names
Such
a
package
is
called
a
em
structure
and
is
introduced
by
the
struct
ldots
end
construct
which
contains
an
arbitrary
sequence
of
definitions
The
structure
is
usually
given
a
name
with
the
module
binding
For
instance
here
is
a
structure
packaging
together
a
type
of
FIFO
queues
and
their
operations
begin
caml
example
toplevel
module
Fifo
struct
type
a
queue
front
a
list
rear
a
list
let
make
front
rear
match
front
with
front
List
rev
rear
rear
front
rear
let
empty
front
rear
let
is
empty
function
front
true
false
let
add
x
q
make
q
front
x
q
rear
exception
Empty
let
top
function
front
raise
Empty
front
x
x
let
pop
function
front
raise
Empty
front
f
rear
r
make
f
r
end
end
caml
example
Outside
the
structure
its
components
can
be
referred
to
using
the
dot
notation
that
is
identifiers
qualified
by
a
structure
name
For
instance
Fifo
add
is
the
function
add
defined
inside
the
structure
Fifo
and
Fifo
queue
is
the
type
queue
defined
in
Fifo
begin
caml
example
toplevel
Fifo
add
hello
Fifo
empty
end
caml
example
Another
possibility
is
to
open
the
module
which
brings
all
identifiers
defined
inside
the
module
into
the
scope
of
the
current
structure
begin
caml
example
toplevel
open
Fifo
add
hello
empty
end
caml
example
Opening
a
module
enables
lighter
access
to
its
components
at
the
cost
of
making
it
harder
to
identify
in
which
module
an
identifier
has
been
defined
In
particular
opened
modules
can
shadow
identifiers
present
in
the
current
scope
potentially
leading
to
confusing
errors
begin
caml
example
toplevel
let
empty
open
Fifo
let
x
1
empty
expect
error
end
caml
example
A
partial
solution
to
this
conundrum
is
to
open
modules
locally
making
the
components
of
the
module
available
only
in
the
concerned
expression
This
can
also
make
the
code
both
easier
to
read
since
the
open
statement
is
closer
to
where
it
is
used
and
easier
to
refactor
since
the
code
fragment
is
more
self
contained
Two
constructions
are
available
for
this
purpose
begin
caml
example
toplevel
let
open
Fifo
in
add
hello
empty
end
caml
example
and
begin
caml
example
toplevel
Fifo
add
hello
empty
end
caml
example
In
the
second
form
when
the
body
of
a
local
open
is
itself
delimited
by
parentheses
braces
or
bracket
the
parentheses
of
the
local
open
can
be
omitted
For
instance
begin
caml
example
toplevel
Fifo
empty
Fifo
empty
Fifo
empty
Fifo
empty
Fifo
contents
empty
Fifo
contents
empty
end
caml
example
This
second
form
also
works
for
patterns
begin
caml
example
toplevel
let
at
most
one
element
x
match
x
with
Fifo
front
rear
true
false
end
caml
example
It
is
also
possible
to
copy
the
components
of
a
module
inside
another
module
by
using
an
include
statement
This
can
be
particularly
useful
to
extend
existing
modules
As
an
illustration
we
could
add
functions
that
return
an
optional
value
rather
than
an
exception
when
the
queue
is
empty
begin
caml
example
toplevel
module
FifoOpt
struct
include
Fifo
let
top
opt
q
if
is
empty
q
then
None
else
Some
top
q
let
pop
opt
q
if
is
empty
q
then
None
else
Some
pop
q
end
end
caml
example
section
s
signature
Signatures
Signatures
are
interfaces
for
structures
A
signature
specifies
which
components
of
a
structure
are
accessible
from
the
outside
and
with
which
type
It
can
be
used
to
hide
some
components
of
a
structure
e
g
local
function
definitions
or
export
some
components
with
a
restricted
type
For
instance
the
signature
below
specifies
the
queue
operations
empty
add
top
and
pop
but
not
the
auxiliary
function
make
Similarly
it
makes
the
queue
type
abstract
by
not
providing
its
actual
representation
as
a
concrete
type
This
ensures
that
users
of
the
Fifo
module
cannot
violate
data
structure
invariants
that
operations
rely
on
such
as
if
the
front
list
is
empty
the
rear
list
must
also
be
empty
begin
caml
example
toplevel
module
type
FIFO
sig
type
a
queue
now
an
abstract
type
val
empty
a
queue
val
add
a
a
queue
a
queue
val
top
a
queue
a
val
pop
a
queue
a
queue
exception
Empty
end
end
caml
example
Restricting
the
Fifo
structure
to
this
signature
results
in
another
view
of
the
Fifo
structure
where
the
make
function
is
not
accessible
and
the
actual
representation
of
queues
is
hidden
begin
caml
example
toplevel
module
AbstractQueue
Fifo
FIFO
AbstractQueue
make
1
2
3
expect
error
AbstractQueue
add
hello
AbstractQueue
empty
end
caml
example
The
restriction
can
also
be
performed
during
the
definition
of
the
structure
as
in
begin
verbatim
module
Fifo
struct
end
FIFO
end
verbatim
An
alternate
syntax
is
provided
for
the
above
begin
verbatim
module
Fifo
FIFO
struct
end
end
verbatim
Like
for
modules
it
is
possible
to
include
a
signature
to
copy
its
components
inside
the
current
signature
For
instance
we
can
extend
the
FIFO
signature
with
the
top
opt
and
pop
opt
functions
begin
caml
example
toplevel
module
type
FIFO
WITH
OPT
sig
include
FIFO
val
top
opt
a
queue
a
option
val
pop
opt
a
queue
a
queue
option
end
end
caml
example
section
s
functors
Functors
Functors
are
functions
from
modules
to
modules
Functors
let
you
create
parameterized
modules
and
then
provide
other
modules
as
parameter
s
to
get
a
specific
implementation
For
instance
a
Set
module
implementing
sets
as
sorted
lists
could
be
parameterized
to
work
with
any
module
that
provides
an
element
type
and
a
comparison
function
compare
such
as
OrderedString
begin
caml
example
toplevel
type
comparison
Less
Equal
Greater
module
type
ORDERED
TYPE
sig
type
t
val
compare
t
t
comparison
end
module
Set
functor
Elt
ORDERED
TYPE
struct
type
element
Elt
t
type
set
element
list
let
empty
let
rec
add
x
s
match
s
with
x
hd
tl
match
Elt
compare
x
hd
with
Equal
s
x
is
already
in
s
Less
x
s
x
is
smaller
than
all
elements
of
s
Greater
hd
add
x
tl
let
rec
member
x
s
match
s
with
false
hd
tl
match
Elt
compare
x
hd
with
Equal
true
x
belongs
to
s
Less
false
x
is
smaller
than
all
elements
of
s
Greater
member
x
tl
end
end
caml
example
By
applying
the
Set
functor
to
a
structure
implementing
an
ordered
type
we
obtain
set
operations
for
this
type
begin
caml
example
toplevel
module
OrderedString
struct
type
t
string
let
compare
x
y
if
x
y
then
Equal
else
if
x
y
then
Less
else
Greater
end
module
StringSet
Set
OrderedString
StringSet
member
bar
StringSet
add
foo
StringSet
empty
end
caml
example
section
s
functors
and
abstraction
Functors
and
type
abstraction
As
in
the
Fifo
example
it
would
be
good
style
to
hide
the
actual
implementation
of
the
type
set
so
that
users
of
the
structure
will
not
rely
on
sets
being
lists
and
we
can
switch
later
to
another
more
efficient
representation
of
sets
without
breaking
their
code
This
can
be
achieved
by
restricting
Set
by
a
suitable
functor
signature
begin
caml
example
toplevel
module
type
SETFUNCTOR
Elt
ORDERED
TYPE
sig
type
element
Elt
t
concrete
type
set
abstract
val
empty
set
val
add
element
set
set
val
member
element
set
bool
end
module
AbstractSet
Set
SETFUNCTOR
module
AbstractStringSet
AbstractSet
OrderedString
AbstractStringSet
add
gee
AbstractStringSet
empty
end
caml
example
In
an
attempt
to
write
the
type
constraint
above
more
elegantly
one
may
wish
to
name
the
signature
of
the
structure
returned
by
the
functor
then
use
that
signature
in
the
constraint
begin
caml
example
toplevel
module
type
SET
sig
type
element
type
set
val
empty
set
val
add
element
set
set
val
member
element
set
bool
end
module
WrongSet
Set
Elt
ORDERED
TYPE
SET
module
WrongStringSet
WrongSet
OrderedString
WrongStringSet
add
gee
WrongStringSet
empty
expect
error
end
caml
example
The
problem
here
is
that
SET
specifies
the
type
element
abstractly
so
that
the
type
equality
between
element
in
the
result
of
the
functor
and
t
in
its
argument
is
forgotten
Consequently
WrongStringSet
element
is
not
the
same
type
as
string
and
the
operations
of
WrongStringSet
cannot
be
applied
to
strings
As
demonstrated
above
it
is
important
that
the
type
element
in
the
signature
SET
be
declared
equal
to
Elt
t
unfortunately
this
is
impossible
above
since
SET
is
defined
in
a
context
where
Elt
does
not
exist
To
overcome
this
difficulty
OCaml
provides
a
with
type
construct
over
signatures
that
allows
enriching
a
signature
with
extra
type
equalities
begin
caml
example
toplevel
module
AbstractSet2
Set
Elt
ORDERED
TYPE
SET
with
type
element
Elt
t
end
caml
example
As
in
the
case
of
simple
structures
an
alternate
syntax
is
provided
for
defining
functors
and
restricting
their
result
begin
verbatim
module
AbstractSet2
Elt
ORDERED
TYPE
SET
with
type
element
Elt
t
struct
end
end
verbatim
Abstracting
a
type
component
in
a
functor
result
is
a
powerful
technique
that
provides
a
high
degree
of
type
safety
as
we
now
illustrate
Consider
an
ordering
over
character
strings
that
is
different
from
the
standard
ordering
implemented
in
the
OrderedString
structure
For
instance
we
compare
strings
without
distinguishing
upper
and
lower
case
begin
caml
example
toplevel
module
NoCaseString
struct
type
t
string
let
compare
s1
s2
OrderedString
compare
String
lowercase
ascii
s1
String
lowercase
ascii
s2
end
module
NoCaseStringSet
AbstractSet
NoCaseString
NoCaseStringSet
add
FOO
AbstractStringSet
empty
expect
error
end
caml
example
Note
that
the
two
types
AbstractStringSet
set
and
NoCaseStringSet
set
are
not
compatible
and
values
of
these
two
types
do
not
match
This
is
the
correct
behavior
even
though
both
set
types
contain
elements
of
the
same
type
strings
they
are
built
upon
different
orderings
of
that
type
and
different
invariants
need
to
be
maintained
by
the
operations
being
strictly
increasing
for
the
standard
ordering
and
for
the
case
insensitive
ordering
Applying
operations
from
AbstractStringSet
to
values
of
type
NoCaseStringSet
set
could
give
incorrect
results
or
build
lists
that
violate
the
invariants
of
NoCaseStringSet
section
s
separate
compilation
Modules
and
separate
compilation
All
examples
of
modules
so
far
have
been
given
in
the
context
of
the
interactive
system
However
modules
are
most
useful
for
large
batch
compiled
programs
For
these
programs
it
is
a
practical
necessity
to
split
the
source
into
several
files
called
compilation
units
that
can
be
compiled
separately
thus
minimizing
recompilation
after
changes
In
OCaml
compilation
units
are
special
cases
of
structures
and
signatures
and
the
relationship
between
the
units
can
be
explained
easily
in
terms
of
the
module
system
A
compilation
unit
var
A
comprises
two
files
begin
itemize
item
the
implementation
file
var
A
ml
which
contains
a
sequence
of
definitions
analogous
to
the
inside
of
a
struct
ldots
end
construct
item
the
interface
file
var
A
mli
which
contains
a
sequence
of
specifications
analogous
to
the
inside
of
a
sig
ldots
end
construct
end
itemize
These
two
files
together
define
a
structure
named
var
A
as
if
the
following
definition
was
entered
at
top
level
begin
alltt
module
var
A
sig
hbox
contents
of
file
var
A
mli
end
struct
hbox
contents
of
file
var
A
ml
end
end
alltt
The
files
that
define
the
compilation
units
can
be
compiled
separately
using
the
ocamlc
c
command
the
c
option
means
compile
only
do
not
try
to
link
this
produces
compiled
interface
files
with
extension
cmi
and
compiled
object
code
files
with
extension
cmo
When
all
units
have
been
compiled
their
cmo
files
are
linked
together
using
the
ocamlc
command
For
instance
the
following
commands
compile
and
link
a
program
composed
of
two
compilation
units
Aux
and
Main
begin
verbatim
ocamlc
c
Aux
mli
produces
aux
cmi
ocamlc
c
Aux
ml
produces
aux
cmo
ocamlc
c
Main
mli
produces
main
cmi
ocamlc
c
Main
ml
produces
main
cmo
ocamlc
o
theprogram
Aux
cmo
Main
cmo
end
verbatim
The
program
behaves
exactly
as
if
the
following
phrases
were
entered
at
top
level
begin
alltt
module
Aux
sig
rminalltt
contents
of
Aux
mli
end
struct
rminalltt
contents
of
Aux
ml
end
module
Main
sig
rminalltt
contents
of
Main
mli
end
struct
rminalltt
contents
of
Main
ml
end
end
alltt
In
particular
Main
can
refer
to
Aux
the
definitions
and
declarations
contained
in
Main
ml
and
Main
mli
can
refer
to
definition
in
Aux
ml
using
the
Aux
var
ident
notation
provided
these
definitions
are
exported
in
Aux
mli
The
order
in
which
the
cmo
files
are
given
to
ocamlc
during
the
linking
phase
determines
the
order
in
which
the
module
definitions
occur
Hence
in
the
example
above
Aux
appears
first
and
Main
can
refer
to
it
but
Aux
cannot
refer
to
Main
Note
that
only
top
level
structures
can
be
mapped
to
separately
compiled
files
but
neither
functors
nor
module
types
However
all
module
class
objects
can
appear
as
components
of
a
structure
so
the
solution
is
to
put
the
functor
or
module
type
inside
a
structure
which
can
then
be
mapped
to
a
file
chapter
Advanced
examples
with
classes
and
modules
HEVEA
cutname
advexamples
html
label
c
advexamples
it
Chapter
written
by
Didier
Rmy
bigskip
noindent
In
this
chapter
we
show
some
larger
examples
using
objects
classes
and
modules
We
review
many
of
the
object
features
simultaneously
on
the
example
of
a
bank
account
We
show
how
modules
taken
from
the
standard
library
can
be
expressed
as
classes
Lastly
we
describe
a
programming
pattern
known
as
em
virtual
types
through
the
example
of
window
managers
section
s
extended
bank
accounts
Extended
example
bank
accounts
In
this
section
we
illustrate
most
aspects
of
Object
and
inheritance
by
refining
debugging
and
specializing
the
following
initial
naive
definition
of
a
simple
bank
account
We
reuse
the
module
Euro
defined
at
the
end
of
chapter
ref
c
objectexamples
begin
caml
eval
module
type
MONEY
sig
type
t
class
c
float
object
a
val
repr
t
method
value
t
method
print
unit
method
times
float
a
method
leq
a
bool
method
plus
a
a
end
end
module
Euro
MONEY
struct
type
t
float
class
c
x
object
self
a
val
repr
x
method
value
repr
method
print
print
float
repr
method
times
k
repr
k
x
method
leq
p
a
repr
p
value
method
plus
p
a
repr
x
p
value
end
end
end
caml
eval
begin
caml
example
toplevel
let
euro
new
Euro
c
let
zero
euro
0
let
neg
x
x
times
1
class
account
object
val
mutable
balance
zero
method
balance
balance
method
deposit
x
balance
balance
plus
x
method
withdraw
x
if
x
leq
balance
then
balance
balance
plus
neg
x
x
else
zero
end
let
c
new
account
in
c
deposit
euro
100
c
withdraw
euro
50
end
caml
example
We
now
refine
this
definition
with
a
method
to
compute
interest
begin
caml
example
toplevel
class
account
with
interests
object
self
inherit
account
method
private
interest
self
deposit
self
balance
times
0
03
end
end
caml
example
We
make
the
method
interest
private
since
clearly
it
should
not
be
called
freely
from
the
outside
Here
it
is
only
made
accessible
to
subclasses
that
will
manage
monthly
or
yearly
updates
of
the
account
We
should
soon
fix
a
bug
in
the
current
definition
the
deposit
method
can
be
used
for
withdrawing
money
by
depositing
negative
amounts
We
can
fix
this
directly
begin
caml
example
toplevel
class
safe
account
object
inherit
account
method
deposit
x
if
zero
leq
x
then
balance
balance
plus
x
end
end
caml
example
However
the
bug
might
be
fixed
more
safely
by
the
following
definition
begin
caml
example
toplevel
class
safe
account
object
inherit
account
as
unsafe
method
deposit
x
if
zero
leq
x
then
unsafe
deposit
x
else
raise
Invalid
argument
deposit
end
end
caml
example
In
particular
this
does
not
require
the
knowledge
of
the
implementation
of
the
method
deposit
To
keep
track
of
operations
we
extend
the
class
with
a
mutable
field
history
and
a
private
method
trace
to
add
an
operation
in
the
log
Then
each
method
to
be
traced
is
redefined
begin
caml
example
toplevel
type
a
operation
Deposit
of
a
Retrieval
of
a
class
account
with
history
object
self
inherit
safe
account
as
super
val
mutable
history
method
private
trace
x
history
x
history
method
deposit
x
self
trace
Deposit
x
super
deposit
x
method
withdraw
x
self
trace
Retrieval
x
super
withdraw
x
method
history
List
rev
history
end
end
caml
example
label
ss
bank
initializer
One
may
wish
to
open
an
account
and
simultaneously
deposit
some
initial
amount
Although
the
initial
implementation
did
not
address
this
requirement
it
can
be
achieved
by
using
an
initializer
begin
caml
example
toplevel
class
account
with
deposit
x
object
inherit
account
with
history
initializer
balance
x
end
end
caml
example
A
better
alternative
is
begin
caml
example
toplevel
class
account
with
deposit
x
object
self
inherit
account
with
history
initializer
self
deposit
x
end
end
caml
example
Indeed
the
latter
is
safer
since
the
call
to
deposit
will
automatically
benefit
from
safety
checks
and
from
the
trace
Let
s
test
it
begin
caml
example
toplevel
let
ccp
new
account
with
deposit
euro
100
in
let
balance
ccp
withdraw
euro
50
in
ccp
history
end
caml
example
Closing
an
account
can
be
done
with
the
following
polymorphic
function
begin
caml
example
toplevel
let
close
c
c
withdraw
c
balance
end
caml
example
Of
course
this
applies
to
all
sorts
of
accounts
Finally
we
gather
several
versions
of
the
account
into
a
module
Account
abstracted
over
some
currency
begin
caml
example
toplevel
let
today
01
01
2000
an
approximation
module
Account
M
MONEY
struct
type
m
M
c
let
m
new
M
c
let
zero
m
0
class
bank
object
self
val
mutable
balance
zero
method
balance
balance
val
mutable
history
method
private
trace
x
history
x
history
method
deposit
x
self
trace
Deposit
x
if
zero
leq
x
then
balance
balance
plus
x
else
raise
Invalid
argument
deposit
method
withdraw
x
if
x
leq
balance
then
balance
balance
plus
neg
x
self
trace
Retrieval
x
x
else
zero
method
history
List
rev
history
end
class
type
client
view
object
method
deposit
m
unit
method
history
m
operation
list
method
withdraw
m
m
method
balance
m
end
class
virtual
check
client
x
let
y
if
m
100
leq
x
then
x
else
raise
Failure
Insufficient
initial
deposit
in
object
self
initializer
self
deposit
y
method
virtual
deposit
m
unit
end
module
Client
B
sig
class
bank
client
view
end
struct
class
account
x
client
view
object
inherit
B
bank
inherit
check
client
x
end
let
discount
x
let
c
new
account
x
in
if
today
1998
10
30
then
c
deposit
m
100
c
end
end
end
caml
example
This
shows
the
use
of
modules
to
group
several
class
definitions
that
can
in
fact
be
thought
of
as
a
single
unit
This
unit
would
be
provided
by
a
bank
for
both
internal
and
external
uses
This
is
implemented
as
a
functor
that
abstracts
over
the
currency
so
that
the
same
code
can
be
used
to
provide
accounts
in
different
currencies
The
class
bank
is
the
em
real
implementation
of
the
bank
account
it
could
have
been
inlined
This
is
the
one
that
will
be
used
for
further
extensions
refinements
etc
Conversely
the
client
will
only
be
given
the
client
view
begin
caml
example
toplevel
module
Euro
account
Account
Euro
module
Client
Euro
account
Client
Euro
account
new
Client
account
new
Euro
c
100
end
caml
example
Hence
the
clients
do
not
have
direct
access
to
the
balance
nor
the
history
of
their
own
accounts
Their
only
way
to
change
their
balance
is
to
deposit
or
withdraw
money
It
is
important
to
give
the
clients
a
class
and
not
just
the
ability
to
create
accounts
such
as
the
promotional
discount
account
so
that
they
can
personalize
their
account
For
instance
a
client
may
refine
the
deposit
and
withdraw
methods
so
as
to
do
his
own
financial
bookkeeping
automatically
On
the
other
hand
the
function
discount
is
given
as
such
with
no
possibility
for
further
personalization
It
is
important
to
provide
the
client
s
view
as
a
functor
Client
so
that
client
accounts
can
still
be
built
after
a
possible
specialization
of
the
bank
The
functor
Client
may
remain
unchanged
and
be
passed
the
new
definition
to
initialize
a
client
s
view
of
the
extended
account
begin
caml
example
toplevel
module
Investment
account
M
MONEY
struct
type
m
M
c
module
A
Account
M
class
bank
object
inherit
A
bank
as
super
method
deposit
x
if
new
M
c
1000
leq
x
then
print
string
Would
you
like
to
invest
super
deposit
x
end
module
Client
A
Client
end
end
caml
example
begin
caml
eval
module
Euro
account
Investment
account
Euro
module
Client
Euro
account
Client
Euro
account
new
Client
account
new
Euro
c
100
end
caml
eval
The
functor
Client
may
also
be
redefined
when
some
new
features
of
the
account
can
be
given
to
the
client
begin
caml
example
toplevel
module
Internet
account
M
MONEY
struct
type
m
M
c
module
A
Account
M
class
bank
object
inherit
A
bank
method
mail
s
print
string
s
end
class
type
client
view
object
method
deposit
m
unit
method
history
m
operation
list
method
withdraw
m
m
method
balance
m
method
mail
string
unit
end
module
Client
B
sig
class
bank
client
view
end
struct
class
account
x
client
view
object
inherit
B
bank
inherit
A
check
client
x
end
end
end
end
caml
example
begin
caml
eval
module
Euro
account
Internet
account
Euro
module
Client
Euro
account
Client
Euro
account
new
Client
account
new
Euro
c
100
end
caml
eval
section
s
modules
as
classes
Simple
modules
as
classes
One
may
wonder
whether
it
is
possible
to
treat
primitive
types
such
as
integers
and
strings
as
objects
Although
this
is
usually
uninteresting
for
integers
or
strings
there
may
be
some
situations
where
this
is
desirable
The
class
money
above
is
such
an
example
We
show
here
how
to
do
it
for
strings
subsection
ss
string
as
class
Strings
A
naive
definition
of
strings
as
objects
could
be
begin
caml
example
toplevel
class
ostring
s
object
method
get
n
String
get
s
n
method
print
print
string
s
method
escaped
new
ostring
String
escaped
s
end
end
caml
example
However
the
method
escaped
returns
an
object
of
the
class
ostring
and
not
an
object
of
the
current
class
Hence
if
the
class
is
further
extended
the
method
escaped
will
only
return
an
object
of
the
parent
class
begin
caml
example
toplevel
class
sub
string
s
object
inherit
ostring
s
method
sub
start
len
new
sub
string
String
sub
s
start
len
end
end
caml
example
As
seen
in
section
ref
s
binary
methods
the
solution
is
to
use
functional
update
instead
We
need
to
create
an
instance
variable
containing
the
representation
s
of
the
string
begin
caml
example
toplevel
class
better
string
s
object
val
repr
s
method
get
n
String
get
repr
n
method
print
print
string
repr
method
escaped
repr
String
escaped
repr
method
sub
start
len
repr
String
sub
s
start
len
end
end
caml
example
As
shown
in
the
inferred
type
the
methods
escaped
and
sub
now
return
objects
of
the
same
type
as
the
one
of
the
class
Another
difficulty
is
the
implementation
of
the
method
concat
In
order
to
concatenate
a
string
with
another
string
of
the
same
class
one
must
be
able
to
access
the
instance
variable
externally
Thus
a
method
repr
returning
s
must
be
defined
Here
is
the
correct
definition
of
strings
begin
caml
example
toplevel
class
ostring
s
object
self
mytype
val
repr
s
method
repr
repr
method
get
n
String
get
repr
n
method
print
print
string
repr
method
escaped
repr
String
escaped
repr
method
sub
start
len
repr
String
sub
s
start
len
method
concat
t
mytype
repr
repr
t
repr
end
end
caml
example
Another
constructor
of
the
class
string
can
be
defined
to
return
a
new
string
of
a
given
length
begin
caml
example
toplevel
class
cstring
n
ostring
String
make
n
end
caml
example
Here
exposing
the
representation
of
strings
is
probably
harmless
We
do
could
also
hide
the
representation
of
strings
as
we
hid
the
currency
in
the
class
money
of
section
ref
s
friends
subsubsection
sss
stack
as
class
Stacks
There
is
sometimes
an
alternative
between
using
modules
or
classes
for
parametric
data
types
Indeed
there
are
situations
when
the
two
approaches
are
quite
similar
For
instance
a
stack
can
be
straightforwardly
implemented
as
a
class
begin
caml
example
toplevel
exception
Empty
class
a
stack
object
val
mutable
l
a
list
method
push
x
l
x
l
method
pop
match
l
with
raise
Empty
a
l
l
l
a
method
clear
l
method
length
List
length
l
end
end
caml
example
However
writing
a
method
for
iterating
over
a
stack
is
more
problematic
A
method
fold
would
have
type
b
a
b
b
b
Here
a
is
the
parameter
of
the
stack
The
parameter
b
is
not
related
to
the
class
a
stack
but
to
the
argument
that
will
be
passed
to
the
method
fold
The
intuition
is
that
method
fold
should
be
polymorphic
i
e
of
type
All
a
b
a
b
b
b
A
naive
approach
is
to
make
b
an
extra
parameter
of
class
stack
begin
caml
example
toplevel
class
a
b
stack2
object
inherit
a
stack
method
fold
f
x
b
List
fold
left
f
x
l
end
end
caml
example
However
the
method
fold
of
a
given
object
can
only
be
applied
to
functions
that
all
have
the
same
type
begin
caml
example
toplevel
let
s
new
stack2
s
fold
0
s
end
caml
example
A
better
solution
is
to
use
polymorphic
methods
which
were
introduced
in
OCaml
version
3
05
Polymorphic
methods
makes
it
possible
to
treat
the
type
variable
b
in
the
type
of
fold
as
universally
quantified
giving
fold
the
polymorphic
type
Forall
b
b
a
b
b
b
An
explicit
type
declaration
on
the
method
fold
is
required
since
the
type
checker
cannot
infer
the
polymorphic
type
by
itself
begin
caml
example
toplevel
class
a
stack3
object
inherit
a
stack
method
fold
b
b
a
b
b
b
fun
f
x
List
fold
left
f
x
l
end
end
caml
example
However
the
nice
correspondence
between
the
implementations
of
stacks
as
modules
or
classes
is
a
very
particular
case
XXX
Maps
subsection
ss
hashtbl
as
class
Hashtbl
A
simplified
version
of
object
oriented
hash
tables
should
have
the
following
class
type
begin
caml
example
toplevel
class
type
a
b
hash
table
object
method
find
a
b
method
add
a
b
unit
end
end
caml
example
A
simple
implementation
which
is
quite
reasonable
for
small
hash
tables
is
to
use
an
association
list
begin
caml
example
toplevel
class
a
b
small
hashtbl
a
b
hash
table
object
val
mutable
table
method
find
key
List
assoc
key
table
method
add
key
value
table
key
value
table
end
end
caml
example
A
better
implementation
and
one
that
scales
up
better
is
to
use
a
true
hash
table
ldots
whose
elements
are
small
hash
tables
begin
caml
example
toplevel
class
a
b
hashtbl
size
a
b
hash
table
object
self
val
table
Array
init
size
fun
i
new
small
hashtbl
method
private
hash
key
Hashtbl
hash
key
mod
Array
length
table
method
find
key
table
self
hash
key
find
key
method
add
key
table
self
hash
key
add
key
end
end
caml
example
problem
solution
subsection
ss
set
as
class
Sets
Implementing
sets
leads
to
another
difficulty
Indeed
the
method
union
needs
to
be
able
to
access
the
internal
representation
of
another
object
of
the
same
class
This
is
another
instance
of
friend
functions
as
seen
in
section
ref
s
friends
Indeed
this
is
the
same
mechanism
used
in
the
module
Set
in
the
absence
of
objects
In
the
object
oriented
version
of
sets
we
only
need
to
add
an
additional
method
tag
to
return
the
representation
of
a
set
Since
sets
are
parametric
in
the
type
of
elements
the
method
tag
has
a
parametric
type
a
tag
concrete
within
the
module
definition
but
abstract
in
its
signature
From
outside
it
will
then
be
guaranteed
that
two
objects
with
a
method
tag
of
the
same
type
will
share
the
same
representation
begin
caml
example
toplevel
module
type
SET
sig
type
a
tag
class
a
c
object
b
method
is
empty
bool
method
mem
a
bool
method
add
a
b
method
union
b
b
method
iter
a
unit
unit
method
tag
a
tag
end
end
module
Set
SET
struct
let
rec
merge
l1
l2
match
l1
with
l2
h1
t1
match
l2
with
l1
h2
t2
if
h1
h2
then
h1
merge
t1
l2
else
if
h1
h2
then
h2
merge
l1
t2
else
merge
t1
l2
type
a
tag
a
list
class
a
c
object
b
val
repr
a
list
method
is
empty
repr
method
mem
x
List
exists
x
repr
method
add
x
repr
merge
x
repr
method
union
s
b
repr
merge
repr
s
tag
method
iter
f
a
unit
List
iter
f
repr
method
tag
repr
end
end
end
caml
example
section
s
subject
observer
The
subject
observer
pattern
The
following
example
known
as
the
subject
observer
pattern
is
often
presented
in
the
literature
as
a
difficult
inheritance
problem
with
inter
connected
classes
The
general
pattern
amounts
to
the
definition
a
pair
of
two
classes
that
recursively
interact
with
one
another
The
class
observer
has
a
distinguished
method
notify
that
requires
two
arguments
a
subject
and
an
event
to
execute
an
action
begin
caml
example
toplevel
class
virtual
subject
event
observer
object
method
virtual
notify
subject
event
unit
end
end
caml
example
The
class
subject
remembers
a
list
of
observers
in
an
instance
variable
and
has
a
distinguished
method
notify
observers
to
broadcast
the
message
notify
to
all
observers
with
a
particular
event
e
begin
caml
example
toplevel
class
observer
event
subject
object
self
val
mutable
observers
observer
list
method
add
observer
obs
observers
obs
observers
method
notify
observers
e
event
List
iter
fun
x
x
notify
self
e
observers
end
end
caml
example
The
difficulty
usually
lies
in
defining
instances
of
the
pattern
above
by
inheritance
This
can
be
done
in
a
natural
and
obvious
manner
in
OCaml
as
shown
on
the
following
example
manipulating
windows
begin
caml
example
toplevel
type
event
Raise
Resize
Move
let
string
of
event
function
Raise
Raise
Resize
Resize
Move
Move
let
count
ref
0
class
observer
window
subject
let
id
count
succ
count
count
in
object
self
inherit
observer
event
subject
val
mutable
position
0
method
identity
id
method
move
x
position
position
x
self
notify
observers
Move
method
draw
Printf
printf
Position
d
n
position
end
class
subject
window
observer
object
inherit
subject
event
observer
method
notify
s
e
s
draw
end
end
caml
example
As
can
be
expected
the
type
of
window
is
recursive
begin
caml
example
toplevel
let
window
new
window
subject
end
caml
example
However
the
two
classes
of
window
subject
and
window
observer
are
not
mutually
recursive
begin
caml
example
toplevel
let
window
observer
new
window
observer
window
add
observer
window
observer
window
move
1
end
caml
example
Classes
window
observer
and
window
subject
can
still
be
extended
by
inheritance
For
instance
one
may
enrich
the
subject
with
new
behaviors
and
refine
the
behavior
of
the
observer
begin
caml
example
toplevel
class
observer
richer
window
subject
object
self
inherit
observer
window
subject
val
mutable
size
1
method
resize
x
size
size
x
self
notify
observers
Resize
val
mutable
top
false
method
raise
top
true
self
notify
observers
Raise
method
draw
Printf
printf
Position
d
Size
d
n
position
size
end
class
subject
richer
window
observer
object
inherit
subject
window
observer
as
super
method
notify
s
e
if
e
Raise
then
s
raise
super
notify
s
e
end
end
caml
example
We
can
also
create
a
different
kind
of
observer
begin
caml
example
toplevel
class
subject
trace
observer
object
inherit
subject
event
observer
method
notify
s
e
Printf
printf
Window
d
s
n
s
identity
string
of
event
e
end
end
caml
example
and
attach
several
observers
to
the
same
object
begin
caml
example
toplevel
let
window
new
richer
window
subject
window
add
observer
new
richer
window
observer
window
add
observer
new
trace
observer
window
move
1
window
resize
2
end
caml
example
subsection
ss
Classes
used
as
modules
with
inheritance
to
be
filled
for
next
release
an
example
of
stateless
objects
used
to
provide
inheritance
in
modules
LocalWords
objectexamples
bsection
init
caml
val
int
Oo
succ
incr
ref
LocalWords
typecheck
leq
bool
cp
eval
sig
struct
ABSPOINT
Abspoint
iter
neg
LocalWords
accu
mem
rec
repr
Euro
euro
ccp
inlined
ostring
len
concat
OCaml
chapter
Generalized
algebraic
datatypes
label
c
gadts
tutorial
HEVEA
cutname
gadts
tutorial
html
Generalized
algebraic
datatypes
or
GADTs
extend
usual
sum
types
in
two
ways
constraints
on
type
parameters
may
change
depending
on
the
value
constructor
and
some
type
variables
may
be
existentially
quantified
Adding
constraints
is
done
by
giving
an
explicit
return
type
where
type
parameters
are
instantiated
begin
caml
example
verbatim
type
term
Int
int
int
term
Add
int
int
int
term
App
b
a
term
b
term
a
term
end
caml
example
This
return
type
must
use
the
same
type
constructor
as
the
type
being
defined
and
have
the
same
number
of
parameters
Variables
are
made
existential
when
they
appear
inside
a
constructor
s
argument
but
not
in
its
return
type
Since
the
use
of
a
return
type
often
eliminates
the
need
to
name
type
parameters
in
the
left
hand
side
of
a
type
definition
one
can
replace
them
with
anonymous
types
in
that
case
The
constraints
associated
to
each
constructor
can
be
recovered
through
pattern
matching
Namely
if
the
type
of
the
scrutinee
of
a
pattern
matching
contains
a
locally
abstract
type
this
type
can
be
refined
according
to
the
constructor
used
These
extra
constraints
are
only
valid
inside
the
corresponding
branch
of
the
pattern
matching
If
a
constructor
has
some
existential
variables
fresh
locally
abstract
types
are
generated
and
they
must
not
escape
the
scope
of
this
branch
section
s
gadts
recfun
Recursive
functions
We
write
an
eval
function
begin
caml
example
verbatim
let
rec
eval
type
a
a
term
a
function
Int
n
n
a
int
Add
fun
x
y
x
y
a
int
int
int
App
f
x
eval
f
eval
x
eval
called
at
types
b
a
and
b
for
fresh
b
end
caml
example
And
use
it
begin
caml
example
verbatim
let
two
eval
App
App
Add
Int
1
Int
1
end
caml
example
It
is
important
to
remark
that
the
function
eval
is
using
the
polymorphic
syntax
for
locally
abstract
types
When
defining
a
recursive
function
that
manipulates
a
GADT
explicit
polymorphic
recursion
should
generally
be
used
For
instance
the
following
definition
fails
with
a
type
error
begin
caml
example
verbatim
error
let
rec
eval
type
a
a
term
a
function
Int
n
n
Add
fun
x
y
x
y
App
f
x
eval
f
eval
x
end
caml
example
In
absence
of
an
explicit
polymorphic
annotation
a
monomorphic
type
is
inferred
for
the
recursive
function
If
a
recursive
call
occurs
inside
the
function
definition
at
a
type
that
involves
an
existential
GADT
type
variable
this
variable
flows
to
the
type
of
the
recursive
function
and
thus
escapes
its
scope
In
the
above
example
this
happens
in
the
branch
App
f
x
when
eval
is
called
with
f
as
an
argument
In
this
branch
the
type
of
f
is
App
b
a
term
The
prefix
in
App
b
denotes
an
existential
type
named
by
the
compiler
see
ref
s
existential
names
Since
the
type
of
eval
is
a
term
a
the
call
eval
f
makes
the
existential
type
App
b
flow
to
the
type
variable
a
and
escape
its
scope
This
triggers
the
above
error
section
s
gadts
type
inference
Type
inference
Type
inference
for
GADTs
is
notoriously
hard
This
is
due
to
the
fact
some
types
may
become
ambiguous
when
escaping
from
a
branch
For
instance
in
the
Int
case
above
n
could
have
either
type
int
or
a
and
they
are
not
equivalent
outside
of
that
branch
As
a
first
approximation
type
inference
will
always
work
if
a
pattern
matching
is
annotated
with
types
containing
no
free
type
variables
both
on
the
scrutinee
and
the
return
type
This
is
the
case
in
the
above
example
thanks
to
the
type
annotation
containing
only
locally
abstract
types
In
practice
type
inference
is
a
bit
more
clever
than
that
type
annotations
do
not
need
to
be
immediately
on
the
pattern
matching
and
the
types
do
not
have
to
be
always
closed
As
a
result
it
is
usually
enough
to
only
annotate
functions
as
in
the
example
above
Type
annotations
are
propagated
in
two
ways
for
the
scrutinee
they
follow
the
flow
of
type
inference
in
a
way
similar
to
polymorphic
methods
for
the
return
type
they
follow
the
structure
of
the
program
they
are
split
on
functions
propagated
to
all
branches
of
a
pattern
matching
and
go
through
tuples
records
and
sum
types
Moreover
the
notion
of
ambiguity
used
is
stronger
a
type
is
only
seen
as
ambiguous
if
it
was
mixed
with
incompatible
types
equated
by
constraints
without
type
annotations
between
them
For
instance
the
following
program
types
correctly
begin
caml
example
verbatim
let
rec
sum
type
a
a
term
fun
x
let
y
match
x
with
Int
n
n
Add
0
App
f
x
sum
f
sum
x
in
y
1
end
caml
example
Here
the
return
type
int
is
never
mixed
with
a
so
it
is
seen
as
non
ambiguous
and
can
be
inferred
When
using
such
partial
type
annotations
we
strongly
suggest
specifying
the
principal
mode
to
check
that
inference
is
principal
The
exhaustiveness
check
is
aware
of
GADT
constraints
and
can
automatically
infer
that
some
cases
cannot
happen
For
instance
the
following
pattern
matching
is
correctly
seen
as
exhaustive
the
Add
case
cannot
happen
begin
caml
example
verbatim
let
get
int
int
term
int
function
Int
n
n
App
0
end
caml
example
section
s
gadt
refutation
cases
Refutation
cases
Usually
the
exhaustiveness
check
only
tries
to
check
whether
the
cases
omitted
from
the
pattern
matching
are
typable
or
not
However
you
can
force
it
to
try
harder
by
adding
em
refutation
cases
written
as
a
full
stop
In
the
presence
of
a
refutation
case
the
exhaustiveness
check
will
first
compute
the
intersection
of
the
pattern
with
the
complement
of
the
cases
preceding
it
It
then
checks
whether
the
resulting
patterns
can
really
match
any
concrete
values
by
trying
to
type
check
them
Wild
cards
in
the
generated
patterns
are
handled
in
a
special
way
if
their
type
is
a
variant
type
with
only
GADT
constructors
then
the
pattern
is
split
into
the
different
constructors
in
order
to
check
whether
any
of
them
is
possible
this
splitting
is
not
done
for
arguments
of
these
constructors
to
avoid
non
termination
We
also
split
tuples
and
variant
types
with
only
one
case
since
they
may
contain
GADTs
inside
For
instance
the
following
code
is
deemed
exhaustive
begin
caml
example
verbatim
type
t
Int
int
t
Bool
bool
t
let
deep
char
t
int
option
char
function
None
c
end
caml
example
Namely
the
inferred
remaining
case
is
Some
which
is
split
into
Some
Int
and
Some
Bool
which
are
both
untypable
because
deep
expects
a
non
existing
char
t
as
the
first
element
of
the
tuple
Note
that
the
refutation
case
could
be
omitted
here
because
it
is
automatically
added
when
there
is
only
one
case
in
the
pattern
matching
Another
addition
is
that
the
redundancy
check
is
now
aware
of
GADTs
a
case
will
be
detected
as
redundant
if
it
could
be
replaced
by
a
refutation
case
using
the
same
pattern
section
s
gadts
advexamples
Advanced
examples
The
term
type
we
have
defined
above
is
an
em
indexed
type
where
a
type
parameter
reflects
a
property
of
the
value
contents
Another
use
of
GADTs
is
em
singleton
types
where
a
GADT
value
represents
exactly
one
type
This
value
can
be
used
as
runtime
representation
for
this
type
and
a
function
receiving
it
can
have
a
polytypic
behavior
Here
is
an
example
of
a
polymorphic
function
that
takes
the
runtime
representation
of
some
type
t
and
a
value
of
the
same
type
then
pretty
prints
the
value
as
a
string
begin
caml
example
verbatim
type
typ
Int
int
typ
String
string
typ
Pair
a
typ
b
typ
a
b
typ
let
rec
to
string
type
t
t
typ
t
string
fun
t
x
match
t
with
Int
Int
to
string
x
String
Printf
sprintf
S
x
Pair
t1
t2
let
x1
x2
x
in
Printf
sprintf
s
s
to
string
t1
x1
to
string
t2
x2
end
caml
example
Another
frequent
application
of
GADTs
is
equality
witnesses
begin
caml
example
verbatim
type
eq
Eq
a
a
eq
let
cast
type
a
b
a
b
eq
a
b
fun
Eq
x
x
end
caml
example
Here
type
eq
has
only
one
constructor
and
by
matching
on
it
one
adds
a
local
constraint
allowing
the
conversion
between
a
and
b
By
building
such
equality
witnesses
one
can
make
equal
types
which
are
syntactically
different
Here
is
an
example
using
both
singleton
types
and
equality
witnesses
to
implement
dynamic
types
begin
caml
example
verbatim
let
rec
eq
type
type
a
b
a
typ
b
typ
a
b
eq
option
fun
a
b
match
a
b
with
Int
Int
Some
Eq
String
String
Some
Eq
Pair
a1
a2
Pair
b1
b2
begin
match
eq
type
a1
b1
eq
type
a2
b2
with
Some
Eq
Some
Eq
Some
Eq
None
end
None
type
dyn
Dyn
a
typ
a
dyn
let
get
dyn
type
a
a
typ
dyn
a
option
fun
a
Dyn
b
x
match
eq
type
a
b
with
None
None
Some
Eq
Some
x
end
caml
example
section
s
existential
names
Existential
type
names
in
error
messages
The
typing
of
pattern
matching
in
the
presence
of
GADTs
can
generate
many
existential
types
When
necessary
error
messages
refer
to
these
existential
types
using
compiler
generated
names
Currently
the
compiler
generates
these
names
according
to
the
following
nomenclature
begin
itemize
item
First
types
whose
name
starts
with
a
are
existentials
item
a
denotes
an
existential
type
introduced
for
the
type
variable
a
of
a
GADT
constructor
begin
caml
example
verbatim
error
type
any
Any
name
any
let
escape
Any
x
x
end
caml
example
item
a
if
the
existential
variable
was
unified
with
the
type
variable
a
during
typing
begin
caml
example
verbatim
error
type
arg
result
aux
fn
Fun
a
b
a
b
unit
fn
Mem1
a
b
a
b
a
b
a
b
fn
let
apply
arg
result
fn
arg
result
fun
f
x
match
f
with
Fun
f
f
x
Mem1
f
y
fy
if
x
y
then
fy
else
f
x
end
caml
example
item
n
n
a
number
is
an
internally
generated
existential
which
could
not
be
named
using
one
of
the
previous
schemes
end
itemize
As
shown
by
the
last
item
the
current
behavior
is
imperfect
and
may
be
improved
in
future
versions
section
s
explicit
existential
name
Explicit
naming
of
existentials
As
explained
above
pattern
matching
on
a
GADT
constructor
may
introduce
existential
types
Syntax
has
been
introduced
which
allows
them
to
be
named
explicitly
For
instance
the
following
code
names
the
type
of
the
argument
of
f
and
uses
this
name
begin
caml
example
verbatim
type
closure
Closure
a
b
a
b
closure
let
eval
fun
Closure
type
a
f
x
a
f
x
a
end
caml
example
All
existential
type
variables
of
the
constructor
must
be
introduced
by
the
type
construct
and
bound
by
a
type
annotation
on
the
outside
of
the
constructor
argument
One
can
additionally
bind
existentials
that
were
freshly
introduced
by
the
refinement
of
another
existential
type
if
they
appear
in
the
type
of
the
arguments
begin
caml
example
verbatim
type
ty
Int
int
ty
Pair
b
ty
c
ty
b
c
ty
let
rec
default
type
a
a
ty
a
function
Int
0
Pair
type
b
c
b
c
b
ty
c
ty
default
b
b
default
c
c
end
caml
example
section
s
gadt
equation
nonlocal
abstract
Equations
on
non
local
abstract
types
GADT
pattern
matching
may
also
add
type
equations
to
non
local
abstract
types
The
behaviour
is
the
same
as
with
local
abstract
types
Reusing
the
above
eq
type
one
can
write
begin
caml
example
verbatim
module
M
sig
type
t
val
x
t
val
e
t
int
eq
end
struct
type
t
int
let
x
33
let
e
Eq
end
let
x
int
let
Eq
M
e
in
M
x
end
caml
example
Of
course
not
all
abstract
types
can
be
refined
as
this
would
contradict
the
exhaustiveness
check
Namely
builtin
types
those
defined
by
the
compiler
itself
such
as
int
or
array
and
abstract
types
defined
by
the
local
module
are
non
instantiable
and
as
such
cause
a
type
error
rather
than
introduce
an
equation
chapter
Labeled
arguments
label
c
labl
examples
HEVEA
cutname
lablexamples
html
it
Chapter
written
by
Jacques
Garrigue
If
you
have
a
look
at
modules
ending
in
Labels
in
the
standard
library
you
will
see
that
function
types
have
annotations
you
did
not
have
in
the
functions
you
defined
yourself
begin
caml
example
toplevel
ListLabels
map
StringLabels
sub
end
caml
example
Such
annotations
of
the
form
name
are
called
em
labels
They
are
meant
to
document
the
code
allow
more
checking
and
give
more
flexibility
to
function
application
You
can
give
such
names
to
arguments
in
your
programs
by
prefixing
them
with
a
tilde
begin
caml
example
toplevel
let
f
x
y
x
y
let
x
3
and
y
2
in
f
x
y
end
caml
example
When
you
want
to
use
distinct
names
for
the
variable
and
the
label
appearing
in
the
type
you
can
use
a
naming
label
of
the
form
name
This
also
applies
when
the
argument
is
not
a
variable
begin
caml
example
toplevel
let
f
x
x1
y
y1
x1
y1
f
x
3
y
2
end
caml
example
Labels
obey
the
same
rules
as
other
identifiers
in
OCaml
that
is
you
cannot
use
a
reserved
keyword
like
in
or
to
as
a
label
Formal
parameters
and
arguments
are
matched
according
to
their
respective
labels
the
absence
of
label
being
interpreted
as
the
empty
label
This
allows
commuting
arguments
in
applications
One
can
also
partially
apply
a
function
on
any
argument
creating
a
new
function
of
the
remaining
parameters
begin
caml
example
toplevel
let
f
x
y
x
y
f
y
2
x
3
ListLabels
fold
left
ListLabels
fold
left
1
2
3
init
0
f
ListLabels
fold
left
init
0
end
caml
example
If
several
arguments
of
a
function
bear
the
same
label
or
no
label
they
will
not
commute
among
themselves
and
order
matters
But
they
can
still
commute
with
other
arguments
begin
caml
example
toplevel
let
hline
x
x1
x
x2
y
x1
x2
y
hline
x
3
y
2
x
5
end
caml
example
section
s
optional
arguments
Optional
arguments
An
interesting
feature
of
labeled
arguments
is
that
they
can
be
made
optional
For
optional
parameters
the
question
mark
replaces
the
tilde
of
non
optional
ones
and
the
label
is
also
prefixed
by
in
the
function
type
Default
values
may
be
given
for
such
optional
parameters
begin
caml
example
toplevel
let
bump
step
1
x
x
step
bump
2
bump
step
3
2
end
caml
example
A
function
taking
some
optional
arguments
must
also
take
at
least
one
non
optional
argument
The
criterion
for
deciding
whether
an
optional
argument
has
been
omitted
is
the
non
labeled
application
of
an
argument
appearing
after
this
optional
argument
in
the
function
type
Note
that
if
that
argument
is
labeled
you
will
only
be
able
to
eliminate
optional
arguments
by
totally
applying
the
function
omitting
all
optional
arguments
and
omitting
all
labels
for
all
remaining
arguments
begin
caml
example
toplevel
let
test
x
0
y
0
z
0
x
y
z
test
test
x
2
z
3
end
caml
example
Optional
parameters
may
also
commute
with
non
optional
or
unlabeled
ones
as
long
as
they
are
applied
simultaneously
By
nature
optional
arguments
do
not
commute
with
unlabeled
arguments
applied
independently
begin
caml
example
toplevel
test
y
2
x
3
test
z
1
y
2
x
3
test
z
1
expect
error
end
caml
example
Here
test
is
already
0
0
0
and
cannot
be
further
applied
Optional
arguments
are
actually
implemented
as
option
types
If
you
do
not
give
a
default
value
you
have
access
to
their
internal
representation
type
a
option
None
Some
of
a
You
can
then
provide
different
behaviors
when
an
argument
is
present
or
not
begin
caml
example
toplevel
let
bump
step
x
match
step
with
None
x
2
Some
y
x
y
end
caml
example
It
may
also
be
useful
to
relay
an
optional
argument
from
a
function
call
to
another
This
can
be
done
by
prefixing
the
applied
argument
with
This
question
mark
disables
the
wrapping
of
optional
argument
in
an
option
type
begin
caml
example
toplevel
let
test2
x
y
test
x
y
test2
x
None
end
caml
example
section
s
label
inference
Labels
and
type
inference
While
they
provide
an
increased
comfort
for
writing
function
applications
labels
and
optional
arguments
have
the
pitfall
that
they
cannot
be
inferred
as
completely
as
the
rest
of
the
language
You
can
see
it
in
the
following
two
examples
begin
caml
example
toplevel
let
h
g
g
y
2
x
3
h
f
expect
error
let
bump
it
bump
x
bump
step
2
x
bump
it
bump
1
expect
error
end
caml
example
The
first
case
is
simple
g
is
passed
y
and
then
x
but
f
expects
x
and
then
y
This
is
correctly
handled
if
we
know
the
type
of
g
to
be
x
int
y
int
int
in
advance
but
otherwise
this
causes
the
above
type
clash
The
simplest
workaround
is
to
apply
formal
parameters
in
a
standard
order
The
second
example
is
more
subtle
while
we
intended
the
argument
bump
to
be
of
type
step
int
int
int
it
is
inferred
as
step
int
int
a
These
two
types
being
incompatible
internally
normal
and
optional
arguments
are
different
a
type
error
occurs
when
applying
bump
it
to
the
real
bump
We
will
not
try
here
to
explain
in
detail
how
type
inference
works
One
must
just
understand
that
there
is
not
enough
information
in
the
above
program
to
deduce
the
correct
type
of
g
or
bump
That
is
there
is
no
way
to
know
whether
an
argument
is
optional
or
not
or
which
is
the
correct
order
by
looking
only
at
how
a
function
is
applied
The
strategy
used
by
the
compiler
is
to
assume
that
there
are
no
optional
arguments
and
that
applications
are
done
in
the
right
order
The
right
way
to
solve
this
problem
for
optional
parameters
is
to
add
a
type
annotation
to
the
argument
bump
begin
caml
example
toplevel
let
bump
it
bump
step
int
int
int
x
bump
step
2
x
bump
it
bump
1
end
caml
example
In
practice
such
problems
appear
mostly
when
using
objects
whose
methods
have
optional
arguments
so
writing
the
type
of
object
arguments
is
often
a
good
idea
Normally
the
compiler
generates
a
type
error
if
you
attempt
to
pass
to
a
function
a
parameter
whose
type
is
different
from
the
expected
one
However
in
the
specific
case
where
the
expected
type
is
a
non
labeled
function
type
and
the
argument
is
a
function
expecting
optional
parameters
the
compiler
will
attempt
to
transform
the
argument
to
have
it
match
the
expected
type
by
passing
None
for
all
optional
parameters
begin
caml
example
toplevel
let
twice
f
x
int
f
f
x
twice
bump
2
end
caml
example
This
transformation
is
coherent
with
the
intended
semantics
including
side
effects
That
is
if
the
application
of
optional
parameters
shall
produce
side
effects
these
are
delayed
until
the
received
function
is
really
applied
to
an
argument
section
s
label
suggestions
Suggestions
for
labeling
Like
for
names
choosing
labels
for
functions
is
not
an
easy
task
A
good
labeling
is
one
which
begin
itemize
item
makes
programs
more
readable
item
is
easy
to
remember
item
when
possible
allows
useful
partial
applications
end
itemize
We
explain
here
the
rules
we
applied
when
labeling
OCaml
libraries
To
speak
in
an
object
oriented
way
one
can
consider
that
each
function
has
a
main
argument
its
em
object
and
other
arguments
related
with
its
action
the
em
parameters
To
permit
the
combination
of
functions
through
functionals
in
commuting
label
mode
the
object
will
not
be
labeled
Its
role
is
clear
from
the
function
itself
The
parameters
are
labeled
with
names
reminding
of
their
nature
or
their
role
The
best
labels
combine
nature
and
role
When
this
is
not
possible
the
role
is
to
be
preferred
since
the
nature
will
often
be
given
by
the
type
itself
Obscure
abbreviations
should
be
avoided
begin
alltt
ListLabels
map
f
a
b
a
list
b
list
UnixLabels
write
file
descr
buf
bytes
pos
int
len
int
unit
end
alltt
When
there
are
several
objects
of
same
nature
and
role
they
are
all
left
unlabeled
begin
alltt
ListLabels
iter2
f
a
b
unit
a
list
b
list
unit
end
alltt
When
there
is
no
preferable
object
all
arguments
are
labeled
begin
alltt
BytesLabels
blit
src
bytes
src
pos
int
dst
bytes
dst
pos
int
len
int
unit
end
alltt
However
when
there
is
only
one
argument
it
is
often
left
unlabeled
begin
alltt
BytesLabels
create
int
bytes
end
alltt
This
principle
also
applies
to
functions
of
several
arguments
whose
return
type
is
a
type
variable
as
long
as
the
role
of
each
argument
is
not
ambiguous
Labeling
such
functions
may
lead
to
awkward
error
messages
when
one
attempts
to
omit
labels
in
an
application
as
we
have
seen
with
ListLabels
fold
left
Here
are
some
of
the
label
names
you
will
find
throughout
the
libraries
begin
tableau
l
l
Label
Meaning
entree
f
a
function
to
be
applied
entree
pos
a
position
in
a
string
array
or
byte
sequence
entree
len
a
length
entree
buf
a
byte
sequence
or
string
used
as
buffer
entree
src
the
source
of
an
operation
entree
dst
the
destination
of
an
operation
entree
init
the
initial
value
for
an
iterator
entree
cmp
a
comparison
function
it
e
g
Stdlib
compare
entree
mode
an
operation
mode
or
a
flag
list
end
tableau
All
these
are
only
suggestions
but
keep
in
mind
that
the
choice
of
labels
is
essential
for
readability
Bizarre
choices
will
make
the
program
harder
to
maintain
In
the
ideal
the
right
function
name
with
right
labels
should
be
enough
to
understand
the
function
s
meaning
Since
one
can
get
this
information
with
OCamlBrowser
or
the
ocaml
toplevel
the
documentation
is
only
used
when
a
more
detailed
specification
is
needed
begin
caml
eval
label
false
end
caml
eval
chapter
Memory
model
The
hard
bits
HEVEA
cutname
memorymodel
html
label
c
memorymodel
This
chapter
describes
the
details
of
OCaml
relaxed
memory
model
The
relaxed
memory
model
describes
what
values
an
OCaml
program
is
allowed
to
witness
when
reading
a
memory
location
If
you
are
interested
in
high
level
parallel
programming
in
OCaml
please
have
a
look
at
the
parallel
programming
chapter
ref
c
parallelism
This
chapter
is
aimed
at
experts
who
would
like
to
understand
the
details
of
the
OCaml
memory
model
from
a
practitioner
s
perspective
For
a
formal
definition
of
the
OCaml
memory
model
its
guarantees
and
the
compilation
to
hardware
memory
models
please
have
a
look
at
the
PLDI
2018
paper
on
href
https
doi
org
10
1145
3192366
3192421
Bounding
Data
Races
in
Space
and
Time
The
memory
model
presented
in
this
chapter
is
an
extension
of
the
one
presented
in
the
PLDI
2018
paper
This
chapter
also
covers
some
pragmatic
aspects
of
the
memory
model
that
are
not
covered
in
the
paper
section
s
why
relaxed
memory
Why
weakly
consistent
memory
The
simplest
memory
model
that
we
could
give
to
our
programs
is
sequential
consistency
Under
sequential
consistency
the
values
observed
by
the
program
can
be
explained
through
some
interleaving
of
the
operations
from
different
domains
in
the
program
For
example
consider
the
following
program
with
two
domains
d1
and
d2
executing
in
parallel
begin
caml
example
verbatim
let
d1
a
b
let
r1
a
2
in
let
r2
b
in
let
r3
a
2
in
r1
r2
r3
let
d2
b
b
0
let
main
let
a
ref
1
in
let
b
ref
1
in
let
h
Domain
spawn
fun
let
r1
r2
r3
d1
a
b
in
Printf
printf
r1
d
r2
d
r3
d
n
r1
r2
r3
in
d2
b
Domain
join
h
end
caml
example
The
reference
cells
a
and
b
are
initially
1
The
user
may
observe
r1
2
r2
0
r3
2
if
the
write
to
b
in
d2
occurred
before
the
read
of
b
in
d1
Here
the
observed
behaviour
can
be
explained
in
terms
of
interleaving
of
the
operations
from
different
domains
Let
us
now
assume
that
a
and
b
are
aliases
of
each
other
begin
caml
example
verbatim
let
d1
a
b
let
r1
a
2
in
let
r2
b
in
let
r3
a
2
in
r1
r2
r3
let
d2
b
b
0
let
main
let
ab
ref
1
in
let
h
Domain
spawn
fun
let
r1
r2
r3
d1
ab
ab
in
assert
not
r1
2
r2
0
r3
2
in
d2
ab
Domain
join
h
end
caml
example
In
the
above
program
the
variables
ab
a
and
b
refer
to
the
same
reference
cell
One
would
expect
that
the
assertion
in
the
main
function
will
never
fail
The
reasoning
is
that
if
r2
is
0
then
the
write
in
d2
occurred
before
the
read
of
b
in
d1
Given
that
a
and
b
are
aliases
the
second
read
of
a
in
d1
should
also
return
0
subsection
ss
mm
comp
opt
Compiler
optimisations
Surprisingly
this
assertion
may
fail
in
OCaml
due
to
compiler
optimisations
The
OCaml
compiler
observes
the
common
sub
expression
a
2
in
d1
and
optimises
the
program
to
begin
caml
example
verbatim
let
d1
a
b
let
r1
a
2
in
let
r2
b
in
let
r3
r1
in
CSE
a
2
r1
r1
r2
r3
let
d2
b
b
0
let
main
let
ab
ref
1
in
let
h
Domain
spawn
fun
let
r1
r2
r3
d1
ab
ab
in
assert
not
r1
2
r2
0
r3
2
in
d2
ab
Domain
join
h
end
caml
example
This
optimisation
is
known
as
the
common
sub
expression
elimination
CSE
Such
optimisations
are
valid
and
necessary
for
good
performance
and
do
not
change
the
sequential
meaning
of
the
program
However
CSE
breaks
sequential
reasoning
In
the
optimized
program
above
even
if
the
write
to
b
in
d2
occurs
between
the
first
and
the
second
reads
in
d1
the
program
will
observe
the
value
2
for
r3
causing
the
assertion
to
fail
The
observed
behaviour
cannot
be
explained
by
interleaving
of
operations
from
different
domains
in
the
source
program
Thus
CSE
optimization
is
said
to
be
invalid
under
sequential
consistency
One
way
to
explain
the
observed
behaviour
is
as
if
the
operations
performed
on
a
domain
were
reordered
For
example
if
the
second
and
the
third
reads
from
d1
were
reordered
begin
caml
example
verbatim
let
d1
a
b
let
r1
a
2
in
let
r3
a
2
in
let
r2
b
in
r1
r2
r3
end
caml
example
noindent
then
we
can
explain
the
observed
behaviour
2
0
2
returned
by
d1
subsection
ss
mm
hw
opt
Hardware
optimisations
The
other
source
of
reordering
is
by
the
hardware
Modern
hardware
architectures
have
complex
cache
hierarchies
with
multiple
levels
of
cache
While
cache
coherence
ensures
that
reads
and
writes
to
a
single
memory
location
respect
sequential
consistency
the
guarantees
on
programs
that
operate
on
different
memory
locations
are
much
weaker
Consider
the
following
program
begin
caml
example
verbatim
let
a
ref
0
and
b
ref
0
let
d1
a
1
b
let
d2
b
1
a
let
main
let
h
Domain
spawn
d2
in
let
r1
d1
in
let
r2
Domain
join
h
in
assert
not
r1
0
r2
0
end
caml
example
Under
sequential
consistency
we
would
never
expect
the
assertion
to
fail
However
even
on
x86
which
offers
much
stronger
guarantees
than
ARM
the
writes
performed
at
a
CPU
core
are
not
immediately
published
to
all
of
the
other
cores
Since
a
and
b
are
different
memory
locations
the
reads
of
a
and
b
may
both
witness
the
initial
values
leading
to
the
assertion
failure
This
behaviour
can
be
explained
if
a
load
is
allowed
to
be
reordered
before
a
preceding
store
to
a
different
memory
location
This
reordering
can
happen
due
to
the
presence
of
in
core
store
buffers
on
modern
processors
Each
core
effectively
has
a
FIFO
buffer
of
pending
writes
to
avoid
the
need
to
block
while
a
write
completes
The
writes
to
a
and
b
may
be
in
the
store
buffers
of
cores
c1
and
c2
running
the
domains
d1
and
d2
respectively
The
reads
of
b
and
a
running
on
the
cores
c1
and
c2
respectively
will
not
see
the
writes
if
the
writes
have
not
propagated
from
the
buffers
to
the
main
memory
section
s
drf
sc
Data
race
freedom
implies
sequential
consistency
The
aim
of
the
OCaml
relaxed
memory
model
is
to
precisely
describe
which
orders
are
preserved
by
the
OCaml
program
The
compiler
and
the
hardware
are
free
to
optimize
the
program
as
long
as
they
respect
the
ordering
guarantees
of
the
memory
model
While
programming
directly
under
the
relaxed
memory
model
is
difficult
the
memory
model
also
describes
the
conditions
under
which
a
program
will
only
exhibit
sequentially
consistent
behaviours
This
guarantee
is
known
as
emph
data
race
freedom
implies
sequential
consistency
DRF
SC
In
this
section
we
shall
describe
this
guarantee
In
order
to
do
this
we
first
need
a
number
of
definitions
subsection
s
atomics
Memory
locations
OCaml
classifies
memory
locations
into
emph
atomic
and
emph
non
atomic
locations
Reference
cells
array
fields
and
mutable
record
fields
are
non
atomic
memory
locations
Immutable
objects
are
non
atomic
locations
with
an
initialising
write
but
no
further
updates
Atomic
memory
locations
are
those
that
are
created
using
the
stdmoduleref
Atomic
module
subsection
s
happens
before
Happens
before
relation
Let
us
imagine
that
the
OCaml
programs
are
executed
by
an
abstract
machine
that
executes
one
action
at
a
time
arbitrarily
picking
one
of
the
available
domains
at
each
step
We
classify
actions
into
two
emph
inter
domain
and
emph
intra
domain
An
inter
domain
action
is
one
which
can
be
observed
and
be
influenced
by
actions
on
other
domains
There
are
several
inter
domain
actions
begin
itemize
item
Reads
and
writes
of
atomic
and
non
atomic
locations
item
Spawn
and
join
of
domains
item
Operations
on
mutexes
end
itemize
TODO
Include
semaphores
and
condition
variables
in
the
inter
domain
actions
On
the
other
hand
intra
domain
actions
can
neither
be
observed
nor
influence
the
execution
of
other
domains
Examples
include
evaluating
an
arithmetic
expression
calling
a
function
etc
The
memory
model
specification
ignores
such
intra
domain
actions
In
the
sequel
we
use
the
term
action
to
indicate
inter
domain
actions
A
totally
ordered
list
of
actions
executed
by
the
abstract
machine
is
called
an
emph
execution
trace
There
might
be
several
possible
execution
traces
for
a
given
program
due
to
non
determinism
For
a
given
execution
trace
we
define
an
irreflexive
transitive
emph
happens
before
relation
that
captures
the
causality
between
actions
in
the
OCaml
program
The
happens
before
relation
is
defined
as
the
smallest
transitive
relation
satisfying
the
following
properties
begin
itemize
item
We
define
the
order
in
which
a
domain
executes
its
actions
as
the
emph
program
order
If
an
action
x
precedes
another
action
y
in
program
order
then
x
precedes
y
in
happens
before
order
item
If
x
is
a
write
to
an
atomic
location
and
y
is
a
subsequent
read
or
write
to
that
memory
location
in
the
execution
trace
then
x
precedes
y
in
happens
before
order
For
atomic
locations
compare
and
set
fetch
and
add
exchange
incr
and
decr
are
considered
to
perform
both
a
read
and
a
write
item
If
x
is
Domain
spawn
f
and
y
is
the
first
action
in
the
newly
spawned
domain
executing
f
then
x
precedes
y
in
happens
before
order
item
If
x
is
the
last
action
in
a
domain
d
and
y
is
Domain
join
d
then
x
precedes
y
in
happens
before
order
item
If
x
is
an
unlock
operation
on
a
mutex
and
y
is
any
subsequent
operation
on
the
mutex
in
the
execution
trace
then
x
precedes
y
in
happens
before
order
end
itemize
subsection
s
datarace
Data
race
In
a
given
trace
two
actions
are
said
to
be
emph
conflicting
if
they
access
the
same
non
atomic
location
at
least
one
is
a
write
and
neither
is
an
initialising
write
to
that
location
We
say
that
a
program
has
a
emph
data
race
if
there
exists
some
execution
trace
of
the
program
with
two
conflicting
actions
and
there
does
not
exist
a
happens
before
relationship
between
the
conflicting
accesses
A
program
without
data
races
is
said
to
be
emph
correctly
synchronised
subsection
ss
drf
sc
DRF
SC
textbf
DRF
SC
guarantee
A
program
without
data
races
will
only
exhibit
sequentially
consistent
behaviours
DRF
SC
is
a
strong
guarantee
for
the
programmers
Programmers
can
use
emph
sequential
reasoning
i
e
reasoning
by
executing
one
inter
domain
action
after
the
other
to
identify
whether
their
program
has
a
data
race
In
particular
they
do
not
need
to
reason
about
reorderings
described
in
section
ref
s
why
relaxed
memory
in
order
to
determine
whether
their
program
has
a
data
race
Once
the
determination
that
a
particular
program
is
data
race
free
is
made
they
do
not
need
to
worry
about
reorderings
in
their
code
section
s
drf
reasoning
Reasoning
with
DRF
SC
In
this
section
we
will
look
at
examples
of
using
DRF
SC
for
program
reasoning
In
this
section
we
will
use
the
functions
with
names
dN
to
represent
domains
executing
in
parallel
with
other
domains
That
is
we
assume
that
there
is
a
main
function
that
runs
the
dN
functions
in
parallel
as
follows
begin
verbatim
let
main
let
h1
Domain
spawn
d1
in
let
h2
Domain
spawn
d2
in
ignore
Domain
join
h1
ignore
Domain
join
h2
end
verbatim
Here
is
a
simple
example
with
a
data
race
begin
caml
example
verbatim
Has
data
race
let
r
ref
0
let
d1
r
1
let
d2
r
end
caml
example
r
is
a
non
atomic
reference
The
two
domains
race
to
access
the
reference
and
d1
is
a
write
Since
there
is
no
happens
before
relationship
between
the
conflicting
accesses
there
is
a
data
race
Both
of
the
programs
that
we
had
seen
in
the
section
ref
s
why
relaxed
memory
have
data
races
It
is
no
surprise
that
they
exhibit
non
sequentially
consistent
behaviours
Accessing
disjoint
array
indices
and
fields
of
a
record
in
parallel
is
not
a
data
race
For
example
begin
caml
example
verbatim
No
data
race
let
a
0
1
let
d1
a
0
42
let
d2
a
1
42
end
caml
example
begin
caml
example
verbatim
No
data
race
type
t
mutable
a
int
mutable
b
int
let
r
a
0
b
1
let
d1
r
a
42
let
d2
r
b
42
end
caml
example
noindent
do
not
have
data
races
Races
on
atomic
locations
do
not
lead
to
a
data
race
begin
caml
example
verbatim
No
data
race
let
r
Atomic
make
0
let
d1
Atomic
set
r
1
let
d2
Atomic
get
r
end
caml
example
subsubsection
s
mm
msg
passing
Message
passing
Atomic
variables
may
be
used
for
implementing
non
blocking
communication
between
domains
begin
caml
example
verbatim
No
data
race
let
msg
ref
0
let
flag
Atomic
make
false
let
d1
msg
42
a
Atomic
set
flag
true
b
let
d2
if
Atomic
get
flag
c
then
msg
d
else
0
end
caml
example
Observe
that
the
actions
a
and
d
write
and
read
from
the
same
non
atomic
location
msg
respectively
and
hence
are
conflicting
We
need
to
establish
that
a
and
d
have
a
happens
before
relationship
in
order
to
show
that
this
program
does
not
have
a
data
race
The
action
a
precedes
b
in
program
order
and
hence
a
happens
before
b
Similarly
c
happens
before
d
If
d2
observes
the
atomic
variable
flag
to
be
true
then
b
precedes
c
in
happens
before
order
Since
happens
before
is
transitive
the
conflicting
actions
a
and
d
are
in
happens
before
order
If
d2
observes
the
flag
to
be
false
then
the
read
of
msg
is
not
done
Hence
there
is
no
conflicting
access
in
this
execution
trace
Hence
the
program
does
not
have
a
data
race
The
following
modified
version
of
the
message
passing
program
does
have
a
data
race
begin
caml
example
verbatim
Has
data
race
let
msg
ref
0
let
flag
Atomic
make
false
let
d1
msg
42
a
Atomic
set
flag
true
b
let
d2
ignore
Atomic
get
flag
c
msg
d
end
caml
example
The
domain
d2
now
unconditionally
reads
the
non
atomic
reference
msg
Consider
the
execution
trace
begin
verbatim
Atomic
get
flag
c
msg
d
msg
42
a
Atomic
set
flag
true
b
end
verbatim
In
this
trace
d
and
a
are
conflicting
operations
But
there
is
no
happens
before
relationship
between
them
Hence
this
program
has
a
data
race
section
s
local
drf
Local
data
race
freedom
The
OCaml
memory
model
offers
strong
guarantees
even
for
programs
with
data
races
It
offers
what
is
known
as
emph
local
data
race
freedom
sequential
consistency
LDRF
SC
guarantee
A
formal
definition
of
this
property
is
beyond
the
scope
of
this
manual
chapter
Interested
readers
are
encouraged
to
read
the
PLDI
2018
paper
on
href
https
doi
org
10
1145
3192366
3192421
Bounding
Data
Races
in
Space
and
Time
Informally
LDRF
SC
says
that
the
data
race
free
parts
of
the
program
remain
sequentially
consistent
That
is
even
if
the
program
has
data
races
those
parts
of
the
program
that
are
disjoint
from
the
parts
with
data
races
are
amenable
to
sequential
reasoning
Consider
the
following
snippet
begin
caml
example
verbatim
let
snippet
let
c
ref
0
in
c
42
let
a
c
in
a
c
end
caml
example
Observe
that
c
is
a
newly
allocated
reference
Can
the
read
of
c
return
a
value
which
is
not
42
That
is
can
a
ever
be
not
42
Surprisingly
in
the
C
and
Java
memory
models
the
answer
is
yes
With
the
C
memory
model
if
the
program
has
a
data
race
even
in
unrelated
parts
then
the
semantics
is
undefined
If
this
snippet
were
linked
with
a
library
that
had
a
data
race
then
under
the
C
memory
model
the
read
may
return
any
value
Since
data
races
on
unrelated
locations
can
affect
program
behaviour
we
say
that
C
memory
model
is
not
bounded
in
space
Unlike
C
Java
memory
model
is
bounded
in
space
But
Java
memory
model
is
not
bounded
in
time
data
races
in
the
future
will
affect
the
past
behaviour
For
example
consider
the
translation
of
this
example
to
Java
We
assume
a
prior
definition
of
Class
c
int
x
and
a
shared
emph
non
volatile
variable
C
g
Now
the
snippet
may
be
part
of
a
larger
program
with
parallel
threads
begin
verbatim
Thread
1
C
c
new
C
c
x
42
a
c
x
g
c
Thread
2
g
x
7
end
verbatim
The
read
of
c
x
and
the
write
of
g
in
the
first
thread
are
done
on
separate
memory
locations
Hence
the
Java
memory
model
allows
them
to
be
reordered
As
a
result
the
write
in
the
second
thread
may
occur
before
the
read
of
c
x
and
hence
c
x
returns
7
The
OCaml
equivalent
of
the
Java
code
above
is
begin
caml
example
verbatim
let
g
ref
None
let
snippet
let
c
ref
0
in
c
42
let
a
c
in
a
c
let
d1
let
a
c
snippet
in
g
Some
c
a
let
d2
match
g
with
None
Some
c
c
7
end
caml
example
Observe
that
there
is
a
data
race
on
both
g
and
c
Consider
only
the
first
three
instructions
in
snippet
begin
verbatim
let
c
ref
0
in
c
42
let
a
c
in
end
verbatim
The
OCaml
memory
model
is
bounded
both
in
space
and
time
The
only
memory
location
here
is
c
Reasoning
only
about
this
snippet
there
is
neither
the
data
race
in
space
the
race
on
g
nor
in
time
the
future
race
on
c
Hence
the
snippet
will
have
sequentially
consistent
behaviour
and
the
value
returned
by
c
will
be
42
The
OCaml
memory
model
guarantees
that
even
for
programs
with
data
races
memory
safety
is
preserved
While
programs
with
data
races
may
observe
non
sequentially
consistent
behaviours
they
will
not
crash
section
s
mm
semantics
An
operational
view
of
the
memory
model
In
this
section
we
describe
the
semantics
of
the
OCaml
memory
model
A
formal
definition
of
the
operational
view
of
the
memory
model
is
presented
in
section
3
of
the
PLDI
2018
paper
on
href
https
doi
org
10
1145
3192366
3192421
Bounding
Data
Races
in
Space
and
Time
This
section
presents
an
informal
description
of
the
memory
model
with
the
help
of
an
example
Given
an
OCaml
program
which
may
possibly
contain
data
races
the
operational
semantics
tells
you
the
values
that
may
be
observed
by
the
read
of
a
memory
location
For
simplicity
we
restrict
the
intra
thread
actions
to
just
the
accesses
to
atomic
and
non
atomic
locations
ignoring
domain
spawn
and
join
operations
and
the
operations
on
mutexes
We
describe
the
semantics
of
the
OCaml
memory
model
in
a
straightforward
small
step
operational
manner
That
is
the
semantics
is
described
by
an
abstract
machine
that
executes
one
action
at
a
time
arbitrarily
picking
one
of
the
available
domains
at
each
step
This
is
similar
to
the
abstract
machine
that
we
had
used
to
describe
the
happens
before
relationship
in
section
ref
s
happens
before
subsection
ss
mm
non
atomic
Non
atomic
locations
In
the
semantics
we
model
non
atomic
locations
as
finite
maps
from
timestamps
t
to
values
v
We
take
timestamps
to
be
rational
numbers
The
timestamps
are
totally
ordered
but
dense
there
is
a
timestamp
between
any
two
others
For
example
begin
verbatim
a
t1
1
t2
2
b
t3
3
t4
4
t5
5
c
t6
5
t7
6
t8
7
end
verbatim
noindent
represents
three
non
atomic
locations
a
b
and
c
and
their
histories
The
location
a
has
two
writes
at
timestamps
t1
and
t2
with
values
1
and
2
respectively
When
we
write
a
t1
1
t2
2
we
assume
that
t1
t2
We
assume
that
the
locations
are
initialised
with
a
history
that
has
a
single
entry
at
timestamp
0
that
maps
to
the
initial
value
subsection
ss
mm
domains
Domains
Each
domain
is
equipped
with
a
emph
frontier
which
is
a
map
from
non
atomic
locations
to
timestamps
Intuitively
each
domain
s
frontier
records
for
each
non
atomic
location
the
latest
write
known
to
the
thread
More
recent
writes
may
have
occurred
but
are
not
guaranteed
to
be
visible
For
example
begin
verbatim
d1
a
t1
b
t3
c
t7
d2
a
t1
b
t4
c
t7
end
verbatim
noindent
represents
two
domains
d1
and
d2
and
their
frontiers
subsection
ss
mm
na
access
Non
atomic
accesses
Let
us
now
define
the
semantics
of
non
atomic
reads
and
writes
Suppose
domain
d1
performs
the
read
of
b
For
non
atomic
reads
the
domains
may
read
an
arbitrary
element
of
the
history
for
that
location
as
long
as
it
is
not
older
than
the
timestamp
in
the
domains
s
frontier
In
this
case
since
d1
frontier
at
b
is
at
t3
the
read
may
return
the
value
3
4
or
5
A
non
atomic
read
does
not
change
the
frontier
of
the
current
domain
Suppose
domain
d2
writes
the
value
10
to
c
c
10
We
pick
a
new
timestamp
t9
for
this
write
such
that
it
is
later
than
d2
s
frontier
at
c
Note
a
subtlety
here
this
new
timestamp
might
not
be
later
than
everything
else
in
the
history
but
merely
later
than
any
other
write
known
to
the
writing
domain
Hence
t9
may
be
inserted
in
c
s
history
either
a
between
t7
and
t8
or
b
after
t8
Let
us
pick
the
former
option
for
our
discussion
Since
the
new
write
appears
after
all
the
writes
known
by
the
domain
d2
to
the
location
c
d2
s
frontier
at
c
is
also
updated
The
new
state
of
the
abstract
machine
is
begin
verbatim
Non
atomic
locations
a
t1
1
t2
2
b
t3
3
t4
4
t5
5
c
t6
5
t7
6
t9
10
t8
7
new
write
at
t9
Domains
d1
a
t1
b
t3
c
t7
d2
a
t1
b
t4
c
t9
frontier
updated
at
c
end
verbatim
subsection
ss
mm
at
access
Atomic
accesses
Atomic
locations
carry
not
only
values
but
also
synchronization
information
We
model
atomic
locations
as
a
pair
of
the
value
held
by
that
location
and
a
frontier
The
frontier
models
the
synchronization
information
which
is
merged
with
the
frontiers
of
threads
that
operate
on
the
location
In
this
way
non
atomic
writes
made
by
one
thread
can
become
known
to
another
by
communicating
via
an
atomic
location
For
example
begin
verbatim
Atomic
locations
A
10
a
t1
b
t5
c
t7
B
5
a
t2
b
t4
c
t6
end
verbatim
noindent
shows
two
atomic
variables
A
and
B
with
values
10
and
5
respectively
and
frontiers
of
their
own
We
use
upper
case
variable
names
to
indicate
atomic
locations
During
atomic
reads
the
frontier
of
the
location
is
merged
into
that
of
the
domain
performing
the
read
For
example
suppose
d1
reads
B
The
read
returns
5
and
d1
s
frontier
updated
by
merging
it
with
B
s
frontier
choosing
the
later
timestamp
for
each
location
The
abstract
machine
state
before
the
atomic
read
is
begin
verbatim
Non
atomic
locations
a
t1
1
t2
2
b
t3
3
t4
4
t5
5
c
t6
5
t7
6
t9
10
t8
7
Domains
d1
a
t1
b
t3
c
t7
d2
a
t1
b
t4
c
t9
Atomic
locations
A
10
a
t1
b
t5
c
t7
B
5
a
t2
b
t4
c
t6
end
verbatim
As
a
result
of
the
atomic
read
the
abstract
machine
state
is
updated
to
begin
verbatim
Non
atomic
locations
a
t1
1
t2
2
b
t3
3
t4
4
t5
5
c
t6
5
t7
6
t9
10
t8
7
Domains
d1
a
t2
b
t4
c
t7
frontier
updated
at
a
and
b
d2
a
t1
b
t4
c
t9
Atomic
locations
A
10
a
t1
b
t5
c
t7
B
5
a
t2
b
t4
c
t6
end
verbatim
During
atomic
writes
the
value
held
by
the
atomic
location
is
updated
The
frontiers
of
both
the
writing
domain
and
that
of
the
location
being
written
to
are
updated
to
the
merge
of
the
two
frontiers
For
example
if
d2
writes
20
to
A
in
the
current
machine
state
the
machine
state
is
updated
to
begin
verbatim
Non
atomic
locations
a
t1
1
t2
2
b
t3
3
t4
4
t5
5
c
t6
5
t7
6
t9
10
t8
7
Domains
d1
a
t2
b
t4
c
t7
d2
a
t1
b
t5
c
t9
frontier
updated
at
b
Atomic
locations
A
20
a
t1
b
t5
c
t9
value
updated
frontier
updated
at
c
B
5
a
t2
b
t4
c
t6
end
verbatim
subsection
s
mm
semantics
reasoning
Reasoning
with
the
semantics
Let
us
revisit
an
example
from
earlier
section
ref
s
why
relaxed
memory
begin
caml
example
verbatim
let
a
ref
0
and
b
ref
0
let
d1
a
1
b
let
d2
b
1
a
let
main
let
h
Domain
spawn
d2
in
let
r1
d1
in
let
r2
Domain
join
h
in
assert
not
r1
0
r2
0
end
caml
example
This
program
has
a
data
race
on
a
and
b
and
hence
the
program
may
exhibit
non
sequentially
consistent
behaviour
Let
us
use
the
semantics
to
show
that
the
program
may
exhibit
r1
0
r2
0
The
initial
state
of
the
abstract
machine
is
begin
verbatim
Non
atomic
locations
a
t0
0
b
t1
0
Domains
d1
a
t0
b
t1
d2
a
t0
b
t1
end
verbatim
There
are
several
possible
schedules
for
executing
this
program
Let
us
consider
the
following
schedule
begin
verbatim
1
a
1
d1
2
b
1
d2
3
b
d1
4
a
d2
end
verbatim
After
the
first
action
a
1
by
d1
the
machine
state
is
begin
verbatim
Non
atomic
locations
a
t0
0
t2
1
new
write
at
t2
b
t1
0
Domains
d1
a
t2
b
t1
frontier
updated
at
a
d2
a
t0
b
t1
end
verbatim
After
the
second
action
b
1
by
d2
the
machine
state
is
begin
verbatim
Non
atomic
locations
a
t0
0
t2
1
b
t1
0
t3
1
new
write
at
t3
Domains
d1
a
t2
b
t1
d2
a
t0
b
t3
frontier
updated
at
b
end
verbatim
Now
for
the
third
action
b
by
d1
observe
that
d1
s
frontier
at
b
is
at
t1
Hence
the
read
may
return
either
0
or
1
Let
us
assume
that
it
returns
0
The
machine
state
is
not
updated
by
the
non
atomic
read
Similarly
for
the
fourth
action
a
by
d2
d2
s
frontier
at
a
is
at
t0
Hence
this
read
may
also
return
either
0
or
1
Let
us
assume
that
it
returns
0
Hence
the
assertion
in
the
original
program
assert
not
r1
0
r2
0
will
fail
for
this
particular
execution
section
s
mm
tearing
Non
compliant
operations
There
are
certain
operations
which
are
not
memory
model
compliant
begin
itemize
item
Array
blit
function
on
float
arrays
may
cause
emph
tearing
When
an
unsynchronized
blit
operation
runs
concurrently
with
some
overlapping
write
to
the
fields
of
the
same
float
array
the
field
may
end
up
with
bits
from
either
of
the
writes
item
With
flat
float
arrays
or
records
with
only
float
fields
on
32
bit
architectures
getting
or
setting
a
field
involves
two
separate
memory
accesses
In
the
presence
of
data
races
the
user
may
observe
tearing
item
The
Bytes
module
stdmoduleref
Bytes
permits
mixed
mode
accesses
where
reads
and
writes
may
be
of
different
sizes
Unsynchronized
mixed
mode
accesses
lead
to
tearing
end
itemize
chapter
Polymorphism
and
its
limitations
label
c
polymorphism
HEVEA
cutname
polymorphism
html
bigskip
noindent
This
chapter
covers
more
advanced
questions
related
to
the
limitations
of
polymorphic
functions
and
types
There
are
some
situations
in
OCaml
where
the
type
inferred
by
the
type
checker
may
be
less
generic
than
expected
Such
non
genericity
can
stem
either
from
interactions
between
side
effects
and
typing
or
the
difficulties
of
implicit
polymorphic
recursion
and
higher
rank
polymorphism
This
chapter
details
each
of
these
situations
and
if
it
is
possible
how
to
recover
genericity
section
s
weak
polymorphism
Weak
polymorphism
and
mutation
subsection
ss
weak
types
Weakly
polymorphic
types
Maybe
the
most
frequent
examples
of
non
genericity
derive
from
the
interactions
between
polymorphic
types
and
mutation
A
simple
example
appears
when
typing
the
following
expression
begin
caml
example
toplevel
let
store
ref
None
end
caml
example
Since
the
type
of
None
is
a
option
and
the
function
ref
has
type
b
b
ref
a
natural
deduction
for
the
type
of
store
would
be
a
option
ref
However
the
inferred
type
weak1
option
ref
is
different
Type
variables
whose
names
start
with
a
weak
prefix
like
weak1
are
weakly
polymorphic
type
variables
sometimes
shortened
to
weak
type
variables
A
weak
type
variable
is
a
placeholder
for
a
single
type
that
is
currently
unknown
Once
the
specific
type
t
behind
the
placeholder
type
weak1
is
known
all
occurrences
of
weak1
will
be
replaced
by
t
For
instance
we
can
define
another
option
reference
and
store
an
int
inside
begin
caml
example
toplevel
let
another
store
ref
None
another
store
Some
0
another
store
end
caml
example
After
storing
an
int
inside
another
store
the
type
of
another
store
has
been
updated
from
weak2
option
ref
to
int
option
ref
This
distinction
between
weakly
and
generic
polymorphic
type
variable
protects
OCaml
programs
from
unsoundness
and
runtime
errors
To
understand
from
where
unsoundness
might
come
consider
this
simple
function
which
swaps
a
value
x
with
the
value
stored
inside
a
store
reference
if
there
is
such
value
begin
caml
example
toplevel
let
swap
store
x
match
store
with
None
store
Some
x
x
Some
y
store
Some
x
y
end
caml
example
We
can
apply
this
function
to
our
store
begin
caml
example
toplevel
let
one
swap
store
1
let
one
again
swap
store
2
let
two
swap
store
3
end
caml
example
After
these
three
swaps
the
stored
value
is
3
Everything
is
fine
up
to
now
We
can
then
try
to
swap
3
with
a
more
interesting
value
for
instance
a
function
begin
caml
example
toplevel
error
let
error
swap
store
fun
x
x
end
caml
example
At
this
point
the
type
checker
rightfully
complains
that
it
is
not
possible
to
swap
an
integer
and
a
function
and
that
an
int
should
always
be
traded
for
another
int
Furthermore
the
type
checker
prevents
us
from
manually
changing
the
type
of
the
value
stored
by
store
begin
caml
example
toplevel
error
store
Some
fun
x
x
end
caml
example
Indeed
looking
at
the
type
of
store
we
see
that
the
weak
type
weak1
has
been
replaced
by
the
type
int
begin
caml
example
toplevel
store
end
caml
example
Therefore
after
placing
an
int
in
store
we
cannot
use
it
to
store
any
value
other
than
an
int
More
generally
weak
types
protect
the
program
from
undue
mutation
of
values
with
a
polymorphic
type
todo
fix
indentation
in
manual
pdf
Moreover
weak
types
cannot
appear
in
the
signature
of
toplevel
modules
types
must
be
known
at
compilation
time
Otherwise
different
compilation
units
could
replace
the
weak
type
with
different
and
incompatible
types
For
this
reason
compiling
the
following
small
piece
of
code
begin
verbatim
let
option
ref
ref
None
end
verbatim
yields
a
compilation
error
begin
verbatim
Error
The
type
of
this
expression
weak1
option
ref
contains
type
variables
that
cannot
be
generalized
end
verbatim
To
solve
this
error
it
is
enough
to
add
an
explicit
type
annotation
to
specify
the
type
at
declaration
time
begin
verbatim
let
option
ref
int
option
ref
ref
None
end
verbatim
This
is
in
any
case
a
good
practice
for
such
global
mutable
variables
Otherwise
they
will
pick
out
the
type
of
first
use
If
there
is
a
mistake
at
this
point
it
can
result
in
confusing
type
errors
when
later
correct
uses
are
flagged
as
errors
subsection
ss
valuerestriction
The
value
restriction
Identifying
the
exact
context
in
which
polymorphic
types
should
be
replaced
by
weak
types
in
a
modular
way
is
a
difficult
question
Indeed
the
type
system
must
handle
the
possibility
that
functions
may
hide
persistent
mutable
states
For
instance
the
following
function
uses
an
internal
reference
to
implement
a
delayed
identity
function
begin
caml
example
toplevel
let
make
fake
id
let
store
ref
None
in
fun
x
swap
store
x
let
fake
id
make
fake
id
end
caml
example
It
would
be
unsound
to
apply
this
fake
id
function
to
values
with
different
types
The
function
fake
id
is
therefore
rightfully
assigned
the
type
weak3
weak3
rather
than
a
a
At
the
same
time
it
ought
to
be
possible
to
use
a
local
mutable
state
without
impacting
the
type
of
a
function
todo
add
an
example
To
circumvent
these
dual
difficulties
the
type
checker
considers
that
any
value
returned
by
a
function
might
rely
on
persistent
mutable
states
behind
the
scene
and
should
be
given
a
weak
type
This
restriction
on
the
type
of
mutable
values
and
the
results
of
function
application
is
called
the
value
restriction
Note
that
this
value
restriction
is
conservative
there
are
situations
where
the
value
restriction
is
too
cautious
and
gives
a
weak
type
to
a
value
that
could
be
safely
generalized
to
a
polymorphic
type
begin
caml
example
toplevel
let
not
id
fun
x
x
fun
x
x
end
caml
example
Quite
often
this
happens
when
defining
functions
using
higher
order
functions
To
avoid
this
problem
a
solution
is
to
add
an
explicit
argument
to
the
function
begin
caml
example
toplevel
let
id
again
fun
x
fun
x
x
fun
x
x
x
end
caml
example
With
this
argument
id
again
is
seen
as
a
function
definition
by
the
type
checker
and
can
therefore
be
generalized
This
kind
of
manipulation
is
called
eta
expansion
in
lambda
calculus
and
is
sometimes
referred
under
this
name
subsection
ss
relaxed
value
restriction
The
relaxed
value
restriction
There
is
another
partial
solution
to
the
problem
of
unnecessary
weak
types
which
is
implemented
directly
within
the
type
checker
Briefly
it
is
possible
to
prove
that
weak
types
that
only
appear
as
type
parameters
in
covariant
positions
also
called
positive
positions
can
be
safely
generalized
to
polymorphic
types
For
instance
the
type
a
list
is
covariant
in
a
begin
caml
example
toplevel
let
f
let
empty
f
end
caml
example
Note
that
the
type
inferred
for
empty
is
a
list
and
not
the
weak5
list
that
should
have
occurred
with
the
value
restriction
The
value
restriction
combined
with
this
generalization
for
covariant
type
parameters
is
called
the
relaxed
value
restriction
question
is
here
the
best
place
for
describing
variance
subsection
ss
variance
and
value
restriction
Variance
and
value
restriction
Variance
describes
how
type
constructors
behave
with
respect
to
subtyping
Consider
for
instance
a
pair
of
type
x
and
xy
with
x
a
subtype
of
xy
denoted
x
xy
begin
caml
example
toplevel
type
x
X
type
xy
X
Y
end
caml
example
As
x
is
a
subtype
of
xy
we
can
convert
a
value
of
type
x
to
a
value
of
type
xy
begin
caml
example
toplevel
let
x
x
X
let
x
x
xy
end
caml
example
Similarly
if
we
have
a
value
of
type
x
list
we
can
convert
it
to
a
value
of
type
xy
list
since
we
could
convert
each
element
one
by
one
begin
caml
example
toplevel
let
l
x
list
X
X
let
l
l
xy
list
end
caml
example
In
other
words
x
xy
implies
that
x
list
xy
list
therefore
the
type
constructor
a
list
is
covariant
it
preserves
subtyping
in
its
parameter
a
Contrarily
if
we
have
a
function
that
can
handle
values
of
type
xy
begin
caml
example
toplevel
let
f
xy
unit
function
X
Y
end
caml
example
it
can
also
handle
values
of
type
x
begin
caml
example
toplevel
let
f
f
x
unit
end
caml
example
Note
that
we
can
rewrite
the
type
of
f
and
f
as
begin
caml
example
toplevel
type
a
proc
a
unit
let
f
f
xy
proc
x
proc
end
caml
example
In
this
case
we
have
x
xy
implies
xy
proc
x
proc
Notice
that
the
second
subtyping
relation
reverse
the
order
of
x
and
xy
the
type
constructor
a
proc
is
contravariant
in
its
parameter
a
More
generally
the
function
type
constructor
a
b
is
covariant
in
its
return
type
b
and
contravariant
in
its
argument
type
a
A
type
constructor
can
also
be
invariant
in
some
of
its
type
parameters
neither
covariant
nor
contravariant
A
typical
example
is
a
reference
begin
caml
example
toplevel
let
x
x
ref
ref
X
end
caml
example
If
we
were
able
to
coerce
x
to
the
type
xy
ref
as
a
variable
xy
we
could
use
xy
to
store
the
value
Y
inside
the
reference
and
then
use
the
x
value
to
read
this
content
as
a
value
of
type
x
which
would
break
the
type
system
More
generally
as
soon
as
a
type
variable
appears
in
a
position
describing
mutable
state
it
becomes
invariant
As
a
corollary
covariant
variables
will
never
denote
mutable
locations
and
can
be
safely
generalized
For
a
better
description
interested
readers
can
consult
the
original
article
by
Jacques
Garrigue
on
url
http
www
math
nagoya
u
ac
jp
garrigue
papers
morepoly
long
pdf
Together
the
relaxed
value
restriction
and
type
parameter
covariance
help
to
avoid
eta
expansion
in
many
situations
subsection
ss
variance
abstract
data
types
Abstract
data
types
Moreover
when
the
type
definitions
are
exposed
the
type
checker
is
able
to
infer
variance
information
on
its
own
and
one
can
benefit
from
the
relaxed
value
restriction
even
unknowingly
However
this
is
not
the
case
anymore
when
defining
new
abstract
types
As
an
illustration
we
can
define
a
module
type
collection
as
begin
caml
example
toplevel
module
type
COLLECTION
sig
type
a
t
val
empty
unit
a
t
end
module
Implementation
struct
type
a
t
a
list
let
empty
end
module
List2
COLLECTION
Implementation
end
caml
example
In
this
situation
when
coercing
the
module
List2
to
the
module
type
COLLECTION
the
type
checker
forgets
that
a
List2
t
was
covariant
in
a
Consequently
the
relaxed
value
restriction
does
not
apply
anymore
begin
caml
example
toplevel
List2
empty
end
caml
example
To
keep
the
relaxed
value
restriction
we
need
to
declare
the
abstract
type
a
COLLECTION
t
as
covariant
in
a
begin
caml
example
toplevel
module
type
COLLECTION
sig
type
a
t
val
empty
unit
a
t
end
module
List2
COLLECTION
Implementation
end
caml
example
We
then
recover
polymorphism
begin
caml
example
toplevel
List2
empty
end
caml
example
section
s
polymorphic
recursion
Polymorphic
recursion
The
second
major
class
of
non
genericity
is
directly
related
to
the
problem
of
type
inference
for
polymorphic
functions
In
some
circumstances
the
type
inferred
by
OCaml
might
be
not
general
enough
to
allow
the
definition
of
some
recursive
functions
in
particular
for
recursive
functions
acting
on
non
regular
algebraic
data
types
With
a
regular
polymorphic
algebraic
data
type
the
type
parameters
of
the
type
constructor
are
constant
within
the
definition
of
the
type
For
instance
we
can
look
at
arbitrarily
nested
list
defined
as
begin
caml
example
toplevel
type
a
regular
nested
List
of
a
list
Nested
of
a
regular
nested
list
let
l
Nested
List
1
Nested
List
2
3
Nested
Nested
end
caml
example
Note
that
the
type
constructor
regular
nested
always
appears
as
a
regular
nested
in
the
definition
above
with
the
same
parameter
a
Equipped
with
this
type
one
can
compute
a
depth
with
a
classic
recursive
function
begin
caml
example
toplevel
let
rec
regular
depth
function
List
1
Nested
n
1
List
fold
left
max
1
List
map
regular
depth
n
end
caml
example
Non
regular
recursive
algebraic
data
types
correspond
to
polymorphic
algebraic
data
types
whose
parameter
types
vary
between
the
left
and
right
side
of
the
type
definition
For
instance
it
might
be
interesting
to
define
a
datatype
that
ensures
that
all
lists
are
nested
at
the
same
depth
begin
caml
example
toplevel
type
a
nested
List
of
a
list
Nested
of
a
list
nested
end
caml
example
Intuitively
a
value
of
type
a
nested
is
a
list
of
list
dots
of
list
of
elements
a
with
k
nested
list
We
can
then
adapt
the
regular
depth
function
defined
on
regular
nested
into
a
depth
function
that
computes
this
k
As
a
first
try
we
may
define
begin
caml
example
toplevel
error
let
rec
depth
function
List
1
Nested
n
1
depth
n
end
caml
example
The
type
error
here
comes
from
the
fact
that
during
the
definition
of
depth
the
type
checker
first
assigns
to
depth
the
type
a
b
When
typing
the
pattern
matching
a
b
becomes
a
nested
b
then
a
nested
int
once
the
List
branch
is
typed
However
when
typing
the
application
depth
n
in
the
Nested
branch
the
type
checker
encounters
a
problem
depth
n
is
applied
to
a
list
nested
it
must
therefore
have
the
type
a
list
nested
b
Unifying
this
constraint
with
the
previous
one
leads
to
the
impossible
constraint
a
list
nested
a
nested
In
other
words
within
its
definition
the
recursive
function
depth
is
applied
to
values
of
type
a
t
with
different
types
a
due
to
the
non
regularity
of
the
type
constructor
nested
This
creates
a
problem
because
the
type
checker
had
introduced
a
new
type
variable
a
only
at
the
emph
definition
of
the
function
depth
whereas
here
we
need
a
different
type
variable
for
every
emph
application
of
the
function
depth
subsection
ss
explicit
polymorphism
Explicitly
polymorphic
annotations
The
solution
of
this
conundrum
is
to
use
an
explicitly
polymorphic
type
annotation
for
the
type
a
begin
caml
example
toplevel
let
rec
depth
a
a
nested
int
function
List
1
Nested
n
1
depth
n
depth
Nested
List
7
8
end
caml
example
In
the
type
of
depth
a
a
nested
int
the
type
variable
a
is
universally
quantified
In
other
words
a
a
nested
int
reads
as
for
all
type
a
depth
maps
a
nested
values
to
integers
Whereas
the
standard
type
a
nested
int
can
be
interpreted
as
let
be
a
type
variable
a
then
depth
maps
a
nested
values
to
integers
There
are
two
major
differences
with
these
two
type
expressions
First
the
explicit
polymorphic
annotation
indicates
to
the
type
checker
that
it
needs
to
introduce
a
new
type
variable
every
time
the
function
depth
is
applied
This
solves
our
problem
with
the
definition
of
the
function
depth
Second
it
also
notifies
the
type
checker
that
the
type
of
the
function
should
be
polymorphic
Indeed
without
explicit
polymorphic
type
annotation
the
following
type
annotation
is
perfectly
valid
begin
caml
example
toplevel
let
sum
a
b
c
fun
x
y
x
y
end
caml
example
since
a
b
and
c
denote
type
variables
that
may
or
may
not
be
polymorphic
Whereas
it
is
an
error
to
unify
an
explicitly
polymorphic
type
with
a
non
polymorphic
type
begin
caml
example
toplevel
error
let
sum
a
b
c
a
b
c
fun
x
y
x
y
end
caml
example
An
important
remark
here
is
that
it
is
not
needed
to
explicit
fully
the
type
of
depth
it
is
sufficient
to
add
annotations
only
for
the
universally
quantified
type
variables
begin
caml
example
toplevel
let
rec
depth
a
a
nested
function
List
1
Nested
n
1
depth
n
depth
Nested
List
7
8
end
caml
example
todo
add
a
paragraph
on
the
interaction
with
locally
abstract
type
subsection
ss
recursive
poly
examples
More
examples
With
explicit
polymorphic
annotations
it
becomes
possible
to
implement
any
recursive
function
that
depends
only
on
the
structure
of
the
nested
lists
and
not
on
the
type
of
the
elements
For
instance
a
more
complex
example
would
be
to
compute
the
total
number
of
elements
of
the
nested
lists
begin
caml
example
toplevel
let
len
nested
let
map
and
sum
f
List
fold
left
fun
acc
x
acc
f
x
0
in
let
rec
len
a
a
list
int
a
nested
int
fun
nested
len
n
match
n
with
List
l
nested
len
l
Nested
n
len
map
and
sum
nested
len
n
in
len
List
length
nested
len
Nested
Nested
List
1
2
3
4
5
6
7
end
caml
example
Similarly
it
may
be
necessary
to
use
more
than
one
explicitly
polymorphic
type
variables
like
for
computing
the
nested
list
of
list
lengths
of
the
nested
list
begin
caml
example
toplevel
let
shape
n
let
rec
shape
a
b
a
nested
int
nested
b
list
list
a
list
b
nested
int
nested
fun
nest
nested
shape
function
List
l
raise
Invalid
argument
shape
requires
nested
list
of
depth
greater
than
1
Nested
List
l
nest
List
nested
shape
l
Nested
n
let
nested
shape
List
map
nested
shape
in
let
nest
x
nest
Nested
x
in
shape
nest
nested
shape
n
in
shape
fun
n
n
fun
l
List
map
List
length
l
n
shape
Nested
Nested
List
1
2
3
4
5
6
7
end
caml
example
section
s
higher
rank
poly
Higher
rank
polymorphic
functions
Explicit
polymorphic
annotations
are
however
not
sufficient
to
cover
all
the
cases
where
the
inferred
type
of
a
function
is
less
general
than
expected
A
similar
problem
arises
when
using
polymorphic
functions
as
arguments
of
higher
order
functions
For
instance
we
may
want
to
compute
the
average
depth
or
length
of
two
nested
lists
begin
caml
example
toplevel
let
average
depth
x
y
depth
x
depth
y
2
let
average
len
x
y
len
x
len
y
2
let
one
average
len
List
2
List
end
caml
example
It
would
be
natural
to
factorize
these
two
definitions
as
begin
caml
example
toplevel
let
average
f
x
y
f
x
f
y
2
end
caml
example
However
the
type
of
average
len
is
less
generic
than
the
type
of
average
len
since
it
requires
the
type
of
the
first
and
second
argument
to
be
the
same
begin
caml
example
toplevel
average
len
List
2
List
average
len
List
2
List
expect
error
end
caml
example
As
previously
with
polymorphic
recursion
the
problem
stems
from
the
fact
that
type
variables
are
introduced
only
at
the
start
of
the
let
definitions
When
we
compute
both
f
x
and
f
y
the
type
of
x
and
y
are
unified
together
To
avoid
this
unification
we
need
to
indicate
to
the
type
checker
that
f
is
polymorphic
in
its
first
argument
In
some
sense
we
would
want
average
to
have
type
begin
verbatim
val
average
a
a
nested
int
a
nested
b
nested
int
end
verbatim
Note
that
this
syntax
is
not
valid
within
OCaml
average
has
an
universally
quantified
type
a
inside
the
type
of
one
of
its
argument
whereas
for
polymorphic
recursion
the
universally
quantified
type
was
introduced
before
the
rest
of
the
type
This
position
of
the
universally
quantified
type
means
that
average
is
a
second
rank
polymorphic
function
This
kind
of
higher
rank
functions
is
not
directly
supported
by
OCaml
type
inference
for
second
rank
polymorphic
function
and
beyond
is
undecidable
therefore
using
this
kind
of
higher
rank
functions
requires
to
handle
manually
these
universally
quantified
types
In
OCaml
there
are
two
ways
to
introduce
this
kind
of
explicit
universally
quantified
types
universally
quantified
record
fields
begin
caml
example
toplevel
type
a
nested
reduction
f
elt
elt
nested
a
let
boxed
len
f
len
end
caml
example
and
universally
quantified
object
methods
begin
caml
example
toplevel
let
obj
len
object
method
f
a
a
nested
b
len
end
end
caml
example
To
solve
our
problem
we
can
therefore
use
either
the
record
solution
begin
caml
example
toplevel
let
average
nsm
x
y
nsm
f
x
nsm
f
y
2
end
caml
example
or
the
object
one
begin
caml
example
toplevel
let
average
obj
f
a
a
nested
x
y
obj
f
x
obj
f
y
2
end
caml
example
chapter
The
core
language
label
c
core
xamples
HEVEA
cutname
coreexamples
html
This
part
of
the
manual
is
a
tutorial
introduction
to
the
OCaml
language
A
good
familiarity
with
programming
in
a
conventional
languages
say
C
or
Java
is
assumed
but
no
prior
exposure
to
functional
languages
is
required
The
present
chapter
introduces
the
core
language
Chapter
ref
c
moduleexamples
deals
with
the
module
system
chapter
ref
c
objectexamples
with
the
object
oriented
features
chapter
ref
c
labl
examples
with
labeled
arguments
chapter
ref
c
poly
variant
with
polymorphic
variants
chapter
ref
c
polymorphism
with
the
limitations
of
polymorphism
and
chapter
ref
c
advexamples
gives
some
advanced
examples
section
s
basics
Basics
For
this
overview
of
OCaml
we
use
the
interactive
system
which
is
started
by
running
ocaml
from
the
Unix
shell
or
Windows
command
prompt
This
tutorial
is
presented
as
the
transcript
of
a
session
with
the
interactive
system
lines
starting
with
represent
user
input
the
system
responses
are
printed
below
without
a
leading
Under
the
interactive
system
the
user
types
OCaml
phrases
terminated
by
in
response
to
the
prompt
and
the
system
compiles
them
on
the
fly
executes
them
and
prints
the
outcome
of
evaluation
Phrases
are
either
simple
expressions
or
let
definitions
of
identifiers
either
values
or
functions
begin
caml
example
toplevel
1
2
3
let
pi
4
0
atan
1
0
let
square
x
x
x
square
sin
pi
square
cos
pi
end
caml
example
The
OCaml
system
computes
both
the
value
and
the
type
for
each
phrase
Even
function
parameters
need
no
explicit
type
declaration
the
system
infers
their
types
from
their
usage
in
the
function
Notice
also
that
integers
and
floating
point
numbers
are
distinct
types
with
distinct
operators
and
operate
on
integers
but
and
operate
on
floats
begin
caml
example
toplevel
error
1
0
2
end
caml
example
Recursive
functions
are
defined
with
the
let
rec
binding
begin
caml
example
toplevel
let
rec
fib
n
if
n
2
then
n
else
fib
n
1
fib
n
2
fib
10
end
caml
example
section
s
datatypes
Data
types
In
addition
to
integers
and
floating
point
numbers
OCaml
offers
the
usual
basic
data
types
begin
itemize
item
booleans
begin
caml
example
toplevel
1
2
false
let
one
if
true
then
1
else
2
end
caml
example
item
characters
begin
caml
example
toplevel
a
int
of
char
n
end
caml
example
item
immutable
character
strings
begin
caml
example
toplevel
Hello
world
This
is
a
quoted
string
here
neither
nor
are
special
characters
delimiter
the
end
of
this
quoted
string
is
here
delimiter
the
end
of
this
quoted
string
is
here
end
caml
example
end
itemize
Predefined
data
structures
include
tuples
arrays
and
lists
There
are
also
general
mechanisms
for
defining
your
own
data
structures
such
as
records
and
variants
which
will
be
covered
in
more
detail
later
for
now
we
concentrate
on
lists
Lists
are
either
given
in
extension
as
a
bracketed
list
of
semicolon
separated
elements
or
built
from
the
empty
list
pronounce
nil
by
adding
elements
in
front
using
the
cons
operator
begin
caml
example
toplevel
let
l
is
a
tale
told
etc
Life
l
end
caml
example
As
with
all
other
OCaml
data
structures
lists
do
not
need
to
be
explicitly
allocated
and
deallocated
from
memory
all
memory
management
is
entirely
automatic
in
OCaml
Similarly
there
is
no
explicit
handling
of
pointers
the
OCaml
compiler
silently
introduces
pointers
where
necessary
As
with
most
OCaml
data
structures
inspecting
and
destructuring
lists
is
performed
by
pattern
matching
List
patterns
have
exactly
the
same
form
as
list
expressions
with
identifiers
representing
unspecified
parts
of
the
list
As
an
example
here
is
insertion
sort
on
a
list
begin
caml
example
toplevel
let
rec
sort
lst
match
lst
with
head
tail
insert
head
sort
tail
and
insert
elt
lst
match
lst
with
elt
head
tail
if
elt
head
then
elt
lst
else
head
insert
elt
tail
sort
l
end
caml
example
The
type
inferred
for
sort
a
list
a
list
means
that
sort
can
actually
apply
to
lists
of
any
type
and
returns
a
list
of
the
same
type
The
type
a
is
a
em
type
variable
and
stands
for
any
given
type
The
reason
why
sort
can
apply
to
lists
of
any
type
is
that
the
comparisons
etc
are
em
polymorphic
in
OCaml
they
operate
between
any
two
values
of
the
same
type
This
makes
sort
itself
polymorphic
over
all
list
types
begin
caml
example
toplevel
sort
6
2
5
3
sort
3
14
2
718
end
caml
example
The
sort
function
above
does
not
modify
its
input
list
it
builds
and
returns
a
new
list
containing
the
same
elements
as
the
input
list
in
ascending
order
There
is
actually
no
way
in
OCaml
to
modify
a
list
in
place
once
it
is
built
we
say
that
lists
are
em
immutable
data
structures
Most
OCaml
data
structures
are
immutable
but
a
few
most
notably
arrays
are
em
mutable
meaning
that
they
can
be
modified
in
place
at
any
time
The
OCaml
notation
for
the
type
of
a
function
with
multiple
arguments
is
arg1
type
arg2
type
return
type
For
example
the
type
inferred
for
insert
a
a
list
a
list
means
that
insert
takes
two
arguments
an
element
of
any
type
a
and
a
list
with
elements
of
the
same
type
a
and
returns
a
list
of
the
same
type
section
s
functions
as
values
Functions
as
values
OCaml
is
a
functional
language
functions
in
the
full
mathematical
sense
are
supported
and
can
be
passed
around
freely
just
as
any
other
piece
of
data
For
instance
here
is
a
deriv
function
that
takes
any
float
function
as
argument
and
returns
an
approximation
of
its
derivative
function
begin
caml
example
toplevel
let
deriv
f
dx
fun
x
f
x
dx
f
x
dx
let
sin
deriv
sin
1e
6
sin
pi
end
caml
example
Even
function
composition
is
definable
begin
caml
example
toplevel
let
compose
f
g
fun
x
f
g
x
let
cos2
compose
square
cos
end
caml
example
Functions
that
take
other
functions
as
arguments
are
called
functionals
or
higher
order
functions
Functionals
are
especially
useful
to
provide
iterators
or
similar
generic
operations
over
a
data
structure
For
instance
the
standard
OCaml
library
provides
a
List
map
functional
that
applies
a
given
function
to
each
element
of
a
list
and
returns
the
list
of
the
results
begin
caml
example
toplevel
List
map
fun
n
n
2
1
0
1
2
3
4
end
caml
example
This
functional
along
with
a
number
of
other
list
and
array
functionals
is
predefined
because
it
is
often
useful
but
there
is
nothing
magic
with
it
it
can
easily
be
defined
as
follows
begin
caml
example
toplevel
let
rec
map
f
l
match
l
with
hd
tl
f
hd
map
f
tl
end
caml
example
section
s
tut
recvariants
Records
and
variants
User
defined
data
structures
include
records
and
variants
Both
are
defined
with
the
type
declaration
Here
we
declare
a
record
type
to
represent
rational
numbers
begin
caml
example
toplevel
type
ratio
num
int
denom
int
let
add
ratio
r1
r2
num
r1
num
r2
denom
r2
num
r1
denom
denom
r1
denom
r2
denom
add
ratio
num
1
denom
3
num
2
denom
5
end
caml
example
Record
fields
can
also
be
accessed
through
pattern
matching
begin
caml
example
toplevel
let
integer
part
r
match
r
with
num
num
denom
denom
num
denom
end
caml
example
Since
there
is
only
one
case
in
this
pattern
matching
it
is
safe
to
expand
directly
the
argument
r
in
a
record
pattern
begin
caml
example
toplevel
let
integer
part
num
num
denom
denom
num
denom
end
caml
example
Unneeded
fields
can
be
omitted
begin
caml
example
toplevel
let
get
denom
denom
denom
denom
end
caml
example
Optionally
missing
fields
can
be
made
explicit
by
ending
the
list
of
fields
with
a
trailing
wildcard
begin
caml
example
toplevel
let
get
num
num
num
num
end
caml
example
When
both
sides
of
the
sign
are
the
same
it
is
possible
to
avoid
repeating
the
field
name
by
eliding
the
field
part
begin
caml
example
toplevel
let
integer
part
num
denom
num
denom
end
caml
example
This
short
notation
for
fields
also
works
when
constructing
records
begin
caml
example
toplevel
let
ratio
num
denom
num
denom
end
caml
example
At
last
it
is
possible
to
update
few
fields
of
a
record
at
once
begin
caml
example
toplevel
let
integer
product
integer
ratio
ratio
with
num
integer
ratio
num
end
caml
example
With
this
functional
update
notation
the
record
on
the
left
hand
side
of
with
is
copied
except
for
the
fields
on
the
right
hand
side
which
are
updated
The
declaration
of
a
variant
type
lists
all
possible
forms
for
values
of
that
type
Each
case
is
identified
by
a
name
called
a
constructor
which
serves
both
for
constructing
values
of
the
variant
type
and
inspecting
them
by
pattern
matching
Constructor
names
are
capitalized
to
distinguish
them
from
variable
names
which
must
start
with
a
lowercase
letter
For
instance
here
is
a
variant
type
for
doing
mixed
arithmetic
integers
and
floats
begin
caml
example
toplevel
type
number
Int
of
int
Float
of
float
Error
end
caml
example
This
declaration
expresses
that
a
value
of
type
number
is
either
an
integer
a
floating
point
number
or
the
constant
Error
representing
the
result
of
an
invalid
operation
e
g
a
division
by
zero
Enumerated
types
are
a
special
case
of
variant
types
where
all
alternatives
are
constants
begin
caml
example
toplevel
type
sign
Positive
Negative
let
sign
int
n
if
n
0
then
Positive
else
Negative
end
caml
example
To
define
arithmetic
operations
for
the
number
type
we
use
pattern
matching
on
the
two
numbers
involved
begin
caml
example
toplevel
let
add
num
n1
n2
match
n1
n2
with
Int
i1
Int
i2
Check
for
overflow
of
integer
addition
if
sign
int
i1
sign
int
i2
sign
int
i1
i2
sign
int
i1
then
Float
float
i1
float
i2
else
Int
i1
i2
Int
i1
Float
f2
Float
float
i1
f2
Float
f1
Int
i2
Float
f1
float
i2
Float
f1
Float
f2
Float
f1
f2
Error
Error
Error
Error
add
num
Int
123
Float
3
14159
end
caml
example
Another
interesting
example
of
variant
type
is
the
built
in
a
option
type
which
represents
either
a
value
of
type
a
or
an
absence
of
value
begin
caml
example
toplevel
type
a
option
Some
of
a
None
end
caml
example
This
type
is
particularly
useful
when
defining
function
that
can
fail
in
common
situations
for
instance
begin
caml
example
toplevel
let
safe
square
root
x
if
x
0
then
Some
sqrt
x
else
None
end
caml
example
The
most
common
usage
of
variant
types
is
to
describe
recursive
data
structures
Consider
for
example
the
type
of
binary
trees
begin
caml
example
toplevel
type
a
btree
Empty
Node
of
a
a
btree
a
btree
end
caml
example
This
definition
reads
as
follows
a
binary
tree
containing
values
of
type
a
an
arbitrary
type
is
either
empty
or
is
a
node
containing
one
value
of
type
a
and
two
subtrees
also
containing
values
of
type
a
that
is
two
a
btree
Operations
on
binary
trees
are
naturally
expressed
as
recursive
functions
following
the
same
structure
as
the
type
definition
itself
For
instance
here
are
functions
performing
lookup
and
insertion
in
ordered
binary
trees
elements
increase
from
left
to
right
begin
caml
example
toplevel
let
rec
member
x
btree
match
btree
with
Empty
false
Node
y
left
right
if
x
y
then
true
else
if
x
y
then
member
x
left
else
member
x
right
let
rec
insert
x
btree
match
btree
with
Empty
Node
x
Empty
Empty
Node
y
left
right
if
x
y
then
Node
y
insert
x
left
right
else
Node
y
left
insert
x
right
end
caml
example
subsection
ss
record
and
variant
disambiguation
Record
and
variant
disambiguation
This
subsection
can
be
skipped
on
the
first
reading
Astute
readers
may
have
wondered
what
happens
when
two
or
more
record
fields
or
constructors
share
the
same
name
begin
caml
example
toplevel
type
first
record
x
int
y
int
z
int
type
middle
record
x
int
z
int
type
last
record
x
int
type
first
variant
A
B
C
type
last
variant
A
end
caml
example
The
answer
is
that
when
confronted
with
multiple
options
OCaml
tries
to
use
locally
available
information
to
disambiguate
between
the
various
fields
and
constructors
First
if
the
type
of
the
record
or
variant
is
known
OCaml
can
pick
unambiguously
the
corresponding
field
or
constructor
For
instance
begin
caml
example
toplevel
let
look
at
x
then
z
r
first
record
let
x
r
x
in
x
r
z
let
permute
x
first
variant
match
x
with
A
B
first
variant
B
A
C
C
type
wrapped
First
of
first
record
let
f
First
r
r
r
x
end
caml
example
In
the
first
example
r
first
record
is
an
explicit
annotation
telling
OCaml
that
the
type
of
r
is
first
record
With
this
annotation
Ocaml
knows
that
r
x
refers
to
the
x
field
of
the
first
record
type
Similarly
the
type
annotation
in
the
second
example
makes
it
clear
to
OCaml
that
the
constructors
A
B
and
C
come
from
the
first
variant
type
Contrarily
in
the
last
example
OCaml
has
inferred
by
itself
that
the
type
of
r
can
only
be
first
record
and
there
are
no
needs
for
explicit
type
annotations
Those
explicit
type
annotations
can
in
fact
be
used
anywhere
Most
of
the
time
they
are
unnecessary
but
they
are
useful
to
guide
disambiguation
to
debug
unexpected
type
errors
or
combined
with
some
of
the
more
advanced
features
of
OCaml
described
in
later
chapters
Secondly
for
records
OCaml
can
also
deduce
the
right
record
type
by
looking
at
the
whole
set
of
fields
used
in
a
expression
or
pattern
begin
caml
example
toplevel
let
project
and
rotate
x
y
x
y
y
x
z
0
end
caml
example
Since
the
fields
x
and
y
can
only
appear
simultaneously
in
the
first
record
type
OCaml
infers
that
the
type
of
project
and
rotate
is
first
record
first
record
In
last
resort
if
there
is
not
enough
information
to
disambiguate
between
different
fields
or
constructors
Ocaml
picks
the
last
defined
type
amongst
all
locally
valid
choices
begin
caml
example
toplevel
let
look
at
xz
x
z
x
end
caml
example
Here
OCaml
has
inferred
that
the
possible
choices
for
the
type
of
x
z
are
first
record
and
middle
record
since
the
type
last
record
has
no
field
z
Ocaml
then
picks
the
type
middle
record
as
the
last
defined
type
between
the
two
possibilities
Beware
that
this
last
resort
disambiguation
is
local
once
Ocaml
has
chosen
a
disambiguation
it
sticks
to
this
choice
even
if
it
leads
to
an
ulterior
type
error
begin
caml
example
toplevel
error
let
look
at
x
then
y
r
let
x
r
x
in
Ocaml
deduces
r
last
record
x
r
y
let
is
a
or
b
x
match
x
with
A
true
OCaml
infers
x
last
variant
B
true
end
caml
example
Moreover
being
the
last
defined
type
is
a
quite
unstable
position
that
may
change
surreptitiously
after
adding
or
moving
around
a
type
definition
or
after
opening
a
module
see
chapter
ref
c
moduleexamples
Consequently
adding
explicit
type
annotations
to
guide
disambiguation
is
more
robust
than
relying
on
the
last
defined
type
disambiguation
section
s
imperative
features
Imperative
features
Though
all
examples
so
far
were
written
in
purely
applicative
style
OCaml
is
also
equipped
with
full
imperative
features
This
includes
the
usual
while
and
for
loops
as
well
as
mutable
data
structures
such
as
arrays
Arrays
are
either
created
by
listing
semicolon
separated
element
values
between
and
brackets
or
allocated
and
initialized
with
the
Array
make
function
then
filled
up
later
by
assignments
For
instance
the
function
below
sums
two
vectors
represented
as
float
arrays
componentwise
begin
caml
example
toplevel
let
add
vect
v1
v2
let
len
min
Array
length
v1
Array
length
v2
in
let
res
Array
make
len
0
0
in
for
i
0
to
len
1
do
res
i
v1
i
v2
i
done
res
add
vect
1
0
2
0
3
0
4
0
end
caml
example
Record
fields
can
also
be
modified
by
assignment
provided
they
are
declared
mutable
in
the
definition
of
the
record
type
begin
caml
example
toplevel
type
mutable
point
mutable
x
float
mutable
y
float
let
translate
p
dx
dy
p
x
p
x
dx
p
y
p
y
dy
let
mypoint
x
0
0
y
0
0
translate
mypoint
1
0
2
0
mypoint
end
caml
example
OCaml
has
no
built
in
notion
of
variable
identifiers
whose
current
value
can
be
changed
by
assignment
The
let
binding
is
not
an
assignment
it
introduces
a
new
identifier
with
a
new
scope
However
the
standard
library
provides
references
which
are
mutable
indirection
cells
with
operators
to
fetch
the
current
contents
of
the
reference
and
to
assign
the
contents
Variables
can
then
be
emulated
by
let
binding
a
reference
For
instance
here
is
an
in
place
insertion
sort
over
arrays
begin
caml
example
toplevel
let
insertion
sort
a
for
i
1
to
Array
length
a
1
do
let
val
i
a
i
in
let
j
ref
i
in
while
j
0
val
i
a
j
1
do
a
j
a
j
1
j
j
1
done
a
j
val
i
done
end
caml
example
References
are
also
useful
to
write
functions
that
maintain
a
current
state
between
two
calls
to
the
function
For
instance
the
following
pseudo
random
number
generator
keeps
the
last
returned
number
in
a
reference
begin
caml
example
toplevel
let
current
rand
ref
0
let
random
current
rand
current
rand
25713
1345
current
rand
end
caml
example
Again
there
is
nothing
magical
with
references
they
are
implemented
as
a
single
field
mutable
record
as
follows
begin
caml
example
toplevel
type
a
ref
mutable
contents
a
let
r
r
contents
let
r
newval
r
contents
newval
end
caml
example
In
some
special
cases
you
may
need
to
store
a
polymorphic
function
in
a
data
structure
keeping
its
polymorphism
Doing
this
requires
user
provided
type
annotations
since
polymorphism
is
only
introduced
automatically
for
global
definitions
However
you
can
explicitly
give
polymorphic
types
to
record
fields
begin
caml
example
toplevel
type
idref
mutable
id
a
a
a
let
r
id
fun
x
x
let
g
s
s
id
1
s
id
true
r
id
fun
x
print
string
called
id
n
x
g
r
end
caml
example
section
s
exceptions
Exceptions
OCaml
provides
exceptions
for
signalling
and
handling
exceptional
conditions
Exceptions
can
also
be
used
as
a
general
purpose
non
local
control
structure
although
this
should
not
be
overused
since
it
can
make
the
code
harder
to
understand
Exceptions
are
declared
with
the
exception
construct
and
signalled
with
the
raise
operator
For
instance
the
function
below
for
taking
the
head
of
a
list
uses
an
exception
to
signal
the
case
where
an
empty
list
is
given
begin
caml
example
toplevel
exception
Empty
list
let
head
l
match
l
with
raise
Empty
list
hd
tl
hd
head
1
2
head
end
caml
example
Exceptions
are
used
throughout
the
standard
library
to
signal
cases
where
the
library
functions
cannot
complete
normally
For
instance
the
List
assoc
function
which
returns
the
data
associated
with
a
given
key
in
a
list
of
key
data
pairs
raises
the
predefined
exception
Not
found
when
the
key
does
not
appear
in
the
list
begin
caml
example
toplevel
List
assoc
1
0
zero
1
one
List
assoc
2
0
zero
1
one
end
caml
example
Exceptions
can
be
trapped
with
the
try
ldots
with
construct
begin
caml
example
toplevel
let
name
of
binary
digit
digit
try
List
assoc
digit
0
zero
1
one
with
Not
found
not
a
binary
digit
name
of
binary
digit
0
name
of
binary
digit
1
end
caml
example
The
with
part
does
pattern
matching
on
the
exception
value
with
the
same
syntax
and
behavior
as
match
Thus
several
exceptions
can
be
caught
by
one
try
ldots
with
construct
begin
caml
example
toplevel
let
rec
first
named
value
values
names
try
List
assoc
head
values
names
with
Empty
list
no
named
value
Not
found
first
named
value
List
tl
values
names
first
named
value
0
10
1
one
10
ten
end
caml
example
Also
finalization
can
be
performed
by
trapping
all
exceptions
performing
the
finalization
then
re
raising
the
exception
begin
caml
example
toplevel
let
temporarily
set
reference
ref
newval
funct
let
oldval
ref
in
try
ref
newval
let
res
funct
in
ref
oldval
res
with
x
ref
oldval
raise
x
end
caml
example
An
alternative
to
try
ldots
with
is
to
catch
the
exception
while
pattern
matching
begin
caml
example
toplevel
let
assoc
may
map
f
x
l
match
List
assoc
x
l
with
exception
Not
found
None
y
f
y
end
caml
example
Note
that
this
construction
is
only
useful
if
the
exception
is
raised
between
match
ldots
with
Exception
patterns
can
be
combined
with
ordinary
patterns
at
the
toplevel
begin
caml
example
toplevel
let
flat
assoc
opt
x
l
match
List
assoc
x
l
with
None
exception
Not
found
None
Some
as
v
v
end
caml
example
but
they
cannot
be
nested
inside
other
patterns
For
instance
the
pattern
Some
exception
A
is
invalid
When
exceptions
are
used
as
a
control
structure
it
can
be
useful
to
make
them
as
local
as
possible
by
using
a
locally
defined
exception
For
instance
with
begin
caml
eval
let
ref
x
ref
contents
x
end
caml
eval
begin
caml
example
toplevel
let
fixpoint
f
x
let
exception
Done
in
let
x
ref
x
in
try
while
true
do
let
y
f
x
in
if
x
y
then
raise
Done
else
x
y
done
with
Done
x
end
caml
example
the
function
f
cannot
raise
a
Done
exception
which
removes
an
entire
class
of
misbehaving
functions
section
s
lazy
expr
Lazy
expressions
OCaml
allows
us
to
defer
some
computation
until
later
when
we
need
the
result
of
that
computation
We
use
lazy
expr
to
delay
the
evaluation
of
some
expression
expr
For
example
we
can
defer
the
computation
of
1
1
until
we
need
the
result
of
that
expression
2
Let
us
see
how
we
initialize
a
lazy
expression
begin
caml
example
toplevel
let
lazy
two
lazy
print
endline
lazy
two
evaluation
1
1
end
caml
example
We
added
print
endline
lazy
two
evaluation
to
see
when
the
lazy
expression
is
being
evaluated
The
value
of
lazy
two
is
displayed
as
lazy
which
means
the
expression
has
not
been
evaluated
yet
and
its
final
value
is
unknown
Note
that
lazy
two
has
type
int
lazy
t
However
the
type
a
lazy
t
is
an
internal
type
name
so
the
type
a
Lazy
t
should
be
preferred
when
possible
When
we
finally
need
the
result
of
a
lazy
expression
we
can
call
Lazy
force
on
that
expression
to
force
its
evaluation
The
function
force
comes
from
standard
library
module
stdmoduleref
Lazy
begin
caml
example
toplevel
Lazy
force
lazy
two
end
caml
example
Notice
that
our
function
call
above
prints
lazy
two
evaluation
and
then
returns
the
plain
value
of
the
computation
Now
if
we
look
at
the
value
of
lazy
two
we
see
that
it
is
not
displayed
as
lazy
anymore
but
as
lazy
2
begin
caml
example
toplevel
lazy
two
end
caml
example
This
is
because
Lazy
force
memoizes
the
result
of
the
forced
expression
In
other
words
every
subsequent
call
of
Lazy
force
on
that
expression
returns
the
result
of
the
first
computation
without
recomputing
the
lazy
expression
Let
us
force
lazy
two
once
again
begin
caml
example
toplevel
Lazy
force
lazy
two
end
caml
example
The
expression
is
not
evaluated
this
time
notice
that
lazy
two
evaluation
is
not
printed
The
result
of
the
initial
computation
is
simply
returned
Lazy
patterns
provide
another
way
to
force
a
lazy
expression
begin
caml
example
toplevel
let
lazy
l
lazy
1
2
3
4
let
lazy
l
lazy
l
end
caml
example
We
can
also
use
lazy
patterns
in
pattern
matching
begin
caml
example
toplevel
let
maybe
eval
lazy
guard
lazy
expr
match
lazy
guard
lazy
expr
with
lazy
false
matches
if
Lazy
force
lazy
guard
false
lazy
expr
not
forced
lazy
true
lazy
matches
if
Lazy
force
lazy
guard
true
lazy
expr
forced
end
caml
example
The
lazy
expression
lazy
expr
is
forced
only
if
the
lazy
guard
value
yields
true
once
computed
Indeed
a
simple
wildcard
pattern
not
lazy
never
forces
the
lazy
expression
s
evaluation
However
a
pattern
with
keyword
lazy
even
if
it
is
wildcard
always
forces
the
evaluation
of
the
deferred
computation
section
s
symb
expr
Symbolic
processing
of
expressions
We
finish
this
introduction
with
a
more
complete
example
representative
of
the
use
of
OCaml
for
symbolic
processing
formal
manipulations
of
arithmetic
expressions
containing
variables
The
following
variant
type
describes
the
expressions
we
shall
manipulate
begin
caml
example
toplevel
type
expression
Const
of
float
Var
of
string
Sum
of
expression
expression
e1
e2
Diff
of
expression
expression
e1
e2
Prod
of
expression
expression
e1
e2
Quot
of
expression
expression
e1
e2
end
caml
example
We
first
define
a
function
to
evaluate
an
expression
given
an
environment
that
maps
variable
names
to
their
values
For
simplicity
the
environment
is
represented
as
an
association
list
begin
caml
example
toplevel
exception
Unbound
variable
of
string
let
rec
eval
env
exp
match
exp
with
Const
c
c
Var
v
try
List
assoc
v
env
with
Not
found
raise
Unbound
variable
v
Sum
f
g
eval
env
f
eval
env
g
Diff
f
g
eval
env
f
eval
env
g
Prod
f
g
eval
env
f
eval
env
g
Quot
f
g
eval
env
f
eval
env
g
eval
x
1
0
y
3
14
Prod
Sum
Var
x
Const
2
0
Var
y
end
caml
example
Now
for
a
real
symbolic
processing
we
define
the
derivative
of
an
expression
with
respect
to
a
variable
dv
begin
caml
example
toplevel
let
rec
deriv
exp
dv
match
exp
with
Const
c
Const
0
0
Var
v
if
v
dv
then
Const
1
0
else
Const
0
0
Sum
f
g
Sum
deriv
f
dv
deriv
g
dv
Diff
f
g
Diff
deriv
f
dv
deriv
g
dv
Prod
f
g
Sum
Prod
f
deriv
g
dv
Prod
deriv
f
dv
g
Quot
f
g
Quot
Diff
Prod
deriv
f
dv
g
Prod
f
deriv
g
dv
Prod
g
g
deriv
Quot
Const
1
0
Var
x
x
end
caml
example
section
s
pretty
printing
Pretty
printing
As
shown
in
the
examples
above
the
internal
representation
also
called
em
abstract
syntax
of
expressions
quickly
becomes
hard
to
read
and
write
as
the
expressions
get
larger
We
need
a
printer
and
a
parser
to
go
back
and
forth
between
the
abstract
syntax
and
the
em
concrete
syntax
which
in
the
case
of
expressions
is
the
familiar
algebraic
notation
e
g
2
x
1
For
the
printing
function
we
take
into
account
the
usual
precedence
rules
i
e
binds
tighter
than
to
avoid
printing
unnecessary
parentheses
To
this
end
we
maintain
the
current
operator
precedence
and
print
parentheses
around
an
operator
only
if
its
precedence
is
less
than
the
current
precedence
begin
caml
example
toplevel
let
print
expr
exp
Local
function
definitions
let
open
paren
prec
op
prec
if
prec
op
prec
then
print
string
in
let
close
paren
prec
op
prec
if
prec
op
prec
then
print
string
in
let
rec
print
prec
exp
prec
is
the
current
precedence
match
exp
with
Const
c
print
float
c
Var
v
print
string
v
Sum
f
g
open
paren
prec
0
print
0
f
print
string
print
0
g
close
paren
prec
0
Diff
f
g
open
paren
prec
0
print
0
f
print
string
print
1
g
close
paren
prec
0
Prod
f
g
open
paren
prec
2
print
2
f
print
string
print
2
g
close
paren
prec
2
Quot
f
g
open
paren
prec
2
print
2
f
print
string
print
3
g
close
paren
prec
2
in
print
0
exp
let
e
Sum
Prod
Const
2
0
Var
x
Const
1
0
print
expr
e
print
newline
print
expr
deriv
e
x
print
newline
end
caml
example
section
s
printf
Printf
formats
There
is
a
printf
function
in
the
stdmoduleref
Printf
module
see
chapter
ref
c
moduleexamples
that
allows
you
to
make
formatted
output
more
concisely
It
follows
the
behavior
of
the
printf
function
from
the
C
standard
library
The
printf
function
takes
a
format
string
that
describes
the
desired
output
as
a
text
interspersed
with
specifiers
for
instance
d
f
Next
the
specifiers
are
substituted
by
the
following
arguments
in
their
order
of
apparition
in
the
format
string
begin
caml
example
toplevel
Printf
printf
i
i
is
an
integer
value
F
F
is
a
float
S
n
3
2
4
5
1
this
is
a
string
end
caml
example
The
OCaml
type
system
checks
that
the
type
of
the
arguments
and
the
specifiers
are
compatible
If
you
pass
it
an
argument
of
a
type
that
does
not
correspond
to
the
format
specifier
the
compiler
will
display
an
error
message
begin
caml
example
toplevel
error
Printf
printf
Float
value
F
42
end
caml
example
The
fprintf
function
is
like
printf
except
that
it
takes
an
output
channel
as
the
first
argument
The
a
specifier
can
be
useful
to
define
custom
printers
for
custom
types
For
instance
we
can
create
a
printing
template
that
converts
an
integer
argument
to
signed
decimal
begin
caml
example
toplevel
let
pp
int
ppf
n
Printf
fprintf
ppf
d
n
Printf
printf
Outputting
an
integer
using
a
custom
printer
a
pp
int
42
end
caml
example
The
advantage
of
those
printers
based
on
the
a
specifier
is
that
they
can
be
composed
together
to
create
more
complex
printers
step
by
step
We
can
define
a
combinator
that
can
turn
a
printer
for
a
type
into
a
printer
for
a
optional
begin
caml
example
toplevel
let
pp
option
printer
ppf
function
None
Printf
fprintf
ppf
None
Some
v
Printf
fprintf
ppf
Some
a
printer
v
Printf
fprintf
stdout
The
current
setting
is
a
nThere
is
only
a
n
pp
option
pp
int
Some
3
pp
option
pp
int
None
end
caml
example
If
the
value
of
its
argument
its
None
the
printer
returned
by
pp
option
printer
prints
None
otherwise
it
uses
the
provided
printer
to
print
Some
Here
is
how
to
rewrite
the
pretty
printer
using
fprintf
begin
caml
example
toplevel
let
pp
expr
ppf
expr
let
open
paren
prec
op
prec
output
if
prec
op
prec
then
Printf
fprintf
output
s
in
let
close
paren
prec
op
prec
output
if
prec
op
prec
then
Printf
fprintf
output
s
in
let
rec
print
prec
ppf
expr
match
expr
with
Const
c
Printf
fprintf
ppf
F
c
Var
v
Printf
fprintf
ppf
s
v
Sum
f
g
open
paren
prec
0
ppf
Printf
fprintf
ppf
a
a
print
0
f
print
0
g
close
paren
prec
0
ppf
Diff
f
g
open
paren
prec
0
ppf
Printf
fprintf
ppf
a
a
print
0
f
print
1
g
close
paren
prec
0
ppf
Prod
f
g
open
paren
prec
2
ppf
Printf
fprintf
ppf
a
a
print
2
f
print
2
g
close
paren
prec
2
ppf
Quot
f
g
open
paren
prec
2
ppf
Printf
fprintf
ppf
a
a
print
2
f
print
3
g
close
paren
prec
2
ppf
in
print
0
ppf
expr
pp
expr
stdout
e
print
newline
pp
expr
stdout
deriv
e
x
print
newline
end
caml
example
Due
to
the
way
that
format
strings
are
built
storing
a
format
string
requires
an
explicit
type
annotation
begin
caml
example
toplevel
let
str
format
i
is
an
integer
value
F
is
a
float
S
n
end
caml
example
begin
caml
example
toplevel
Printf
printf
str
3
4
5
string
value
end
caml
example
section
s
standalone
programs
Standalone
OCaml
programs
All
examples
given
so
far
were
executed
under
the
interactive
system
OCaml
code
can
also
be
compiled
separately
and
executed
non
interactively
using
the
batch
compilers
ocamlc
and
ocamlopt
The
source
code
must
be
put
in
a
file
with
extension
ml
It
consists
of
a
sequence
of
phrases
which
will
be
evaluated
at
runtime
in
their
order
of
appearance
in
the
source
file
Unlike
in
interactive
mode
types
and
values
are
not
printed
automatically
the
program
must
call
printing
functions
explicitly
to
produce
some
output
The
used
in
the
interactive
examples
is
not
required
in
source
files
created
for
use
with
OCaml
compilers
but
can
be
helpful
to
mark
the
end
of
a
top
level
expression
unambiguously
even
when
there
are
syntax
errors
Here
is
a
sample
standalone
program
to
print
the
greatest
common
divisor
gcd
of
two
numbers
begin
verbatim
File
gcd
ml
let
rec
gcd
a
b
if
b
0
then
a
else
gcd
b
a
mod
b
let
main
let
a
int
of
string
Sys
argv
1
in
let
b
int
of
string
Sys
argv
2
in
Printf
printf
d
n
gcd
a
b
exit
0
main
end
verbatim
Sys
argv
is
an
array
of
strings
containing
the
command
line
parameters
Sys
argv
1
is
thus
the
first
command
line
parameter
The
program
above
is
compiled
and
executed
with
the
following
shell
commands
begin
verbatim
ocamlc
o
gcd
gcd
ml
gcd
6
9
3
gcd
7
11
1
end
verbatim
More
complex
standalone
OCaml
programs
are
typically
composed
of
multiple
source
files
and
can
link
with
precompiled
libraries
Chapters
ref
c
camlc
and
ref
c
nativecomp
explain
how
to
use
the
batch
compilers
ocamlc
and
ocamlopt
Recompilation
of
multi
file
OCaml
projects
can
be
automated
using
third
party
build
systems
such
as
href
https
github
com
ocaml
dune
dune
chapter
Polymorphic
variants
label
c
poly
variant
HEVEA
cutname
polyvariant
html
it
Chapter
written
by
Jacques
Garrigue
Variants
as
presented
in
section
ref
s
tut
recvariants
are
a
powerful
tool
to
build
data
structures
and
algorithms
However
they
sometimes
lack
flexibility
when
used
in
modular
programming
This
is
due
to
the
fact
that
every
constructor
is
assigned
to
a
unique
type
when
defined
and
used
Even
if
the
same
name
appears
in
the
definition
of
multiple
types
the
constructor
itself
belongs
to
only
one
type
Therefore
one
cannot
decide
that
a
given
constructor
belongs
to
multiple
types
or
consider
a
value
of
some
type
to
belong
to
some
other
type
with
more
constructors
With
polymorphic
variants
this
original
assumption
is
removed
That
is
a
variant
tag
does
not
belong
to
any
type
in
particular
the
type
system
will
just
check
that
it
is
an
admissible
value
according
to
its
use
You
need
not
define
a
type
before
using
a
variant
tag
A
variant
type
will
be
inferred
independently
for
each
of
its
uses
section
s
polyvariant
basic
use
Basic
use
In
programs
polymorphic
variants
work
like
usual
ones
You
just
have
to
prefix
their
names
with
a
backquote
character
begin
caml
example
toplevel
On
Off
Number
1
let
f
function
On
1
Off
0
Number
n
n
List
map
f
On
Off
end
caml
example
Off
On
list
means
that
to
match
this
list
you
should
at
least
be
able
to
match
Off
and
On
without
argument
On
Off
Number
of
int
means
that
f
may
be
applied
to
Off
On
both
without
argument
or
Number
n
where
n
is
an
integer
The
and
inside
the
variant
types
show
that
they
may
still
be
refined
either
by
defining
more
tags
or
by
allowing
less
As
such
they
contain
an
implicit
type
variable
Because
each
of
the
variant
types
appears
only
once
in
the
whole
type
their
implicit
type
variables
are
not
shown
The
above
variant
types
were
polymorphic
allowing
further
refinement
When
writing
type
annotations
one
will
most
often
describe
fixed
variant
types
that
is
types
that
cannot
be
refined
This
is
also
the
case
for
type
abbreviations
Such
types
do
not
contain
or
but
just
an
enumeration
of
the
tags
and
their
associated
types
just
like
in
a
normal
datatype
definition
begin
caml
example
toplevel
type
a
vlist
Nil
Cons
of
a
a
vlist
let
rec
map
f
a
vlist
b
vlist
function
Nil
Nil
Cons
a
l
Cons
f
a
map
f
l
end
caml
example
section
s
polyvariant
advanced
Advanced
use
Type
checking
polymorphic
variants
is
a
subtle
thing
and
some
expressions
may
result
in
more
complex
type
information
begin
caml
example
toplevel
let
f
function
A
C
B
D
x
x
f
E
end
caml
example
Here
we
are
seeing
two
phenomena
First
since
this
matching
is
open
the
last
case
catches
any
tag
we
obtain
the
type
A
B
rather
than
A
B
in
a
closed
matching
Then
since
x
is
returned
as
is
input
and
return
types
are
identical
The
notation
as
a
denotes
such
type
sharing
If
we
apply
f
to
yet
another
tag
E
it
gets
added
to
the
list
begin
caml
example
toplevel
let
f1
function
A
x
x
1
B
true
C
false
let
f2
function
A
x
x
a
B
true
let
f
x
f1
x
f2
x
end
caml
example
Here
f1
and
f2
both
accept
the
variant
tags
A
and
B
but
the
argument
of
A
is
int
for
f1
and
string
for
f2
In
f
s
type
C
only
accepted
by
f1
disappears
but
both
argument
types
appear
for
A
as
int
string
This
means
that
if
we
pass
the
variant
tag
A
to
f
its
argument
should
be
em
both
int
and
string
Since
there
is
no
such
value
f
cannot
be
applied
to
A
and
B
is
the
only
accepted
input
Even
if
a
value
has
a
fixed
variant
type
one
can
still
give
it
a
larger
type
through
coercions
Coercions
are
normally
written
with
both
the
source
type
and
the
destination
type
but
in
simple
cases
the
source
type
may
be
omitted
begin
caml
example
toplevel
type
a
wlist
Nil
Cons
of
a
a
wlist
Snoc
of
a
wlist
a
let
wlist
of
vlist
l
l
a
vlist
a
wlist
let
open
vlist
l
l
a
vlist
a
vlist
fun
x
x
A
B
C
end
caml
example
You
may
also
selectively
coerce
values
through
pattern
matching
begin
caml
example
toplevel
let
split
cases
function
Nil
Cons
as
x
A
x
Snoc
as
x
B
x
end
caml
example
When
an
or
pattern
composed
of
variant
tags
is
wrapped
inside
an
alias
pattern
the
alias
is
given
a
type
containing
only
the
tags
enumerated
in
the
or
pattern
This
allows
for
many
useful
idioms
like
incremental
definition
of
functions
begin
caml
example
toplevel
let
num
x
Num
x
let
eval1
eval
Num
x
x
let
rec
eval
x
eval1
eval
x
let
plus
x
y
Plus
x
y
let
eval2
eval
function
Plus
x
y
eval
x
eval
y
Num
as
x
eval1
eval
x
let
rec
eval
x
eval2
eval
x
end
caml
example
To
make
this
even
more
comfortable
you
may
use
type
definitions
as
abbreviations
for
or
patterns
That
is
if
you
have
defined
type
myvariant
Tag1
of
int
Tag2
of
bool
then
the
pattern
myvariant
is
equivalent
to
writing
Tag1
int
Tag2
bool
begin
caml
eval
type
myvariant
Tag1
of
int
Tag2
of
bool
end
caml
eval
Such
abbreviations
may
be
used
alone
begin
caml
example
toplevel
let
f
function
myvariant
myvariant
Tag3
Tag3
end
caml
example
or
combined
with
with
aliases
begin
caml
example
toplevel
let
g1
function
Tag1
Tag1
Tag2
Tag2
let
g
function
myvariant
as
x
g1
x
Tag3
Tag3
end
caml
example
section
s
polyvariant
weaknesses
Weaknesses
of
polymorphic
variants
After
seeing
the
power
of
polymorphic
variants
one
may
wonder
why
they
were
added
to
core
language
variants
rather
than
replacing
them
The
answer
is
twofold
The
first
aspect
is
that
while
being
pretty
efficient
the
lack
of
static
type
information
allows
for
less
optimizations
and
makes
polymorphic
variants
slightly
heavier
than
core
language
ones
However
noticeable
differences
would
only
appear
on
huge
data
structures
More
important
is
the
fact
that
polymorphic
variants
while
being
type
safe
result
in
a
weaker
type
discipline
That
is
core
language
variants
do
actually
much
more
than
ensuring
type
safety
they
also
check
that
you
use
only
declared
constructors
that
all
constructors
present
in
a
data
structure
are
compatible
and
they
enforce
typing
constraints
to
their
parameters
For
this
reason
you
must
be
more
careful
about
making
types
explicit
when
you
use
polymorphic
variants
When
you
write
a
library
this
is
easy
since
you
can
describe
exact
types
in
interfaces
but
for
simple
programs
you
are
probably
better
off
with
core
language
variants
Beware
also
that
some
idioms
make
trivial
errors
very
hard
to
find
For
instance
the
following
code
is
probably
wrong
but
the
compiler
has
no
way
to
see
it
begin
caml
example
toplevel
type
abc
A
B
C
let
f
function
As
A
abc
other
let
f
abc
string
f
end
caml
example
You
can
avoid
such
risks
by
annotating
the
definition
itself
begin
caml
example
toplevel
error
let
f
abc
string
function
As
A
abc
other
end
caml
example
chapter
Parallel
programming
HEVEA
cutname
parallelism
html
label
c
parallelism
In
this
chapter
we
look
at
the
parallel
programming
facilities
in
OCaml
The
OCaml
standard
library
exposes
low
level
primitives
for
parallel
programming
We
recommend
that
users
make
use
of
higher
level
parallel
programming
libraries
such
as
href
https
github
com
ocaml
multicore
domainslib
domainslib
This
tutorial
will
first
cover
high
level
parallel
programming
using
domainslib
followed
by
low
level
primitives
exposed
by
the
compiler
OCaml
distinguishes
between
concurrency
and
parallelism
and
provides
distinct
mechanisms
for
expressing
them
Concurrency
is
interleaved
execution
of
tasks
section
ref
s
effects
concurrency
whereas
parallelism
is
simultaneous
execution
of
tasks
In
particular
parallel
tasks
overlap
in
time
but
concurrent
tasks
may
or
may
not
overlap
in
time
Tasks
may
execute
concurrently
by
yielding
control
to
each
other
While
concurrency
is
a
program
structuring
mechanism
parallelism
is
a
mechanism
to
make
your
programs
run
faster
If
you
are
interested
in
the
concurrent
programming
mechanisms
in
OCaml
please
refer
to
section
ref
s
effect
handlers
on
effect
handlers
and
chapter
ref
c
threads
on
the
threads
library
section
s
par
domains
Domains
Domains
are
the
units
of
parallelism
in
OCaml
The
module
stdmoduleref
Domain
provides
the
primitives
to
create
and
manage
domains
New
domains
can
be
spawned
using
the
spawn
function
begin
caml
example
verbatim
Domain
spawn
fun
print
endline
I
ran
in
parallel
end
caml
example
The
spawn
function
executes
the
given
computation
in
parallel
with
the
calling
domain
Domains
are
heavy
weight
entities
Each
domain
maps
1
1
to
an
operating
system
thread
Each
domain
also
has
its
own
runtime
state
which
includes
domain
local
structures
for
allocating
memory
Hence
they
are
relatively
expensive
to
create
and
tear
down
emph
textbf
It
is
recommended
that
programs
do
not
spawn
more
domains
than
the
number
of
available
cores
In
this
tutorial
we
will
be
implementing
running
and
measuring
the
performance
of
parallel
programs
The
results
observed
are
dependent
on
the
number
of
cores
available
on
the
target
machine
This
tutorial
was
written
on
a
2
3
GHz
Quad
Core
Intel
Core
i7
MacBook
Pro
with
4
cores
and
8
hardware
threads
It
is
reasonable
to
expect
roughly
4x
performance
on
4
domains
for
parallel
programs
with
little
coordination
between
the
domains
and
when
the
machine
is
not
under
load
Beyond
4
domains
the
speedup
is
likely
to
be
less
than
linear
We
will
also
use
the
command
line
benchmarking
tool
href
https
github
com
sharkdp
hyperfine
hyperfine
to
benchmark
our
programs
subsection
s
par
join
Joining
domains
We
will
write
a
program
to
compute
the
n
th
Fibonacci
number
using
recursion
as
a
running
example
The
sequential
program
for
computing
the
n
th
Fibonacci
number
is
given
below
begin
caml
example
verbatim
fib
ml
let
n
try
int
of
string
Sys
argv
1
with
1
let
rec
fib
n
if
n
2
then
n
else
fib
n
1
fib
n
2
let
main
let
r
fib
n
in
Printf
printf
fib
d
d
n
n
r
let
main
end
caml
example
The
program
can
be
compiled
and
benchmarked
as
follows
begin
verbatim
ocamlopt
o
fib
exe
fib
ml
fib
exe
42
fib
42
267914296
hyperfine
fib
exe
42
Benchmarking
Benchmark
1
fib
exe
42
Time
mean
?
sd
1
193
s
?
0
006
s
User
1
186
s
System
0
003
s
Range
min

max
1
181
s

1
202
s
10
runs
end
verbatim
We
see
that
it
takes
around
1
2
seconds
to
compute
the
42nd
Fibonacci
number
Spawned
domains
can
be
joined
using
the
join
function
to
get
their
results
The
join
function
waits
for
target
domain
to
terminate
The
following
program
computes
the
n
th
Fibonacci
number
twice
in
parallel
begin
caml
example
verbatim
fib
twice
ml
let
n
int
of
string
Sys
argv
1
let
rec
fib
n
if
n
2
then
n
else
fib
n
1
fib
n
2
let
main
let
d1
Domain
spawn
fun
fib
n
in
let
d2
Domain
spawn
fun
fib
n
in
let
r1
Domain
join
d1
in
Printf
printf
fib
d
d
n
n
r1
let
r2
Domain
join
d2
in
Printf
printf
fib
d
d
n
n
r2
let
main
end
caml
example
The
program
spawns
two
domains
which
compute
the
n
th
Fibonacci
number
The
spawn
function
returns
a
Domain
t
value
which
can
be
joined
to
get
the
result
of
the
parallel
computation
The
join
function
blocks
until
the
computation
runs
to
completion
begin
verbatim
ocamlopt
o
fib
twice
exe
fib
twice
ml
fib
twice
exe
42
fib
42
267914296
fib
42
267914296
hyperfine
fib
twice
exe
42
Benchmark
1
fib
twice
exe
42
Time
mean
?
sd
1
249
s
?
0
025
s
User
2
451
s
System
0
012
s
Range
min

max
1
221
s

1
290
s
10
runs
end
verbatim
As
one
can
see
computing
the
n
th
Fibonacci
number
twice
takes
almost
the
same
time
as
computing
it
once
thanks
to
parallelism
section
s
par
parfib
Domainslib
A
library
for
nested
parallel
programming
Let
us
attempt
to
parallelise
the
Fibonacci
function
The
two
recursive
calls
may
be
executed
in
parallel
However
naively
parallelising
the
recursive
calls
by
spawning
domains
for
each
one
will
not
work
as
it
spawns
too
many
domains
begin
caml
example
verbatim
fib
par1
ml
let
n
try
int
of
string
Sys
argv
1
with
1
let
rec
fib
n
if
n
2
then
n
else
begin
let
d1
Domain
spawn
fun
fib
n
1
in
let
d2
Domain
spawn
fun
fib
n
2
in
Domain
join
d1
Domain
join
d2
end
let
main
let
r
fib
n
in
Printf
printf
fib
d
d
n
n
r
let
main
end
caml
example
begin
verbatim
ocamlopt
o
fib
par1
exe
fib
par1
ml
fib
par1
exe
42
Fatal
error
exception
Failure
failed
to
allocate
domain
end
verbatim
OCaml
has
a
limit
of
128
domains
that
can
be
active
at
the
same
time
An
attempt
to
spawn
more
domains
will
raise
an
exception
How
then
can
we
parallelise
the
Fibonacci
function
subsection
s
par
parfib
domainslib
Parallelising
Fibonacci
using
domainslib
The
OCaml
standard
library
provides
only
low
level
primitives
for
concurrent
and
parallel
programming
leaving
high
level
programming
libraries
to
be
developed
and
distributed
outside
the
core
compiler
distribution
href
https
github
com
ocaml
multicore
domainslib
Domainslib
is
such
a
library
for
nested
parallel
programming
which
is
epitomised
by
the
parallelism
available
in
the
recursive
Fibonacci
computation
Let
us
use
domainslib
to
parallelise
the
recursive
Fibonacci
program
It
is
recommended
that
you
install
domainslib
using
the
href
https
opam
ocaml
org
opam
package
manager
This
tutorial
uses
domainslib
version
0
5
0
Domainslib
provides
an
async
await
mechanism
for
spawning
parallel
tasks
and
awaiting
their
results
On
top
of
this
mechanism
domainslib
provides
parallel
iterators
At
its
core
domainslib
has
an
efficient
implementation
of
href
https
en
wikipedia
org
wiki
Work
stealing
work
stealing
queues
in
order
to
efficiently
share
tasks
with
other
domains
A
parallel
implementation
of
the
Fibonacci
program
follows
begin
verbatim
fib
par2
ml
let
num
domains
int
of
string
Sys
argv
1
let
n
int
of
string
Sys
argv
2
let
rec
fib
n
if
n
2
then
n
else
fib
n
1
fib
n
2
module
T
Domainslib
Task
let
rec
fib
par
pool
n
if
n
20
then
begin
let
a
T
async
pool
fun
fib
par
pool
n
1
in
let
b
T
async
pool
fun
fib
par
pool
n
2
in
T
await
pool
a
T
await
pool
b
end
else
fib
n
let
main
let
pool
T
setup
pool
num
domains
num
domains
1
in
let
res
T
run
pool
fun
fib
par
pool
n
in
T
teardown
pool
pool
Printf
printf
fib
d
d
n
n
res
let
main
end
verbatim
The
program
takes
the
number
of
domains
and
the
input
to
the
Fibonacci
function
as
the
first
and
the
second
command
line
arguments
respectively
Let
us
start
with
the
main
function
First
we
set
up
a
pool
of
domains
on
which
the
nested
parallel
tasks
will
run
The
domain
invoking
the
run
function
will
also
participate
in
executing
the
tasks
submitted
to
the
pool
We
invoke
the
parallel
Fibonacci
function
fib
par
in
the
run
function
Finally
we
tear
down
the
pool
and
print
the
result
For
sufficiently
large
inputs
n
20
the
fib
par
function
spawns
the
left
and
the
right
recursive
calls
asynchronously
in
the
pool
using
the
async
function
The
async
function
returns
a
promise
for
the
result
The
result
of
an
asynchronous
computation
is
obtained
by
awaiting
the
promise
using
the
await
function
The
await
function
call
blocks
until
the
promise
is
resolved
For
small
inputs
the
fib
par
function
simply
calls
the
sequential
Fibonacci
function
fib
It
is
important
to
switch
to
sequential
mode
for
small
problem
sizes
If
not
the
cost
of
parallelisation
will
outweigh
the
work
available
For
simplicity
we
use
ocamlfind
to
compile
this
program
In
general
it
is
recommended
that
users
use
href
https
github
com
ocaml
dune
dune
to
build
programs
that
use
libraries
installed
through
href
https
opam
ocaml
org
opam
begin
verbatim
ocamlfind
ocamlopt
package
domainslib
linkpkg
o
fib
par2
exe
fib
par2
ml
fib
par2
exe
1
42
fib
42
267914296
hyperfine
fib
exe
42
fib
par2
exe
2
42
fib
par2
exe
4
42
fib
par2
exe
8
42
Benchmark
1
fib
exe
42
Time
mean
?
sd
1
217
s
?
0
018
s
User
1
203
s
System
0
004
s
Range
min

max
1
202
s

1
261
s
10
runs
Benchmark
2
fib
par2
exe
2
42
Time
mean
?
sd
628
2
ms
?
2
9
ms
User
1243
1
ms
System
4
9
ms
Range
min

max
625
7
ms

634
5
ms
10
runs
Benchmark
3
fib
par2
exe
4
42
Time
mean
?
sd
337
6
ms
?
23
4
ms
User
1321
8
ms
System
8
4
ms
Range
min

max
318
5
ms

377
6
ms
10
runs
Benchmark
4
fib
par2
exe
8
42
Time
mean
?
sd
250
0
ms
?
9
4
ms
User
1877
1
ms
System
12
6
ms
Range
min

max
242
5
ms

277
3
ms
11
runs
Summary
fib
par2
exe
8
42
ran
1
35
?
0
11
times
faster
than
fib
par2
exe
4
42
2
51
?
0
10
times
faster
than
fib
par2
exe
2
42
4
87
?
0
20
times
faster
than
fib
exe
42
end
verbatim
The
results
show
that
with
8
domains
the
parallel
Fibonacci
program
runs
4
87
times
faster
than
the
sequential
version
subsection
s
par
iterators
Parallel
iteration
constructs
Many
numerical
algorithms
use
for
loops
The
parallel
for
primitive
provides
a
straight
forward
way
to
parallelise
such
code
Let
us
take
the
href
https
benchmarksgame
team
pages
debian
net
benchmarksgame
description
spectralnorm
html
spectralnorm
spectral
norm
benchmark
from
the
computer
language
benchmarks
game
and
parallelise
it
The
sequential
version
of
the
program
is
given
below
begin
caml
example
verbatim
spectralnorm
ml
let
n
try
int
of
string
Sys
argv
1
with
32
let
eval
A
i
j
1
float
i
j
i
j
1
2
i
1
let
eval
A
times
u
u
v
let
n
Array
length
v
1
in
for
i
0
to
n
do
let
vi
ref
0
in
for
j
0
to
n
do
vi
vi
eval
A
i
j
u
j
done
v
i
vi
done
let
eval
At
times
u
u
v
let
n
Array
length
v
1
in
for
i
0
to
n
do
let
vi
ref
0
in
for
j
0
to
n
do
vi
vi
eval
A
j
i
u
j
done
v
i
vi
done
let
eval
AtA
times
u
u
v
let
w
Array
make
Array
length
u
0
0
in
eval
A
times
u
u
w
eval
At
times
u
w
v
let
let
u
Array
make
n
1
0
and
v
Array
make
n
0
0
in
for
i
0
to
9
do
eval
AtA
times
u
u
v
eval
AtA
times
u
v
u
done
let
vv
ref
0
0
and
vBv
ref
0
0
in
for
i
0
to
n
1
do
vv
vv
v
i
v
i
vBv
vBv
u
i
v
i
done
Printf
printf
0
9f
n
sqrt
vBv
vv
end
caml
example
Observe
that
the
program
has
nested
loops
in
eval
A
times
u
and
eval
At
times
u
Each
iteration
of
the
outer
loop
body
reads
from
u
but
writes
to
disjoint
memory
locations
in
v
Hence
the
iterations
of
the
outer
loop
are
not
dependent
on
each
other
and
can
be
executed
in
parallel
The
parallel
version
of
spectral
norm
is
shown
below
begin
verbatim
spectralnorm
par
ml
let
num
domains
try
int
of
string
Sys
argv
1
with
1
let
n
try
int
of
string
Sys
argv
2
with
32
let
eval
A
i
j
1
float
i
j
i
j
1
2
i
1
module
T
Domainslib
Task
let
eval
A
times
u
pool
u
v
let
n
Array
length
v
1
in
T
parallel
for
pool
start
0
finish
n
body
fun
i
let
vi
ref
0
in
for
j
0
to
n
do
vi
vi
eval
A
i
j
u
j
done
v
i
vi
let
eval
At
times
u
pool
u
v
let
n
Array
length
v
1
in
T
parallel
for
pool
start
0
finish
n
body
fun
i
let
vi
ref
0
in
for
j
0
to
n
do
vi
vi
eval
A
j
i
u
j
done
v
i
vi
let
eval
AtA
times
u
pool
u
v
let
w
Array
make
Array
length
u
0
0
in
eval
A
times
u
pool
u
w
eval
At
times
u
pool
w
v
let
let
pool
T
setup
pool
num
domains
num
domains
1
in
let
u
Array
make
n
1
0
and
v
Array
make
n
0
0
in
T
run
pool
fun
for
i
0
to
9
do
eval
AtA
times
u
pool
u
v
eval
AtA
times
u
pool
v
u
done
let
vv
ref
0
0
and
vBv
ref
0
0
in
for
i
0
to
n
1
do
vv
vv
v
i
v
i
vBv
vBv
u
i
v
i
done
T
teardown
pool
pool
Printf
printf
0
9f
n
sqrt
vBv
vv
end
verbatim
Observe
that
the
parallel
for
function
is
isomorphic
to
the
for
loop
in
the
sequential
version
No
other
change
is
required
except
for
the
boilerplate
code
to
set
up
and
tear
down
the
pools
begin
verbatim
ocamlopt
o
spectralnorm
exe
spectralnorm
ml
ocamlfind
ocamlopt
package
domainslib
linkpkg
o
spectralnorm
par
exe
spectralnorm
par
ml
hyperfine
spectralnorm
exe
4096
spectralnorm
par
exe
2
4096
spectralnorm
par
exe
4
4096
spectralnorm
par
exe
8
4096
Benchmark
1
spectralnorm
exe
4096
Time
mean
?
sd
1
989
s
?
0
013
s
User
1
972
s
System
0
007
s
Range
min

max
1
975
s

2
018
s
10
runs
Benchmark
2
spectralnorm
par
exe
2
4096
Time
mean
?
sd
1
083
s
?
0
015
s
User
2
140
s
System
0
009
s
Range
min

max
1
064
s

1
102
s
10
runs
Benchmark
3
spectralnorm
par
exe
4
4096
Time
mean
?
sd
698
7
ms
?
10
3
ms
User
2730
8
ms
System
18
3
ms
Range
min

max
680
9
ms

721
7
ms
10
runs
Benchmark
4
spectralnorm
par
exe
8
4096
Time
mean
?
sd
921
8
ms
?
52
1
ms
User
6711
6
ms
System
51
0
ms
Range
min

max
838
6
ms

989
2
ms
10
runs
Summary
spectralnorm
par
exe
4
4096
ran
1
32
?
0
08
times
faster
than
spectralnorm
par
exe
8
4096
1
55
?
0
03
times
faster
than
spectralnorm
par
exe
2
4096
2
85
?
0
05
times
faster
than
spectralnorm
exe
4096
end
verbatim
On
the
author
s
machine
the
program
scales
reasonably
well
up
to
4
domains
but
performs
worse
with
8
domains
Recall
that
the
machine
only
has
4
physical
cores
Debugging
and
fixing
this
performance
issue
is
beyond
the
scope
of
this
tutorial
section
s
par
gc
Parallel
garbage
collection
An
important
aspect
of
the
scalability
of
parallel
OCaml
programs
is
the
scalability
of
the
garbage
collector
GC
The
OCaml
GC
is
designed
to
have
both
low
latency
and
good
parallel
scalability
OCaml
has
a
generational
garbage
collector
with
a
small
minor
heap
and
a
large
major
heap
New
objects
upto
a
certain
size
are
allocated
in
the
minor
heap
Each
domain
has
its
own
domain
local
minor
heap
arena
into
which
new
objects
are
allocated
without
synchronising
with
the
other
domains
When
a
domain
exhausts
its
minor
heap
arena
it
calls
for
a
stop
the
world
collection
of
the
minor
heaps
In
the
stop
the
world
section
all
the
domains
collect
their
minor
heap
arenas
in
parallel
evacuating
the
survivors
to
the
major
heap
For
the
major
heap
each
domain
maintains
domain
local
size
segmented
pools
of
memory
into
which
large
objects
and
survivors
from
the
minor
collection
are
allocated
Having
domain
local
pools
avoids
synchronisation
for
most
major
heap
allocations
The
major
heap
is
collected
by
a
concurrent
mark
and
sweep
algorithm
that
involves
a
few
short
stop
the
world
pauses
for
each
major
cycle
Overall
users
should
expect
the
garbage
collector
to
scale
well
with
as
the
number
of
domains
increases
with
latency
remaining
low
For
more
information
on
the
design
and
evaluation
of
the
garbage
collector
please
have
a
look
at
the
ICFP
2020
paper
on
href
https
arxiv
org
abs
2004
11663
Retrofitting
Parallelism
onto
OCaml
section
s
par
mm
easy
Memory
model
The
easy
bits
Modern
processors
and
compilers
aggressively
optimise
programs
These
optimisations
accelerate
without
otherwise
affecting
sequential
programs
but
cause
surprising
behaviours
to
be
visible
in
parallel
programs
To
benefit
from
these
optimisations
OCaml
adopts
a
textit
relaxed
memory
model
that
precisely
specifies
which
of
these
emph
relaxed
behaviours
programs
may
observe
While
these
models
are
difficult
to
program
against
directly
the
OCaml
memory
model
provides
recipes
that
retain
the
simplicity
of
sequential
reasoning
Firstly
immutable
values
may
be
freely
shared
between
multiple
domains
and
may
be
accessed
in
parallel
For
mutable
data
structures
such
as
reference
cells
arrays
and
mutable
record
fields
programmers
should
avoid
emph
data
races
Reference
cells
arrays
and
mutable
record
fields
are
said
to
be
emph
non
atomic
data
structures
A
data
race
is
said
to
occur
when
two
domains
concurrently
access
a
non
atomic
memory
location
without
emph
synchronisation
and
at
least
one
of
the
accesses
is
a
write
OCaml
provides
a
number
of
ways
to
introduce
synchronisation
including
atomic
variables
section
ref
s
par
atomics
and
mutexes
section
ref
s
par
sync
Importantly
textbf
for
data
race
free
DRF
programs
OCaml
provides
sequentially
consistent
SC
semantics
the
observed
behaviour
of
such
programs
can
be
explained
by
the
interleaving
of
operations
from
different
domains
This
property
is
known
as
the
DRF
SC
guarantee
Moreover
in
OCaml
the
DRF
SC
guarantee
is
modular
if
a
part
of
a
program
is
data
race
free
then
the
OCaml
memory
model
ensures
that
those
parts
have
sequential
consistency
despite
other
parts
of
the
program
having
data
races
Even
for
programs
with
data
races
OCaml
provides
strong
guarantees
While
the
user
may
observe
non
sequentially
consistent
behaviours
there
are
no
crashes
For
more
details
on
the
relaxed
behaviours
in
the
presence
of
data
races
please
have
a
look
at
the
chapter
on
the
hard
bits
of
the
memory
model
chapter
ref
c
memorymodel
section
s
par
sync
Blocking
synchronisation
Domains
may
perform
blocking
synchronisation
with
the
help
of
stdmoduleref
Mutex
stdmoduleref
Condition
and
stdmoduleref
Semaphore
modules
These
modules
are
the
same
as
those
used
to
synchronise
threads
created
by
the
threads
library
chapter
ref
c
threads
For
clarity
in
the
rest
of
this
chapter
we
refer
to
the
threads
created
by
the
threads
library
as
emph
systhreads
The
following
program
implements
a
concurrent
stack
using
mutex
and
condition
variables
begin
caml
example
verbatim
module
Blocking
stack
sig
type
a
t
val
make
unit
a
t
val
push
a
t
a
unit
val
pop
a
t
a
end
struct
type
a
t
mutable
contents
a
list
mutex
Mutex
t
nonempty
Condition
t
let
make
contents
mutex
Mutex
create
nonempty
Condition
create
let
push
r
v
Mutex
lock
r
mutex
r
contents
v
r
contents
Condition
signal
r
nonempty
Mutex
unlock
r
mutex
let
pop
r
Mutex
lock
r
mutex
let
rec
loop
match
r
contents
with
Condition
wait
r
nonempty
r
mutex
loop
x
xs
r
contents
xs
x
in
let
res
loop
in
Mutex
unlock
r
mutex
res
end
end
caml
example
The
concurrent
stack
is
implemented
using
a
record
with
three
fields
a
mutable
field
contents
which
stores
the
elements
in
the
stack
a
mutex
to
control
access
to
the
contents
field
and
a
condition
variable
nonempty
which
is
used
to
signal
blocked
domains
waiting
for
the
stack
to
become
non
empty
The
push
operation
locks
the
mutex
updates
the
contents
field
with
a
new
list
whose
head
is
the
element
being
pushed
and
the
tail
is
the
old
list
The
condition
variable
nonempty
is
signalled
while
the
lock
is
held
in
order
to
wake
up
any
domains
waiting
on
this
condition
If
there
are
waiting
domains
one
of
the
domains
is
woken
up
If
there
are
none
then
the
signal
operation
has
no
effect
The
pop
operation
locks
the
mutex
and
checks
whether
the
stack
is
empty
If
so
the
calling
domain
waits
on
the
condition
variable
nonempty
using
the
wait
primitive
The
wait
call
atomically
suspends
the
execution
of
the
current
domain
and
unlocks
the
mutex
When
this
domain
is
woken
up
again
when
the
wait
call
returns
it
holds
the
lock
on
mutex
The
domain
tries
to
read
the
contents
of
the
stack
again
If
the
pop
operation
sees
that
the
stack
is
non
empty
it
updates
the
contents
to
the
tail
of
the
old
list
and
returns
the
head
The
use
of
mutex
to
control
access
to
the
shared
resource
contents
introduces
sufficient
synchronisation
between
multiple
domains
using
the
stack
Hence
there
are
no
data
races
when
multiple
domains
use
the
stack
in
parallel
subsection
s
par
systhread
interaction
Interaction
with
systhreads
How
do
systhreads
interact
with
domains
The
systhreads
created
on
a
particular
domain
remain
pinned
to
that
domain
Only
one
systhread
at
a
time
is
allowed
to
run
OCaml
code
on
a
particular
domain
However
systhreads
belonging
to
a
particular
domain
may
run
C
library
or
system
code
in
parallel
Systhreads
belonging
to
different
domains
may
execute
in
parallel
When
using
systhreads
the
thread
created
for
executing
the
computation
given
to
Domain
spawn
is
also
treated
as
a
systhread
For
example
the
following
program
creates
in
total
two
domains
including
the
initial
domain
with
two
systhreads
each
including
the
initial
systhread
for
each
of
the
domains
begin
verbatim
dom
thr
ml
let
m
Mutex
create
let
r
ref
None
protected
by
m
let
task
let
my
thr
id
Thread
id
self
in
let
my
dom
id
int
Domain
self
in
Mutex
lock
m
begin
match
r
with
None
Printf
printf
Thread
d
running
on
domain
d
saw
initial
write
n
my
thr
id
my
dom
id
Some
their
thr
id
Printf
printf
Thread
d
running
on
domain
d
saw
the
write
by
thread
d
n
my
thr
id
my
dom
id
their
thr
id
end
r
Some
my
thr
id
Mutex
unlock
m
let
task
let
t
Thread
create
task
in
task
Thread
join
t
let
main
let
d
Domain
spawn
task
in
task
Domain
join
d
let
main
end
verbatim
begin
verbatim
ocamlopt
I
threads
I
unix
unix
cmxa
threads
cmxa
o
dom
thr
exe
dom
thr
ml
dom
thr
exe
Thread
1
running
on
domain
1
saw
initial
write
Thread
0
running
on
domain
0
saw
the
write
by
thread
1
Thread
2
running
on
domain
1
saw
the
write
by
thread
0
Thread
3
running
on
domain
0
saw
the
write
by
thread
2
end
verbatim
This
program
uses
a
shared
reference
cell
protected
by
a
mutex
to
communicate
between
the
different
systhreads
running
on
two
different
domains
The
systhread
identifiers
uniquely
identify
systhreads
in
the
program
The
initial
domain
gets
the
domain
id
0
and
thread
id
0
The
newly
spawned
domain
gets
the
domain
id
1
Note
that
all
the
systhreads
belonging
to
a
particular
domain
are
joined
when
the
domain
is
joined
In
particular
if
such
a
systhread
is
running
an
infinite
loop
then
joining
the
domain
will
never
return
section
s
par
c
bindings
Interaction
with
C
bindings
During
parallel
execution
with
multiple
domains
C
code
running
on
a
domain
may
run
in
parallel
with
any
C
code
running
in
other
domains
even
if
neither
of
them
has
released
the
domain
lock
Prior
to
OCaml
5
0
C
bindings
may
have
assumed
that
if
the
OCaml
runtime
lock
is
not
released
then
it
would
be
safe
to
manipulate
global
C
state
e
g
initialise
a
function
local
static
value
This
is
no
longer
true
in
the
presence
of
parallel
execution
with
multiple
domains
section
s
par
atomics
Atomics
Mutexes
condition
variables
and
semaphores
are
used
to
implement
blocking
synchronisation
between
domains
For
non
blocking
synchronisation
OCaml
provides
stdmoduleref
Atomic
variables
As
the
name
suggests
non
blocking
synchronisation
does
not
provide
mechanisms
for
suspending
and
waking
up
domains
On
the
other
hand
primitives
used
in
non
blocking
synchronisation
are
often
compiled
to
atomic
read
modify
write
primitives
that
the
hardware
provides
As
an
example
the
following
program
increments
a
non
atomic
counter
and
an
atomic
counter
in
parallel
begin
caml
example
verbatim
incr
ml
let
twice
in
parallel
f
let
d1
Domain
spawn
f
in
let
d2
Domain
spawn
f
in
Domain
join
d1
Domain
join
d2
let
plain
ref
n
let
r
ref
0
in
let
f
for
i
1
to
n
do
incr
r
done
in
twice
in
parallel
f
Printf
printf
Non
atomic
ref
count
d
n
r
let
atomic
ref
n
let
r
Atomic
make
0
in
let
f
for
i
1
to
n
do
Atomic
incr
r
done
in
twice
in
parallel
f
Printf
printf
Atomic
ref
count
d
n
Atomic
get
r
let
main
let
n
try
int
of
string
Sys
argv
1
with
1
in
plain
ref
n
atomic
ref
n
let
main
end
caml
example
begin
verbatim
ocamlopt
o
incr
exe
incr
ml
incr
exe
1
000
000
Non
atomic
ref
count
1187193
Atomic
ref
count
2000000
end
verbatim
Observe
that
the
result
from
using
the
non
atomic
counter
is
lower
than
what
one
would
naively
expect
This
is
because
the
non
atomic
incr
function
is
equivalent
to
begin
caml
example
verbatim
let
incr
r
let
curr
r
in
r
curr
1
end
caml
example
Observe
that
the
load
and
the
store
are
two
separate
operations
and
the
increment
operation
as
a
whole
is
not
performed
atomically
When
two
domains
execute
this
code
in
parallel
both
of
them
may
read
the
same
value
of
the
counter
curr
and
update
it
to
curr
1
Hence
instead
of
two
increments
the
effect
will
be
that
of
a
single
increment
On
the
other
hand
the
atomic
counter
performs
the
load
and
the
store
atomically
with
the
help
of
hardware
support
for
atomicity
The
atomic
counter
returns
the
expected
result
Atomic
variables
can
be
used
for
low
level
synchronisation
between
domains
The
following
example
uses
an
atomic
variable
to
exchange
a
message
between
two
domains
begin
caml
example
verbatim
let
r
Atomic
make
None
let
sender
Atomic
set
r
Some
Hello
let
rec
receiver
match
Atomic
get
r
with
None
Domain
cpu
relax
receiver
Some
m
print
endline
m
let
main
let
s
Domain
spawn
sender
in
let
d
Domain
spawn
receiver
in
Domain
join
s
Domain
join
d
let
main
end
caml
example
Although
the
sender
and
the
receiver
compete
to
access
r
this
is
not
a
data
race
since
r
is
an
atomic
reference
subsection
s
par
lockfree
stack
Lock
free
stack
The
Atomic
module
is
used
to
implement
non
blocking
lock
free
data
structures
The
following
program
implements
a
lock
free
stack
begin
caml
example
verbatim
module
Lockfree
stack
sig
type
a
t
val
make
unit
a
t
val
push
a
t
a
unit
val
pop
a
t
a
option
end
struct
type
a
t
a
list
Atomic
t
let
make
Atomic
make
let
rec
push
r
v
let
s
Atomic
get
r
in
if
Atomic
compare
and
set
r
s
v
s
then
else
Domain
cpu
relax
push
r
v
let
rec
pop
r
let
s
Atomic
get
r
in
match
s
with
None
x
xs
if
Atomic
compare
and
set
r
s
xs
then
Some
x
else
Domain
cpu
relax
pop
r
end
end
caml
example
The
atomic
stack
is
represented
by
an
atomic
reference
that
holds
a
list
The
push
and
pop
operations
use
the
compare
and
set
primitive
to
attempt
to
atomically
update
the
atomic
reference
The
expression
compare
and
set
r
seen
v
sets
the
value
of
r
to
v
if
and
only
if
its
current
value
is
physically
equal
to
seen
Importantly
the
comparison
and
the
update
occur
atomically
The
expression
evaluates
to
true
if
the
comparison
succeeded
and
the
update
happened
and
false
otherwise
If
the
compare
and
set
fails
then
some
other
domain
is
also
attempting
to
update
the
atomic
reference
at
the
same
time
In
this
case
the
push
and
pop
operations
call
Domain
cpu
relax
to
back
off
for
a
short
duration
allowing
competing
domains
to
make
progress
before
retrying
the
failed
operation
This
lock
free
stack
implementation
is
called
a
href
https
en
wikipedia
org
wiki
Treiber
stack
Treiber
stack
subsection
s
atomic
record
fields
Atomic
record
fields
The
type
a
Atomic
t
is
the
atomic
counterpart
of
the
type
of
OCaml
references
a
ref
Since
OCaml
5
4
we
also
support
atomic
record
fields
which
must
be
mutable
via
the
atomic
attribute
For
example
begin
caml
example
verbatim
type
a
refcounted
value
a
mutable
readers
int
atomic
end
caml
example
The
field
readers
is
atomic
so
that
reading
and
writing
to
this
field
are
atomic
operations
similar
to
Atomic
get
and
Atomic
set
It
is
possible
to
perform
other
atomic
operations
on
this
field
by
using
a
built
in
extension
node
atomic
loc
if
rc
is
a
value
of
type
foo
refcounted
then
atomic
loc
rc
readers
is
an
expression
of
the
built
in
type
foo
Atomic
Loc
t
which
allows
atomic
operations
defined
in
the
the
stdmoduleref
Atomic
Loc
module
of
the
standard
library
mirroring
the
operations
exposed
for
atomic
references
in
the
stdmoduleref
Atomic
module
begin
caml
example
toplevel
let
add
reader
rc
Atomic
Loc
fetch
and
add
atomic
loc
rc
readers
1
show
Atomic
Loc
end
caml
example
paragraph
Limitation
Currently
there
is
no
analogue
of
Atomic
make
contended
for
atomic
record
fields
If
false
sharing
is
an
issue
for
a
specific
record
field
the
best
supported
approach
is
to
use
a
field
of
type
Atomic
t
We
hope
to
implement
support
for
on
demand
padding
of
record
fields
in
the
future
paragraph
Performance
note
Internally
atomic
loc
rc
readers
is
represented
as
a
pair
of
the
record
value
and
a
field
offset
Whenever
this
expression
is
directly
applied
to
an
atomic
primitive
of
the
stdmoduleref
Atomic
Loc
module
the
compiler
will
optimize
away
the
creation
of
the
pair
it
passes
the
value
and
the
offset
as
separate
parameters
to
an
underlying
runtime
primitive
On
the
other
hand
storing
an
atomic
location
in
a
data
structure
or
passing
it
to
another
non
inlined
function
may
allocate
a
pair
When
in
doubt
you
can
inspect
the
dcmm
intermediate
representation
of
your
code
chapter
The
core
library
label
c
corelib
cutname
core
html
This
chapter
describes
the
OCaml
core
library
which
is
composed
of
declarations
for
built
in
types
and
exceptions
plus
the
module
Stdlib
that
provides
basic
operations
on
these
built
in
types
The
Stdlib
module
is
special
in
two
ways
begin
itemize
item
It
is
automatically
linked
with
the
user
s
object
code
files
by
the
ocamlc
command
chapter
ref
c
camlc
item
It
is
automatically
opened
when
a
compilation
starts
or
when
the
toplevel
system
is
launched
Hence
it
is
possible
to
use
unqualified
identifiers
to
refer
to
the
functions
provided
by
the
Stdlib
module
without
adding
a
open
Stdlib
directive
end
itemize
begin
latexonly
section
s
core
conventions
Conventions
The
declarations
of
the
built
in
types
and
the
components
of
module
Stdlib
are
printed
one
by
one
in
typewriter
font
followed
by
a
short
comment
All
library
modules
and
the
components
they
provide
are
indexed
at
the
end
of
this
report
end
latexonly
input
builtin
tex
ifouthtml
section
s
stdlib
module
Module
tt
Stdlib
the
initially
opened
module
fi
begin
linklist
libdocitem
Stdlib
the
initially
opened
module
end
linklist
chapter
Recently
removed
or
moved
libraries
Graphics
Bigarray
Num
LablTk
HEVEA
cutname
old
html
This
chapter
describes
three
libraries
which
were
formerly
part
of
the
OCaml
distribution
Graphics
Num
and
LablTk
and
a
library
which
has
now
become
part
of
OCaml
s
standard
library
and
is
documented
there
Bigarray
section
s
graphics
removed
The
Graphics
Library
Since
OCaml
4
09
the
graphics
library
is
distributed
as
an
external
package
Its
new
home
is
url
https
github
com
ocaml
graphics
If
you
are
using
the
opam
package
manager
you
should
install
the
corresponding
graphics
package
begin
alltt
opam
install
graphics
end
alltt
Before
OCaml
4
09
this
package
simply
ensures
that
the
graphics
library
was
installed
by
the
compiler
and
starting
from
OCaml
4
09
this
package
effectively
provides
the
graphics
library
section
s
bigarray
moved
The
Bigarray
Library
As
of
OCaml
4
07
the
bigarray
library
has
been
integrated
into
OCaml
s
standard
library
The
bigarray
functionality
may
now
be
found
in
the
standard
library
ifouthtml
ahref
libref
Bigarray
html
texttt
Bigarray
module
else
texttt
Bigarray
module
fi
except
for
the
map
file
function
which
is
now
part
of
the
hyperref
c
unix
Unix
library
The
documentation
has
been
integrated
into
the
documentation
for
the
standard
library
The
legacy
bigarray
library
bundled
with
the
compiler
is
a
compatibility
library
with
exactly
the
same
interface
as
before
i
e
with
map
file
included
We
strongly
recommend
that
you
port
your
code
to
use
the
standard
library
version
instead
as
the
changes
required
are
minimal
If
you
choose
to
use
the
compatibility
library
you
must
link
your
programs
as
follows
begin
alltt
ocamlc
var
other
options
bigarray
cma
var
other
files
ocamlopt
var
other
options
bigarray
cmxa
var
other
files
end
alltt
For
interactive
use
of
the
bigarray
compatibility
library
do
begin
alltt
ocamlmktop
o
mytop
bigarray
cma
mytop
end
alltt
or
if
dynamic
linking
of
C
libraries
is
supported
on
your
platform
start
ocaml
and
type
load
bigarray
cma
section
s
graphics
removed
The
Num
Library
The
num
library
implements
integer
arithmetic
and
rational
arithmetic
in
arbitrary
precision
It
was
split
off
the
core
OCaml
distribution
starting
with
the
4
06
0
release
and
can
now
be
found
at
url
https
github
com
ocaml
num
New
applications
that
need
arbitrary
precision
arithmetic
should
use
the
Zarith
library
url
https
github
com
ocaml
Zarith
instead
of
the
Num
library
and
older
applications
that
already
use
Num
are
encouraged
to
switch
to
Zarith
Zarith
delivers
much
better
performance
than
Num
and
has
a
nicer
API
section
s
labltk
removed
The
Labltk
Library
and
OCamlBrowser
Since
OCaml
version
4
02
the
OCamlBrowser
tool
and
the
Labltk
library
are
distributed
separately
from
the
OCaml
compiler
The
project
is
now
hosted
at
url
https
github
com
garrigue
labltk
chapter
The
threads
library
label
c
threads
cutname
threads
html
HEVEA
cutname
libthreads
html
The
threads
library
allows
concurrent
programming
in
OCaml
It
provides
multiple
threads
of
control
also
called
lightweight
processes
that
execute
concurrently
in
the
same
memory
space
Threads
communicate
by
in
place
modification
of
shared
data
structures
or
by
sending
and
receiving
data
on
communication
channels
The
threads
library
is
implemented
on
top
of
the
threading
facilities
provided
by
the
operating
system
POSIX
1003
1c
threads
for
Linux
MacOS
and
other
Unix
like
systems
Win32
threads
for
Windows
Only
one
thread
at
a
time
is
allowed
to
run
OCaml
code
on
a
particular
domain
ref
s
par
systhread
interaction
Hence
opportunities
for
parallelism
are
limited
to
the
parts
of
the
program
that
run
system
or
C
library
code
However
threads
provide
concurrency
and
can
be
used
to
structure
programs
as
several
communicating
processes
Threads
also
efficiently
support
concurrent
overlapping
I
O
operations
Programs
that
use
threads
must
be
linked
as
follows
begin
alltt
ocamlc
I
unix
I
threads
var
other
options
unix
cma
threads
cma
var
other
files
ocamlopt
I
unix
I
threads
var
other
options
unix
cmxa
threads
cmxa
var
other
files
end
alltt
Compilation
units
that
use
the
threads
library
must
also
be
compiled
with
the
I
threads
option
see
chapter
ref
c
camlc
begin
linklist
libdocitem
Thread
lightweight
threads
libdocitem
Event
first
class
synchronous
communication
end
linklist
section
s
core
builtins
Built
in
types
and
predefined
exceptions
The
following
built
in
types
and
predefined
exceptions
are
always
defined
in
the
compilation
environment
but
are
not
part
of
any
module
As
a
consequence
they
can
only
be
referred
by
their
short
names
vspace
0
1cm
subsection
ss
builtin
types
Built
in
types
vspace
0
1cm
begin
ocamldoccode
type
int
end
ocamldoccode
index
int
verb
int
begin
ocamldocdescription
The
type
of
integer
numbers
end
ocamldocdescription
begin
ocamldoccode
type
char
end
ocamldoccode
index
char
verb
char
begin
ocamldocdescription
The
type
of
characters
end
ocamldocdescription
begin
ocamldoccode
type
bytes
end
ocamldoccode
index
bytes
verb
bytes
begin
ocamldocdescription
The
type
of
writable
byte
sequences
end
ocamldocdescription
begin
ocamldoccode
type
string
end
ocamldoccode
index
string
verb
string
begin
ocamldocdescription
The
type
of
read
only
character
strings
end
ocamldocdescription
begin
ocamldoccode
type
float
end
ocamldoccode
index
float
verb
float
begin
ocamldocdescription
The
type
of
floating
point
numbers
end
ocamldocdescription
begin
ocamldoccode
type
bool
false
true
end
ocamldoccode
index
bool
verb
bool
begin
ocamldocdescription
The
type
of
booleans
truth
values
end
ocamldocdescription
begin
ocamldoccode
type
unit
end
ocamldoccode
index
unit
verb
unit
begin
ocamldocdescription
The
type
of
the
unit
value
end
ocamldocdescription
begin
ocamldoccode
type
exn
end
ocamldoccode
index
exn
verb
exn
begin
ocamldocdescription
The
type
of
exception
values
end
ocamldocdescription
begin
ocamldoccode
type
a
array
end
ocamldoccode
index
array
verb
array
begin
ocamldocdescription
The
type
of
arrays
whose
elements
have
type
a
end
ocamldocdescription
begin
ocamldoccode
type
a
list
of
a
a
list
end
ocamldoccode
index
list
verb
list
begin
ocamldocdescription
The
type
of
lists
whose
elements
have
type
a
end
ocamldocdescription
begin
ocamldoccode
type
a
option
None
Some
of
a
end
ocamldoccode
index
option
verb
option
begin
ocamldocdescription
The
type
of
optional
values
of
type
a
end
ocamldocdescription
begin
ocamldoccode
type
int32
end
ocamldoccode
index
int32
verb
int32
begin
ocamldocdescription
The
type
of
signed
32
bit
integers
Literals
for
32
bit
integers
are
suffixed
by
l
See
the
stdmoduleref
Int32
module
end
ocamldocdescription
begin
ocamldoccode
type
int64
end
ocamldoccode
index
int64
verb
int64
begin
ocamldocdescription
The
type
of
signed
64
bit
integers
Literals
for
64
bit
integers
are
suffixed
by
L
See
the
stdmoduleref
Int64
module
end
ocamldocdescription
begin
ocamldoccode
type
nativeint
end
ocamldoccode
index
nativeint
verb
nativeint
begin
ocamldocdescription
The
type
of
signed
platform
native
integers
32
bits
on
32
bit
processors
64
bits
on
64
bit
processors
Literals
for
native
integers
are
suffixed
by
n
See
the
stdmoduleref
Nativeint
module
end
ocamldocdescription
begin
ocamldoccode
type
a
b
c
d
e
f
format6
end
ocamldoccode
index
format4
verb
format4
begin
ocamldocdescription
The
type
of
format
strings
a
is
the
type
of
the
parameters
of
the
format
f
is
the
result
type
for
the
printf
style
functions
b
is
the
type
of
the
first
argument
given
to
a
and
t
printing
functions
see
module
stdmoduleref
Printf
c
is
the
result
type
of
these
functions
and
also
the
type
of
the
argument
transmitted
to
the
first
argument
of
kprintf
style
functions
d
is
the
result
type
for
the
scanf
style
functions
see
module
stdmoduleref
Scanf
and
e
is
the
type
of
the
receiver
function
for
the
scanf
style
functions
end
ocamldocdescription
begin
ocamldoccode
type
a
lazy
t
end
ocamldoccode
index
lazyt
verb
lazy
t
begin
ocamldocdescription
This
type
is
used
to
implement
the
stdmoduleref
Lazy
module
It
should
not
be
used
directly
end
ocamldocdescription
vspace
0
1cm
subsection
ss
predef
exn
Predefined
exceptions
vspace
0
1cm
begin
ocamldoccode
exception
Match
failure
of
string
int
int
end
ocamldoccode
index
Matchfailure
verb
Match
failure
begin
ocamldocdescription
Exception
raised
when
none
of
the
cases
of
a
pattern
matching
apply
The
arguments
are
the
location
of
the
match
keyword
in
the
source
code
file
name
line
number
column
number
end
ocamldocdescription
begin
ocamldoccode
exception
Assert
failure
of
string
int
int
end
ocamldoccode
index
Assertfailure
verb
Assert
failure
begin
ocamldocdescription
Exception
raised
when
an
assertion
fails
The
arguments
are
the
location
of
the
assert
keyword
in
the
source
code
file
name
line
number
column
number
end
ocamldocdescription
begin
ocamldoccode
exception
Invalid
argument
of
string
end
ocamldoccode
index
Invalidargument
verb
Invalid
argument
begin
ocamldocdescription
Exception
raised
by
library
functions
to
signal
that
the
given
arguments
do
not
make
sense
The
string
gives
some
information
to
the
programmer
As
a
general
rule
this
exception
should
not
be
caught
it
denotes
a
programming
error
and
the
code
should
be
modified
not
to
trigger
it
end
ocamldocdescription
begin
ocamldoccode
exception
Failure
of
string
end
ocamldoccode
index
Failure
verb
Failure
begin
ocamldocdescription
Exception
raised
by
library
functions
to
signal
that
they
are
undefined
on
the
given
arguments
The
string
is
meant
to
give
some
information
to
the
programmer
you
must
emph
not
pattern
match
on
the
string
literal
because
it
may
change
in
future
versions
use
verb
Failure
instead
end
ocamldocdescription
begin
ocamldoccode
exception
Not
found
end
ocamldoccode
index
Notfound
verb
Not
found
begin
ocamldocdescription
Exception
raised
by
search
functions
when
the
desired
object
could
not
be
found
end
ocamldocdescription
begin
ocamldoccode
exception
Out
of
memory
end
ocamldoccode
index
Outofmemory
verb
Out
of
memory
begin
ocamldocdescription
Exception
raised
by
the
garbage
collector
when
there
is
insufficient
memory
to
complete
the
computation
Not
reliable
for
allocations
on
the
minor
heap
end
ocamldocdescription
begin
ocamldoccode
exception
Stack
overflow
end
ocamldoccode
index
Stackoverflow
verb
Stack
overflow
begin
ocamldocdescription
Exception
raised
by
the
bytecode
interpreter
when
the
evaluation
stack
reaches
its
maximal
size
This
often
indicates
infinite
or
excessively
deep
recursion
in
the
user
s
program
Before
4
10
it
was
not
fully
implemented
by
the
native
code
compiler
end
ocamldocdescription
begin
ocamldoccode
exception
Sys
error
of
string
end
ocamldoccode
index
Syserror
verb
Sys
error
begin
ocamldocdescription
Exception
raised
by
the
input
output
functions
to
report
an
operating
system
error
The
string
is
meant
to
give
some
information
to
the
programmer
you
must
emph
not
pattern
match
on
the
string
literal
because
it
may
change
in
future
versions
use
verb
Sys
error
instead
end
ocamldocdescription
begin
ocamldoccode
exception
End
of
file
end
ocamldoccode
index
Endoffile
verb
End
of
file
begin
ocamldocdescription
Exception
raised
by
input
functions
to
signal
that
the
end
of
file
has
been
reached
end
ocamldocdescription
begin
ocamldoccode
exception
Division
by
zero
end
ocamldoccode
index
Divisionbyzero
verb
Division
by
zero
begin
ocamldocdescription
Exception
raised
by
integer
division
and
remainder
operations
when
their
second
argument
is
zero
end
ocamldocdescription
begin
ocamldoccode
exception
Sys
blocked
io
end
ocamldoccode
index
Sysblockedio
verb
Sys
blocked
io
begin
ocamldocdescription
A
special
case
of
Sys
error
raised
when
no
I
O
is
possible
on
a
non
blocking
I
O
channel
end
ocamldocdescription
begin
ocamldoccode
exception
Undefined
recursive
module
of
string
int
int
end
ocamldoccode
index
Undefinedrecursivemodule
verb
Undefined
recursive
module
begin
ocamldocdescription
Exception
raised
when
an
ill
founded
recursive
module
definition
is
evaluated
See
section
ref
s
recursive
modules
The
arguments
are
the
location
of
the
definition
in
the
source
code
file
name
line
number
column
number
end
ocamldocdescription
chapter
The
runtime
events
library
label
c
runtime
events
cutname
runtime
events
html
HEVEA
cutname
runtime
events
html
The
runtime
events
library
provides
an
API
for
consuming
runtime
tracing
and
metrics
information
from
the
runtime
See
chapter
ref
c
runtime
tracing
for
more
information
Programs
that
use
runtime
events
must
be
linked
as
follows
begin
alltt
ocamlc
I
runtime
events
var
other
options
unix
cma
runtime
events
cma
var
other
files
ocamlopt
I
runtime
events
var
other
options
unix
cmxa
runtime
events
cmxa
var
other
files
end
alltt
Compilation
units
that
use
the
runtime
events
library
must
also
be
compiled
with
the
I
runtime
events
option
see
chapter
ref
c
camlc
begin
linklist
libdocitem
Runtime
events
tracing
system
end
linklist
chapter
The
dynlink
library
dynamic
loading
and
linking
of
object
files
HEVEA
cutname
libdynlink
html
The
dynlink
library
supports
type
safe
dynamic
loading
and
linking
of
bytecode
object
files
cmo
and
cma
files
in
a
running
bytecode
program
or
of
native
plugins
usually
cmxs
files
in
a
running
native
program
Type
safety
is
ensured
by
limiting
the
set
of
modules
from
the
running
program
that
the
loaded
object
file
can
access
and
checking
that
the
running
program
and
the
loaded
object
file
have
been
compiled
against
the
same
interfaces
for
these
modules
In
native
code
there
are
also
some
compatibility
checks
on
the
implementations
to
avoid
errors
with
cross
module
optimizations
it
might
be
useful
to
hide
cmx
files
when
building
native
plugins
so
that
they
remain
independent
of
the
implementation
of
modules
in
the
main
program
Programs
that
use
the
dynlink
library
simply
need
to
include
the
dynlink
library
directory
with
I
dynlink
and
link
dynlink
cma
or
dynlink
cmxa
with
their
object
files
and
other
libraries
textbf
Note
in
order
to
insure
that
the
dynamically
loaded
modules
have
access
to
all
the
libraries
that
are
visible
to
the
main
program
and
not
just
to
the
parts
of
those
libraries
that
are
actually
used
in
the
main
program
programs
using
the
dynlink
library
should
be
linked
with
linkall
begin
linklist
libdocitem
Dynlink
dynamic
loading
of
bytecode
object
files
end
linklist
chapter
The
str
library
regular
expressions
and
string
processing
HEVEA
cutname
libstr
html
The
str
library
provides
high
level
string
processing
functions
some
based
on
regular
expressions
It
is
intended
to
support
the
kind
of
file
processing
that
is
usually
performed
with
scripting
languages
such
as
awk
perl
or
sed
Programs
that
use
the
str
library
must
be
linked
as
follows
begin
alltt
ocamlc
var
other
options
I
str
str
cma
var
other
files
ocamlopt
var
other
options
I
str
str
cmxa
var
other
files
end
alltt
For
interactive
use
of
the
str
library
do
begin
alltt
ocamlmktop
o
mytop
str
cma
mytop
end
alltt
or
if
dynamic
linking
of
C
libraries
is
supported
on
your
platform
start
ocaml
and
type
begin
caml
example
toplevel
directory
str
load
str
cma
end
caml
example
begin
linklist
libdocitem
Str
regular
expressions
and
string
processing
end
linklist
chapter
The
standard
library
label
c
stdlib
cutname
stdlib
html
This
chapter
describes
the
functions
provided
by
the
OCaml
standard
library
The
modules
from
the
standard
library
are
automatically
linked
with
the
user
s
object
code
files
by
the
ocamlc
command
Hence
these
modules
can
be
used
in
standalone
programs
without
having
to
add
any
cmo
file
on
the
command
line
for
the
linking
phase
Similarly
in
interactive
use
these
globals
can
be
used
in
toplevel
phrases
without
having
to
load
any
cmo
file
in
memory
Unlike
the
core
Stdlib
module
submodules
are
not
automatically
opened
when
compilation
starts
or
when
the
toplevel
system
is
launched
Hence
it
is
necessary
to
use
qualified
identifiers
to
refer
to
the
functions
provided
by
these
modules
or
to
add
open
directives
label
stdlib
top
begin
latexonly
section
s
stdlib
conv
Conventions
For
easy
reference
the
modules
are
listed
below
in
alphabetical
order
of
module
names
For
each
module
the
declarations
from
its
signature
are
printed
one
by
one
in
typewriter
font
followed
by
a
short
comment
All
modules
and
the
identifiers
they
export
are
indexed
at
the
end
of
this
report
section
s
stdlib
overview
Overview
Here
is
a
short
listing
by
theme
of
the
standard
library
modules
subsubsection
sss
stdlib
data
structures
Data
structures
begin
tabular
lll
Beware
these
entries
must
be
written
in
a
very
rigidly
defined
format
or
the
check
stdlib
modules
script
will
complain
String
p
stdpageref
String
string
operations
Bytes
p
stdpageref
Bytes
operations
on
byte
sequences
Array
p
stdpageref
Array
array
operations
List
p
stdpageref
List
list
operations
StdLabels
p
stdpageref
StdLabels
labelized
versions
of
the
above
4
modules
Unit
p
stdpageref
Unit
unit
values
Bool
p
stdpageref
Bool
boolean
values
Char
p
stdpageref
Char
character
operations
Uchar
p
stdpageref
Uchar
Unicode
characters
Int
p
stdpageref
Int
integer
values
Option
p
stdpageref
Option
option
values
Pair
p
stdpageref
Pair
pairs
of
values
Result
p
stdpageref
Result
result
values
Effect
p
stdpageref
Effect
effect
handlers
Either
p
stdpageref
Either
either
values
Hashtbl
p
stdpageref
Hashtbl
hash
tables
and
hash
functions
Random
p
stdpageref
Random
pseudo
random
number
generator
Set
p
stdpageref
Set
sets
over
ordered
types
Map
p
stdpageref
Map
association
tables
over
ordered
types
MoreLabels
p
stdpageref
MoreLabels
labelized
versions
of
Hashtbl
Set
and
Map
Oo
p
stdpageref
Oo
useful
functions
on
objects
Stack
p
stdpageref
Stack
last
in
first
out
stacks
Queue
p
stdpageref
Queue
first
in
first
out
queues
Pqueue
p
stdpageref
Pqueue
priority
queues
Buffer
p
stdpageref
Buffer
buffers
that
grow
on
demand
Dynarray
p
stdpageref
Dynarray
dynamic
arrays
arrays
that
grow
on
demand
Seq
p
stdpageref
Seq
functional
iterators
Lazy
p
stdpageref
Lazy
delayed
evaluation
Weak
p
stdpageref
Weak
references
that
don
t
prevent
objects
from
being
garbage
collected
Atomic
p
stdpageref
Atomic
atomic
references
for
compatibility
with
concurrent
runtimes
Ephemeron
p
stdpageref
Ephemeron
ephemerons
and
weak
hash
tables
Bigarray
p
stdpageref
Bigarray
large
multi
dimensional
numerical
arrays
Iarray
p
stdpageref
Iarray
immutable
arrays
end
tabular
subsubsection
sss
stdlib
arith
Arithmetic
begin
tabular
lll
Complex
p
stdpageref
Complex
complex
numbers
Float
p
stdpageref
Float
floating
point
numbers
Int32
p
stdpageref
Int32
operations
on
32
bit
integers
Int64
p
stdpageref
Int64
operations
on
64
bit
integers
Nativeint
p
stdpageref
Nativeint
operations
on
platform
native
integers
end
tabular
subsubsection
sss
stdlib
io
input
output
begin
tabular
lll
In
channel
p
stdpageref
In
channel
input
channels
Out
channel
p
stdpageref
Out
channel
output
channels
Format
p
stdpageref
Format
pretty
printing
with
automatic
indentation
and
line
breaking
Marshal
p
stdpageref
Marshal
marshaling
of
data
structures
Printf
p
stdpageref
Printf
formatting
printing
functions
Scanf
p
stdpageref
Scanf
formatted
input
functions
Digest
p
stdpageref
Digest
MD5
message
digest
end
tabular
subsubsection
sss
stdlib
parsing
Parsing
begin
tabular
lll
Lexing
p
stdpageref
Lexing
the
run
time
library
for
lexers
generated
by
ocamllex
Parsing
p
stdpageref
Parsing
the
run
time
library
for
parsers
generated
by
ocamlyacc
end
tabular
subsubsection
sss
stdlib
system
System
interface
begin
tabular
lll
Arg
p
stdpageref
Arg
parsing
of
command
line
arguments
Callback
p
stdpageref
Callback
registering
OCaml
functions
to
be
called
from
C
Filename
p
stdpageref
Filename
operations
on
file
names
Gc
p
stdpageref
Gc
memory
management
control
and
statistics
Printexc
p
stdpageref
Printexc
a
catch
all
exception
handler
Sys
p
stdpageref
Sys
system
interface
end
tabular
subsubsection
sss
stdlib
multicore
Multicore
interface
begin
tabular
lll
Domain
p
stdpageref
Domain
domain
spawn
and
join
Mutex
p
stdpageref
Mutex
mutual
exclusion
locks
Condition
p
stdpageref
Condition
condition
variables
Semaphore
p
stdpageref
Semaphore
semaphores
Effect
p
stdpageref
Effect
deep
and
shallow
effect
handlers
end
tabular
subsubsection
sss
stdlib
misc
Misc
begin
tabular
lll
Fun
p
stdpageref
Fun
function
values
Type
p
stdpageref
Type
type
introspection
Repr
p
stdpageref
Repr
functions
defined
on
the
low
level
representation
of
values
end
tabular
end
latexonly
begin
linklist
stddocitem
Arg
parsing
of
command
line
arguments
stddocitem
Array
array
operations
stddocitem
ArrayLabels
array
operations
with
labels
stddocitem
Atomic
atomic
references
stddocitem
Bigarray
large
multi
dimensional
numerical
arrays
stddocitem
Bool
boolean
values
stddocitem
Buffer
extensible
buffers
stddocitem
Bytes
byte
sequences
stddocitem
BytesLabels
byte
sequences
with
labels
stddocitem
Callback
registering
OCaml
values
with
the
C
runtime
stddocitem
Char
character
operations
stddocitem
Complex
complex
numbers
stddocitem
Condition
condition
variables
to
synchronize
between
threads
stddocitem
Domain
Domain
spawn
join
and
domain
local
variables
stddocitem
Digest
MD5
message
digest
stddocitem
Dynarray
Dynamic
arrays
stddocitem
Iarray
Immutable
arrays
stddocitem
Effect
deep
and
shallow
effect
handlers
stddocitem
Either
either
values
stddocitem
Ephemeron
Ephemerons
and
weak
hash
table
stddocitem
Filename
operations
on
file
names
stddocitem
Float
floating
point
numbers
stddocitem
Format
pretty
printing
stddocitem
Fun
function
values
stddocitem
Gc
memory
management
control
and
statistics
finalized
values
stddocitem
Hashtbl
hash
tables
and
hash
functions
stddocitem
In
channel
input
channels
stddocitem
Int
integers
stddocitem
Int32
32
bit
integers
stddocitem
Int64
64
bit
integers
stddocitem
Lazy
deferred
computations
stddocitem
Lexing
the
run
time
library
for
lexers
generated
by
texttt
ocamllex
stddocitem
List
list
operations
stddocitem
ListLabels
list
operations
with
labels
stddocitem
Map
association
tables
over
ordered
types
stddocitem
Marshal
marshaling
of
data
structures
stddocitem
MoreLabels
include
modules
texttt
Hashtbl
texttt
Map
and
texttt
Set
with
labels
stddocitem
Mutex
locks
for
mutual
exclusion
stddocitem
Nativeint
processor
native
integers
stddocitem
Oo
object
oriented
extension
stddocitem
Option
option
values
stddocitem
Out
channel
output
channels
stddocitem
Pair
pairs
of
values
stddocitem
Parsing
the
run
time
library
for
parsers
generated
by
texttt
ocamlyacc
stddocitem
Pqueue
priority
queues
stddocitem
Printexc
facilities
for
printing
exceptions
stddocitem
Printf
formatting
printing
functions
stddocitem
Queue
first
in
first
out
queues
stddocitem
Random
pseudo
random
number
generator
PRNG
stddocitem
Repr
functions
defined
on
the
low
level
representation
of
values
stddocitem
Result
result
values
stddocitem
Scanf
formatted
input
functions
stddocitem
Seq
functional
iterators
stddocitem
Set
sets
over
ordered
types
stddocitem
Semaphore
semaphores
another
thread
synchronization
mechanism
stddocitem
Stack
last
in
first
out
stacks
stddocitem
StdLabels
include
modules
texttt
Array
texttt
List
texttt
String
and
texttt
Iarray
with
labels
stddocitem
String
string
operations
stddocitem
StringLabels
string
operations
with
labels
stddocitem
Sys
system
interface
stddocitem
Type
type
introspection
stddocitem
Uchar
Unicode
characters
stddocitem
Unit
unit
values
stddocitem
Weak
arrays
of
weak
pointers
ifouthtml
else
input
Ocaml
operators
fi
end
linklist
chapter
The
compiler
front
end
label
c
parsinglib
cutname
parsing
html
label
Compiler
libs
redirect
references
to
compiler
libs
mld
here
This
chapter
describes
the
OCaml
front
end
which
declares
the
abstract
syntax
tree
used
by
the
compiler
provides
a
way
to
parse
print
and
pretty
print
OCaml
code
and
ultimately
allows
one
to
write
abstract
syntax
tree
preprocessors
invoked
via
the
tt
ppx
flag
see
chapters
ref
c
camlc
and
ref
c
nativecomp
It
is
important
to
note
that
the
exported
front
end
interface
follows
the
evolution
of
the
OCaml
language
and
implementation
and
thus
does
not
provide
bf
any
backwards
compatibility
guarantees
The
front
end
is
a
part
of
compiler
libs
library
Programs
that
use
the
compiler
libs
library
should
be
built
as
follows
begin
alltt
ocamlfind
ocamlc
var
other
options
package
compiler
libs
common
var
other
files
ocamlfind
ocamlopt
var
other
options
package
compiler
libs
common
var
other
files
end
alltt
Use
of
the
tt
ocamlfind
utility
is
recommended
However
if
this
is
not
possible
an
alternative
method
may
be
used
begin
alltt
ocamlc
var
other
options
I
compiler
libs
ocamlcommon
cma
var
other
files
ocamlopt
var
other
options
I
compiler
libs
ocamlcommon
cmxa
var
other
files
end
alltt
For
interactive
use
of
the
compiler
libs
library
start
ocaml
and
type
load
compiler
libs
ocamlcommon
cma
Some
of
the
files
below
are
commented
out
as
the
documentation
is
too
poor
or
they
are
thought
to
be
nonessential
begin
linklist
ifouthtml
Ast
helper
is
excluded
from
the
PDF
and
text
manuals
It
is
over
20
pages
long
and
does
not
have
doc
comments
It
is
expected
that
Ast
helper
will
be
only
useful
in
the
HTML
manual
to
look
up
signatures
compilerdocitem
Ast
helper
helper
functions
for
AST
construction
fi
compilerdocitem
Ast
mapper
ppx
rewriter
interface
compilerdocitem
Asttypes
auxiliary
types
used
by
Parsetree
item
ahref
compilerlibref
Lexer
html
Module
texttt
Lexer
OCaml
syntax
lexing
compilerdocitem
Location
source
code
locations
compilerdocitem
Longident
long
identifiers
compilerdocitem
Parse
OCaml
syntax
parsing
compilerdocitem
Parsetree
OCaml
syntax
tree
compilerdocitem
Pprintast
OCaml
syntax
printing
item
ahref
compilerlibref
Printast
html
Module
texttt
Printast
AST
printing
end
linklist
chapter
The
unix
library
Unix
system
calls
HEVEA
cutname
libunix
html
label
c
unix
The
unix
library
makes
many
Unix
system
calls
and
system
related
library
functions
available
to
OCaml
programs
This
chapter
describes
briefly
the
functions
provided
Refer
to
sections
2
and
3
of
the
Unix
manual
for
more
details
on
the
behavior
of
these
functions
ifouthtml
begin
linklist
libdocitem
Unix
Unix
system
calls
libdocitem
UnixLabels
Labeled
Unix
system
calls
end
linklist
fi
Not
all
functions
are
provided
by
all
Unix
variants
If
some
functions
are
not
available
they
will
raise
Invalid
arg
when
called
Programs
that
use
the
unix
library
must
be
linked
as
follows
begin
alltt
ocamlc
var
other
options
I
unix
unix
cma
var
other
files
ocamlopt
var
other
options
I
unix
unix
cmxa
var
other
files
end
alltt
For
interactive
use
of
the
unix
library
do
begin
alltt
ocamlmktop
o
mytop
I
unix
unix
cma
mytop
end
alltt
or
if
dynamic
linking
of
C
libraries
is
supported
on
your
platform
start
ocaml
and
type
begin
caml
example
toplevel
directory
unix
load
unix
cma
end
caml
example
begin
latexonly
begin
windows
A
fairly
complete
emulation
of
the
Unix
system
calls
is
provided
in
the
Windows
version
of
OCaml
The
end
of
this
chapter
gives
more
information
on
the
functions
that
are
not
supported
under
Windows
end
windows
begin
linklist
libdocitem
Unix
Unix
system
calls
end
linklist
section
UnixLabels
Module
texttt
UnixLabels
labelized
version
of
the
interface
index
UnixLabels
module
verb
UnixLabels
module
This
module
is
identical
to
Unix
ref
Unix
and
only
differs
by
the
addition
of
labels
You
may
see
these
labels
directly
by
looking
at
unixLabels
mli
or
by
using
the
ocamlbrowser
tool
newpage
end
latexonly
begin
windows
The
Cygwin
port
of
OCaml
fully
implements
all
functions
from
the
Unix
module
The
native
Win32
ports
implement
a
subset
of
them
Below
is
a
list
of
the
functions
that
are
not
implemented
or
only
partially
implemented
by
the
Win32
ports
Functions
not
mentioned
are
fully
implemented
and
behave
as
described
previously
in
this
chapter
end
windows
begin
tableau
l
p
8cm
Functions
Comment
entree
fork
not
implemented
use
create
process
or
threads
entree
wait
not
implemented
use
waitpid
entree
waitpid
can
only
wait
for
a
given
PID
not
any
child
process
entree
getppid
not
implemented
meaningless
under
Windows
entree
nice
not
implemented
entree
truncate
ftruncate
implemented
since
4
10
0
entree
link
implemented
since
3
02
entree
fchmod
not
implemented
entree
chown
fchown
not
implemented
make
no
sense
on
a
DOS
file
system
entree
umask
not
implemented
entree
access
execute
permission
X
OK
cannot
be
tested
it
just
tests
for
read
permission
instead
entree
chroot
not
implemented
entree
mkfifo
not
implemented
entree
symlink
readlink
implemented
since
4
03
0
entree
kill
partially
implemented
since
4
00
0
only
the
sigkill
signal
is
implemented
entree
sigprocmask
sigpending
sigsuspend
not
implemented
no
inter
process
signals
on
Windows
entree
pause
not
implemented
no
inter
process
signals
in
Windows
entree
alarm
not
implemented
entree
times
partially
implemented
will
not
report
timings
for
child
processes
entree
getitimer
setitimer
not
implemented
entree
getuid
geteuid
getgid
getegid
always
return
1
entree
setuid
setgid
setgroups
initgroups
not
implemented
entree
getgroups
always
returns
1
since
2
00
entree
getpwnam
getpwuid
always
raise
Not
found
entree
getgrnam
getgrgid
always
raise
Not
found
entree
type
socket
domain
PF
INET
is
fully
supported
PF
INET6
is
fully
supported
since
4
01
0
PF
UNIX
is
supported
since
4
14
0
but
only
works
on
Windows
10
1803
and
later
entree
establish
server
not
implemented
use
threads
entree
terminal
functions
tc
not
implemented
entree
setsid
not
implemented
end
tableau
Check
reference
to
manual
section
in
ml
files
cross
reference
checker
auxfile
tex
aux
src
ml
checks
that
all
expression
and
let
bindings
in
src
ml
annotated
with
manual
ref
tex
label
are
integer
tuple
literals
or
lists
e
g
let
manual
ref
sec
major
ref
1
1
or
let
manual
ref
sec
major
ref
1
1
or
let
ref
3
manual
ref
ch
pentatonic
and
that
their
values
are
consistent
with
the
computed
references
for
the
payload
labels
e
g
sec
major
ch
pentatonic
present
in
the
TeX
auxiliary
file
tex
aux
1
Error
printing
type
error
Reference
mismatch
of
loc
Location
t
label
string
ocaml
int
list
tex
int
list
Unknown
label
of
Location
t
string
Tuple
or
list
expected
of
Location
t
No
aux
file
Wrong
attribute
payload
of
Location
t
let
pp
ref
ppf
Format
doc
pp
print
list
pp
sep
fun
ppf
Format
doc
pp
print
string
ppf
Format
doc
pp
print
int
ppf
let
print
error
error
Location
print
report
Format
std
formatter
match
error
with
Tuple
or
list
expected
loc
Location
errorf
loc
Integer
tuple
or
list
expected
after
manual
reference
annotation
Unknown
label
loc
label
Location
errorf
loc
hov
Unknown
manual
label
s
label
Reference
mismatch
r
Location
errorf
loc
r
loc
v
2
References
for
label
S
do
not
match
OCaml
side
a
manual
a
r
label
pp
ref
r
ocaml
pp
ref
r
tex
No
aux
file
Location
errorf
No
aux
file
provided
Wrong
attribute
payload
loc
Location
errorf
loc
Wrong
payload
for
manual
ref
1
Main
types
Maps
of
ocaml
reference
to
manual
labels
module
Refs
Map
Make
String
Reference
extracted
from
TeX
aux
files
type
tex
reference
label
string
pos
int
list
level
string
type
status
Ok
Bad
Unknown
Reference
extracted
from
OCaml
source
files
type
ml
reference
loc
Location
t
pos
int
list
status
status
1
Consistency
check
let
check
consistency
ref
tex
reference
loc
pos
if
ref
pos
pos
then
loc
pos
status
Ok
else
begin
print
error
Reference
mismatch
loc
label
ref
label
tex
ref
pos
ocaml
pos
loc
pos
status
Bad
end
let
rec
check
final
status
label
error
function
status
Ok
error
status
Bad
true
status
Unknown
loc
print
error
Unknown
label
loc
label
true
1
Data
extraction
from
TeX
side
module
TeX
struct
Read
reference
information
from
a
line
of
the
aux
file
let
scan
s
try
Scanf
sscanf
s
newlabel
s
s
d
s
s
s
s
fun
label
position
string
level
let
pos
List
map
int
of
string
String
split
on
char
position
string
in
Some
label
level
pos
with
Scanf
Scan
failure
None
Failure
None
let
check
line
refs
line
match
scan
line
with
None
refs
Some
ref
match
Refs
find
opt
ref
label
refs
with
None
refs
Some
l
Refs
add
ref
label
List
map
check
consistency
ref
l
refs
let
check
all
aux
refs
let
chan
open
in
aux
in
let
rec
lines
refs
let
s
try
Some
input
line
chan
with
End
of
file
None
in
match
s
with
None
refs
Some
line
lines
check
line
refs
line
in
let
refs
lines
refs
in
close
in
chan
let
error
Refs
fold
fun
label
ocaml
refs
error
List
fold
left
check
final
status
label
error
ocaml
refs
refs
false
in
if
error
then
exit
2
else
exit
0
end
1
Extract
references
from
Ocaml
source
files
module
OCaml
refs
struct
let
parse
sourcefile
Pparse
parse
implementation
tool
name
manual
cross
reference
check
sourcefile
search
for
an
attribute
manual
ref
tex
label
name
let
manual
reference
attribute
attr
let
open
Parsetree
in
if
attr
attr
name
Location
txt
manual
ref
then
None
else
begin
match
attr
attr
payload
with
PStr
pstr
desc
Pstr
eval
pexp
desc
Pexp
constant
pconst
desc
Pconst
string
s
Some
s
print
error
Wrong
attribute
payload
attr
attr
loc
Some
triggers
an
error
end
let
rec
label
from
attributes
function
None
a
q
match
manual
reference
attribute
a
with
Some
as
x
x
None
label
from
attributes
q
let
int
e
let
open
Parsetree
in
match
e
pexp
desc
with
Pexp
constant
pconst
desc
Pconst
integer
s
int
of
string
s
raise
Exit
let
int
list
l
try
Some
List
map
int
l
with
Exit
None
We
keep
a
list
of
OCaml
side
references
to
the
same
label
let
add
ref
label
ref
refs
let
l
match
Refs
find
opt
label
refs
with
None
ref
Some
l
ref
l
in
Refs
add
label
l
refs
let
rec
try
parse
as
list
e
match
e
Parsetree
pexp
desc
with
Parsetree
Pexp
construct
txt
Lident
Some
pexp
desc
Pexp
tuple
None
x
None
rest
int
x
try
parse
as
list
rest
Parsetree
Pexp
construct
txt
Lident
None
raise
Exit
let
list
expression
e
try
Some
try
parse
as
list
e
with
Exit
None
let
inner
expr
loc
e
let
tuple
expected
print
error
Tuple
or
list
expected
loc
in
match
e
Parsetree
pexp
desc
with
Parsetree
Pexp
tuple
l
begin
match
int
list
List
map
snd
l
with
None
tuple
expected
Some
pos
pos
end
Parsetree
Pexp
constant
pconst
desc
Pconst
integer
n
int
of
string
n
begin
match
list
expression
e
with
Some
list
list
None
tuple
expected
end
extract
from
let
manual
ref
label
x
1
2
let
value
binding
m
iterator
vb
let
open
Parsetree
in
begin
match
label
from
attributes
vb
pvb
attributes
with
None
Some
label
let
pos
inner
expr
vb
pvb
loc
vb
pvb
expr
in
m
add
ref
label
loc
vb
pvb
loc
pos
status
Unknown
m
end
iterator
Ast
iterator
expr
iterator
vb
pvb
expr
extract
from
1
2
manual
ref
label
let
expr
m
iterator
e
let
open
Parsetree
in
begin
match
label
from
attributes
e
pexp
attributes
with
None
Some
label
let
pos
inner
expr
e
pexp
loc
e
in
m
add
ref
label
loc
e
pexp
loc
pos
status
Unknown
m
end
Ast
iterator
default
iterator
expr
iterator
e
let
from
ast
m
ast
let
iterator
let
value
binding
value
binding
m
in
let
expr
expr
m
in
Ast
iterator
default
iterator
with
value
binding
expr
in
iterator
structure
iterator
ast
let
from
file
m
f
from
ast
m
parse
f
end
1
Argument
handling
and
main
function
let
usage
cross
reference
check
auxfile
file
aux
file
1
file
n
checks
that
the
cross
reference
annotated
with
manual
cross
reference
are
consistent
with
the
provided
auxiliary
TeX
file
the
auxiliary
file
containing
reference
to
be
checked
let
aux
file
ref
None
let
args
auxfile
Arg
String
fun
s
aux
file
Some
s
set
the
reference
file
let
let
m
ref
Refs
empty
in
Arg
parse
args
OCaml
refs
from
file
m
usage
match
aux
file
with
None
print
error
No
aux
file
exit
2
Some
aux
let
error
TeX
check
all
aux
m
in
if
error
then
exit
2
else
exit
0
type
environment
Normal
Caml
Verbatim
of
string
string
Verbatim
like
let
in
quotes
ref
false
let
is
alpha
c
A
c
c
Z
a
c
c
z
let
is
prefix
prefix
str
let
length
prefix
String
length
prefix
in
let
length
str
String
length
str
in
if
length
prefix
length
str
then
false
else
String
sub
str
0
length
prefix
prefix
let
escape
function
n
char123
char125
char94
char95
char92
char126
char38
textquotesingle
textasciigrave
let
process
normal
line
line
let
verb
mark
char
option
ref
ref
None
in
let
l
String
length
line
in
let
i
ref
0
in
while
i
l
do
match
verb
mark
with
None
match
line
i
with
let
r
if
in
quotes
then
else
machine
in
print
string
r
in
quotes
not
in
quotes
incr
i
if
in
quotes
then
begin
if
i
l
1
line
i
1
line
i
1
then
incr
i
let
t
escape
line
i
in
if
t
then
print
string
t
else
print
char
line
i
incr
i
end
else
if
is
prefix
verb
String
sub
line
i
l
i
not
is
alpha
line
i
5
then
begin
i
i
5
verb
mark
Some
line
i
print
string
verb
print
char
line
i
incr
i
end
else
print
char
incr
i
if
in
quotes
escape
line
i
then
print
string
escape
line
i
else
print
char
line
i
incr
i
Some
mark
if
line
i
mark
then
verb
mark
None
else
if
line
i
line
i
then
Printf
eprintf
Warning
c
found
in
verb
n
line
i
print
char
line
i
incr
i
done
let
process
line
line
function
Normal
if
is
prefix
begin
caml
line
is
prefix
begin
rawhtml
line
then
print
string
line
Verbatim
like
else
if
is
prefix
begin
camlexample
line
then
print
endline
line
Caml
else
if
is
prefix
begin
verbatim
line
then
begin
print
string
begin
machineenv
Verbatim
end
verbatim
end
machineenv
end
else
if
is
prefix
begin
ocamldoccode
line
then
begin
print
string
begin
ocamldoccode
Verbatim
end
ocamldoccode
end
ocamldoccode
end
else
begin
process
normal
line
line
if
in
quotes
then
print
string
escape
n
else
print
newline
Normal
end
Caml
print
endline
line
if
is
prefix
end
camlexample
line
then
Normal
else
Caml
Verbatim
verbatim
end
in
verbatim
end
out
as
env
if
is
prefix
verbatim
end
in
line
then
begin
print
string
verbatim
end
out
Normal
end
else
begin
for
i
0
to
String
length
line
1
do
let
c
line
i
in
let
t
escape
c
in
if
c
c
n
t
then
print
char
c
else
print
string
t
done
print
newline
env
end
Verbatim
like
print
endline
line
if
is
prefix
end
caml
line
is
prefix
end
rawhtml
line
then
Normal
else
Verbatim
like
let
rec
process
input
env
match
input
line
stdin
with
exception
End
of
file
line
let
env
process
line
line
env
in
process
input
env
let
main
print
endline
THIS
FILE
IS
GENERATED
print
newline
process
input
Normal
let
main
let
main
let
lexbuf
Lexing
from
channel
stdin
in
Transf
main
lexbuf
exit
0
Printexc
print
main
